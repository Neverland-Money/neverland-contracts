{
  "networkName": "monadMainnet",
  "chainId": 143,
  "contract": "DustLock",
  "metadata": {
    "compiler": {
      "version": "0.8.30+commit.73712a01"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_forwarder",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "name": "AddressZero",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "AlreadyOwned",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "AmountTooBig",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "AmountTooSmall",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "DepositForLockDurationTooShort",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ERC721ReceiverRejectedTokens",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ERC721TransferToNonERC721ReceiverImplementer",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidRevenueRewardContract",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidTokenId",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidWithdrawPenalty",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "LockDurationNotInFuture",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "LockDurationTooLong",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "LockDurationTooShort",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "LockExpired",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "LockNotExpired",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NoLockFound",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotApprovedOrOwner",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotOwner",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotPendingTeam",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotPermanentLock",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotTeam",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            }
          ],
          "name": "PRBMath_MulDiv18_Overflow",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "denominator",
              "type": "uint256"
            }
          ],
          "name": "PRBMath_MulDiv_Overflow",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            }
          ],
          "name": "PRBMath_UD60x18_Convert_Overflow",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "PermanentLock",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "SafeCastOverflow",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "SafeCastUnderflow",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "SameAddress",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "SameNFT",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "SplitNotAllowed",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ZeroAmount",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "approved",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "Approval",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "operator",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bool",
              "name": "approved",
              "type": "bool"
            }
          ],
          "name": "ApprovalForAll",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "string",
              "name": "oldBaseURI",
              "type": "string"
            },
            {
              "indexed": false,
              "internalType": "string",
              "name": "newBaseURI",
              "type": "string"
            }
          ],
          "name": "BaseURIUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_fromTokenId",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_toTokenId",
              "type": "uint256"
            }
          ],
          "name": "BatchMetadataUpdate",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "enum IDustLock.DepositType",
              "name": "depositType",
              "type": "uint8"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "locktime",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "ts",
              "type": "uint256"
            }
          ],
          "name": "Deposit",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amountReturned",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "ts",
              "type": "uint256"
            }
          ],
          "name": "EarlyWithdraw",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "oldPenalty",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "newPenalty",
              "type": "uint256"
            }
          ],
          "name": "EarlyWithdrawPenaltyUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "oldTreasury",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newTreasury",
              "type": "address"
            }
          ],
          "name": "EarlyWithdrawTreasuryUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            }
          ],
          "name": "Initialized",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "_owner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_ts",
              "type": "uint256"
            }
          ],
          "name": "LockPermanent",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "_sender",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "_from",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "_to",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_amountFrom",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_amountTo",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_amountFinal",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_locktime",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_ts",
              "type": "uint256"
            }
          ],
          "name": "Merge",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "MetadataUpdate",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "oldAmount",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "newAmount",
              "type": "uint256"
            }
          ],
          "name": "MinLockAmountUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "oldReward",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newReward",
              "type": "address"
            }
          ],
          "name": "RevenueRewardUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "_from",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "_tokenId1",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "_tokenId2",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "_sender",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_splitAmount1",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_splitAmount2",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_locktime",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_ts",
              "type": "uint256"
            }
          ],
          "name": "Split",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bool",
              "name": "allowed",
              "type": "bool"
            }
          ],
          "name": "SplitPermissionUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "prevSupply",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            }
          ],
          "name": "Supply",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "oldTeam",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newTeam",
              "type": "address"
            }
          ],
          "name": "TeamAccepted",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "currentTeam",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "cancelledTeam",
              "type": "address"
            }
          ],
          "name": "TeamProposalCancelled",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "currentTeam",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "proposedTeam",
              "type": "address"
            }
          ],
          "name": "TeamProposed",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "Transfer",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "_owner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_ts",
              "type": "uint256"
            }
          ],
          "name": "UnlockPermanent",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "provider",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "ts",
              "type": "uint256"
            }
          ],
          "name": "Withdraw",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "CLOCK_MODE",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "acceptTeam",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_approved",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "approve",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_owner",
              "type": "address"
            }
          ],
          "name": "balanceOf",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "balanceOfNFT",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_t",
              "type": "uint256"
            }
          ],
          "name": "balanceOfNFTAt",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "name": "canSplit",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "cancelTeamProposal",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "checkpoint",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "clock",
          "outputs": [
            {
              "internalType": "uint48",
              "name": "",
              "type": "uint48"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "name": "createLock",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            }
          ],
          "name": "createLockFor",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "name": "createLockPermanent",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            }
          ],
          "name": "createLockPermanentFor",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_value",
              "type": "uint256"
            }
          ],
          "name": "depositFor",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "earlyWithdraw",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "earlyWithdrawPenalty",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "earlyWithdrawTreasury",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "epoch",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "forwarder",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "getApproved",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_value",
              "type": "uint256"
            }
          ],
          "name": "increaseAmount",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "name": "increaseUnlockTime",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_forwarder",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_token",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "_baseURI",
              "type": "string"
            }
          ],
          "name": "initialize",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_operator",
              "type": "address"
            }
          ],
          "name": "isApprovedForAll",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_spender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "isApprovedOrOwner",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "forwarder",
              "type": "address"
            }
          ],
          "name": "isTrustedForwarder",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "lockPermanent",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "locked",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "amount",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "effectiveStart",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "end",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isPermanent",
                  "type": "bool"
                }
              ],
              "internalType": "struct IDustLock.LockedBalance",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_to",
              "type": "uint256"
            }
          ],
          "name": "merge",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "minLockAmount",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "name",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "ownerOf",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "ownerToNFTokenIdList",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "pendingTeam",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "permanentLockBalance",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_loc",
              "type": "uint256"
            }
          ],
          "name": "pointHistory",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "bias",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "slope",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "ts",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blk",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "permanentLockBalance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IDustLock.GlobalPoint",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_newTeam",
              "type": "address"
            }
          ],
          "name": "proposeTeam",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "revenueReward",
          "outputs": [
            {
              "internalType": "contract IRevenueReward",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "safeTransferFrom",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "_data",
              "type": "bytes"
            }
          ],
          "name": "safeTransferFrom",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_operator",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "_approved",
              "type": "bool"
            }
          ],
          "name": "setApprovalForAll",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "newBaseURI",
              "type": "string"
            }
          ],
          "name": "setBaseURI",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_earlyWithdrawPenalty",
              "type": "uint256"
            }
          ],
          "name": "setEarlyWithdrawPenalty",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_account",
              "type": "address"
            }
          ],
          "name": "setEarlyWithdrawTreasury",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "newMinLockAmount",
              "type": "uint256"
            }
          ],
          "name": "setMinLockAmount",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract IRevenueReward",
              "name": "_revenueReward",
              "type": "address"
            }
          ],
          "name": "setRevenueReward",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "slopeChanges",
          "outputs": [
            {
              "internalType": "int256",
              "name": "",
              "type": "int256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "name": "split",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_tokenId2",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "supply",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes4",
              "name": "_interfaceID",
              "type": "bytes4"
            }
          ],
          "name": "supportsInterface",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "symbol",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "team",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_account",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "_bool",
              "type": "bool"
            }
          ],
          "name": "toggleSplit",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "token",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "tokenId",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "tokenURI",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "totalSupply",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_timestamp",
              "type": "uint256"
            }
          ],
          "name": "totalSupplyAt",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "transferFrom",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "unlockPermanent",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "userPointEpoch",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_loc",
              "type": "uint256"
            }
          ],
          "name": "userPointHistory",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "bias",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "slope",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "ts",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blk",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "permanent",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IDustLock.UserPoint",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "version",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_tokenId",
              "type": "uint256"
            }
          ],
          "name": "withdraw",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "devdoc": {
        "events": {
          "Approval(address,address,uint256)": {
            "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
          },
          "ApprovalForAll(address,address,bool)": {
            "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
          },
          "BaseURIUpdated(string,string)": {
            "params": {
              "newBaseURI": "New base URI",
              "oldBaseURI": "Previous base URI"
            }
          },
          "BatchMetadataUpdate(uint256,uint256)": {
            "details": "This event emits when the metadata of a range of tokens is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFTs."
          },
          "Deposit(address,uint256,uint8,uint256,uint256,uint256)": {
            "params": {
              "depositType": "Type of deposit operation (create, increase amount, etc.)",
              "locktime": "Timestamp when the lock expires",
              "provider": "Address depositing the tokens",
              "tokenId": "ID of the veNFT being created or modified",
              "ts": "Timestamp when the deposit occurred",
              "value": "Amount of tokens deposited"
            }
          },
          "EarlyWithdraw(address,uint256,uint256,uint256,uint256)": {
            "params": {
              "amountReturned": "Amount returned to the user after penalty",
              "provider": "Address receiving the withdrawn tokens",
              "tokenId": "ID of the veNFT being withdrawn",
              "ts": "Timestamp when the early withdrawal occurred",
              "value": "Original locked amount"
            }
          },
          "EarlyWithdrawPenaltyUpdated(uint256,uint256)": {
            "params": {
              "newPenalty": "New penalty in basis points",
              "oldPenalty": "Previous penalty in basis points"
            }
          },
          "EarlyWithdrawTreasuryUpdated(address,address)": {
            "params": {
              "newTreasury": "New treasury address",
              "oldTreasury": "Previous treasury address"
            }
          },
          "Initialized(uint8)": {
            "details": "Triggered when the contract has been initialized or reinitialized."
          },
          "LockPermanent(address,uint256,uint256,uint256)": {
            "params": {
              "_owner": "Address that owns the veNFT",
              "_tokenId": "ID of the veNFT being locked permanently",
              "_ts": "Timestamp when the permanent lock was created",
              "amount": "Amount of tokens in the lock"
            }
          },
          "Merge(address,uint256,uint256,uint256,uint256,uint256,uint256,uint256)": {
            "params": {
              "_amountFinal": "Final amount of tokens in the destination veNFT after merge",
              "_amountFrom": "Amount of tokens in the source veNFT",
              "_amountTo": "Amount of tokens in the destination veNFT before merge",
              "_from": "Source veNFT ID (burned in the process)",
              "_locktime": "New lock expiry time for the merged veNFT",
              "_sender": "Address initiating the merge",
              "_to": "Destination veNFT ID (receives combined balance)",
              "_ts": "Timestamp when the merge occurred"
            }
          },
          "MetadataUpdate(uint256)": {
            "details": "This event emits when the metadata of a token is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFT."
          },
          "MinLockAmountUpdated(uint256,uint256)": {
            "params": {
              "newAmount": "New minimum lock amount",
              "oldAmount": "Previous minimum lock amount"
            }
          },
          "RevenueRewardUpdated(address,address)": {
            "params": {
              "newReward": "New revenue reward contract address",
              "oldReward": "Previous revenue reward contract address"
            }
          },
          "Split(uint256,uint256,uint256,address,uint256,uint256,uint256,uint256)": {
            "params": {
              "_from": "Original veNFT ID being split (burned in the process)",
              "_locktime": "Lock expiry time for both new veNFTs",
              "_sender": "Address initiating the split",
              "_splitAmount1": "Amount of tokens allocated to the first veNFT",
              "_splitAmount2": "Amount of tokens allocated to the second veNFT",
              "_tokenId1": "First new veNFT ID created from the split",
              "_tokenId2": "Second new veNFT ID created from the split",
              "_ts": "Timestamp when the split occurred"
            }
          },
          "SplitPermissionUpdated(address,bool)": {
            "params": {
              "account": "Address whose permission is updated",
              "allowed": "Whether splitting is now allowed for the account"
            }
          },
          "Supply(uint256,uint256)": {
            "params": {
              "prevSupply": "Previous total locked supply",
              "supply": "New total locked supply"
            }
          },
          "TeamAccepted(address,address)": {
            "params": {
              "newTeam": "The new team address that accepted ownership",
              "oldTeam": "The previous team address"
            }
          },
          "TeamProposalCancelled(address,address)": {
            "params": {
              "cancelledTeam": "The proposed team address that was cancelled",
              "currentTeam": "The current team address that cancelled the proposal"
            }
          },
          "TeamProposed(address,address)": {
            "params": {
              "currentTeam": "The current team address that proposed the change",
              "proposedTeam": "The newly proposed team address"
            }
          },
          "Transfer(address,address,uint256)": {
            "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
          },
          "UnlockPermanent(address,uint256,uint256,uint256)": {
            "params": {
              "_owner": "Address that owns the veNFT",
              "_tokenId": "ID of the veNFT being unlocked",
              "_ts": "Timestamp when the permanent lock was unlocked",
              "amount": "Amount of tokens in the lock"
            }
          },
          "Withdraw(address,uint256,uint256,uint256)": {
            "params": {
              "provider": "Address receiving the withdrawn tokens",
              "tokenId": "ID of the veNFT being withdrawn",
              "ts": "Timestamp when the withdrawal occurred",
              "value": "Amount of tokens withdrawn"
            }
          }
        },
        "kind": "dev",
        "methods": {
          "CLOCK_MODE()": {
            "details": "Description of the clock"
          },
          "acceptTeam()": {
            "details": "This is the second step of the two-step ownership transfer process.      Only the pending team address can call this function.      Once called, the caller becomes the new team and the pending team is cleared.      This ensures that the new team controls the proposed address."
          },
          "approve(address,uint256)": {
            "details": "Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."
          },
          "balanceOf(address)": {
            "details": "Returns the number of tokens in ``owner``'s account."
          },
          "balanceOfNFT(uint256)": {
            "details": "Calculates voting power based on lock amount, remaining time, and permanent status      For standard locks: voting power = amount * (time_left / MAXTIME)      For permanent locks: voting power = amount (no time decay)      Returns 0 if called in the same block as a transfer due to checkpoint timing      This is the core function used for governance voting power determination",
            "params": {
              "_tokenId": "The ID of the veNFT to query voting power for"
            },
            "returns": {
              "_0": "The current voting power of the specified veNFT"
            }
          },
          "balanceOfNFTAt(uint256,uint256)": {
            "details": "Uses checkpoints to determine voting power at any point in the past      Crucial for governance systems that need to determine past voting power      For timestamps between checkpoints, calculates the interpolated value      Returns 0 for timestamps before the veNFT was created",
            "params": {
              "_t": "The timestamp at which to query the voting power",
              "_tokenId": "The ID of the veNFT to query historical voting power for"
            },
            "returns": {
              "_0": "The voting power of the specified veNFT at the requested timestamp"
            }
          },
          "cancelTeamProposal()": {
            "details": "Allows the current team to cancel a pending ownership transfer.      Only the current team can call this function.      This is useful if the team made an error in the proposed address.      After cancellation, a new proposal can be made."
          },
          "checkpoint()": {
            "details": "Updates the global point history with current voting power data      This is called automatically by most state-changing functions      but can be called manually to ensure up-to-date on-chain data"
          },
          "clock()": {
            "details": "Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting)."
          },
          "constructor": {
            "custom:oz-upgrades-unsafe-allow": "constructor"
          },
          "createLock(uint256,uint256)": {
            "details": "Creates a new veNFT representing the locked tokens      Lock duration is rounded down to the nearest week",
            "params": {
              "_lockDuration": "Number of seconds to lock tokens for (rounded down to nearest week)",
              "_value": "Amount of tokens to deposit and lock"
            },
            "returns": {
              "_0": "The ID of the newly created veNFT"
            }
          },
          "createLockFor(uint256,uint256,address)": {
            "details": "Creates a new veNFT representing the locked tokens and assigns it to the specified recipient      This is useful for protocols that want to create locks on behalf of their users      Lock duration is rounded down to the nearest week",
            "params": {
              "_lockDuration": "Number of seconds to lock tokens for (rounded down to nearest week)",
              "_to": "The address that will own the newly created veNFT",
              "_value": "Amount of tokens to deposit and lock"
            },
            "returns": {
              "_0": "The ID of the newly created veNFT"
            }
          },
          "createLockPermanent(uint256,uint256)": {
            "details": "UX convenience to perform \"create lock\" and \"make permanent\" in a single transaction      Follows the same validation as `createLock` (min amount, duration bounds, week rounding)",
            "params": {
              "_lockDuration": "Number of seconds to lock tokens for (rounded down to nearest week)",
              "_value": "Amount of tokens to deposit and lock"
            },
            "returns": {
              "_0": "tokenId The ID of the newly created veNFT"
            }
          },
          "createLockPermanentFor(uint256,uint256,address)": {
            "details": "UX convenience to mint the veNFT to `to` and set permanence in one transaction      Uses `to` as the owner for auth semantics; validation mirrors `createLock`",
            "params": {
              "_lockDuration": "Number of seconds to lock tokens for (rounded down to nearest week)",
              "_to": "The address that will own the newly created veNFT",
              "_value": "Amount of tokens to deposit and lock"
            },
            "returns": {
              "_0": "tokenId The ID of the newly created veNFT"
            }
          },
          "depositFor(uint256,uint256)": {
            "details": "Anyone (even a smart contract) can deposit tokens for someone else's lock      The deposit increases the lock amount but does not extend the lock time      Cannot be used for locks that have already expired",
            "params": {
              "_tokenId": "The ID of the veNFT to deposit for",
              "_value": "Amount of tokens to add to the existing lock"
            }
          },
          "earlyWithdraw(uint256)": {
            "details": "Allows users to exit a lock early but with a penalty fee applied      The penalty is proportional to both `earlyWithdrawPenalty` and remaining time until unlock      If the lock is permanent, it is internally converted back to a standard time-lock first and      the early withdraw penalty is computed using the restored lock window. Penalty fees are sent      to the `earlyWithdrawTreasury` address. Burns the veNFT and returns the nonpenalized portion      of tokens to the owner. Can only be called by the owner of the veNFT or an approved address",
            "params": {
              "_tokenId": "The ID of the veNFT to withdraw early from"
            }
          },
          "getApproved(uint256)": {
            "details": "Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."
          },
          "increaseAmount(uint256,uint256)": {
            "details": "Increases the amount of tokens in a lock while keeping the same unlock date      Can only be called by the owner of the veNFT or an approved address",
            "params": {
              "_tokenId": "The ID of the veNFT to increase the amount for",
              "_value": "Additional amount of tokens to add to the lock"
            }
          },
          "increaseUnlockTime(uint256,uint256)": {
            "details": "Increases the lock duration without changing the token amount      Cannot extend lock time of permanent locks      New lock time is rounded down to the nearest week      Can only be called by the owner of the veNFT or an approved address",
            "params": {
              "_lockDuration": "New number of seconds until tokens unlock (from current time)",
              "_tokenId": "The ID of the veNFT to extend the lock duration for"
            }
          },
          "initialize(address,address,string)": {
            "params": {
              "_baseURI": "base URI for NFT metadata",
              "_forwarder": "address of trusted forwarder",
              "_token": "`DUST` token address"
            }
          },
          "isApprovedForAll(address,address)": {
            "details": "Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"
          },
          "isApprovedOrOwner(address,uint256)": {
            "params": {
              "_spender": "The address to approve for the tokenId",
              "_tokenId": "The ID of the veNFT to be approved"
            },
            "returns": {
              "_0": "True if `_spender` is owner or approved for `_tokenId`, false otherwise"
            }
          },
          "lockPermanent(uint256)": {
            "details": "Converts a standard time-locked veNFT to a permanent lock      Once permanent, the veNFT cannot be withdrawn normally (even after the original lock time)      Permanent locks have constant voting power equal to the locked token amount with no time decay      Note: time served prior to permanence is not preserved for penalty calculations  if the owner      later calls `earlyWithdraw`, the position is first unlocked and the penalty window resets to a      full MAXTIME from the current timestamp      Can only be called by the owner of the veNFT or an approved address      Cannot be called on a lock that is already permanent",
            "params": {
              "_tokenId": "The ID of the veNFT to permanently lock"
            }
          },
          "locked(uint256)": {
            "details": "Returns information about lock amount, end time, and permanent status",
            "params": {
              "_tokenId": "The ID of the veNFT to query"
            },
            "returns": {
              "_0": "The LockedBalance struct containing lock information"
            }
          },
          "merge(uint256,uint256)": {
            "details": "The source veNFT is burned and its tokens are added to the destination veNFT      The lock duration/semantics of the destination veNFT are preserved      Rules:      - permanent + permanent: allowed (destination stays permanent)      - nonpermanent + permanent: allowed (permanent principal increases)      - permanent + nonpermanent: reverts      - expired source or destination: reverts      Can only be called by an address that owns or is approved for both veNFTs",
            "params": {
              "_from": "The ID of the source veNFT to merge from (will be burned)",
              "_to": "The ID of the destination veNFT to merge into (will receive the combined tokens)"
            }
          },
          "ownerOf(uint256)": {
            "details": "Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."
          },
          "pointHistory(uint256)": {
            "details": "Used to track historical voting power across all tokens at different points in time",
            "params": {
              "_loc": "The index of the checkpoint to retrieve"
            },
            "returns": {
              "_0": "The GlobalPoint data at the specified index"
            }
          },
          "proposeTeam(address)": {
            "details": "This is the first step of a two-step ownership transfer process.      Only the current team can propose a new team address.      The proposed address must accept ownership to complete the transfer.      This prevents accidental loss of admin control due to typos or wrong addresses.",
            "params": {
              "_newTeam": "The address of the proposed new team multisig"
            }
          },
          "safeTransferFrom(address,address,uint256)": {
            "details": "Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
          },
          "safeTransferFrom(address,address,uint256,bytes)": {
            "details": "Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
          },
          "setApprovalForAll(address,bool)": {
            "details": "Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."
          },
          "setBaseURI(string)": {
            "details": "Can only be called by the team address",
            "params": {
              "newBaseURI": "The new base URI to set for all tokens"
            }
          },
          "setEarlyWithdrawPenalty(uint256)": {
            "details": "Can only be called by the team address      Value is in basis points (0-10000), where 10000 = 100%",
            "params": {
              "_earlyWithdrawPenalty": "The new penalty percentage in basis points"
            }
          },
          "setEarlyWithdrawTreasury(address)": {
            "details": "Can only be called by the team address      The treasury address receives the penalty portion of tokens from early withdrawals",
            "params": {
              "_account": "The address of the new treasury that will receive penalty fees"
            }
          },
          "setMinLockAmount(uint256)": {
            "details": "Can only be called by the team address. This helps prevent spam and ensures meaningful lock amounts",
            "params": {
              "newMinLockAmount": "The new minimum lock amount in token units (with 18 decimals)"
            }
          },
          "setRevenueReward(address)": {
            "details": "Can only be called by the team address",
            "params": {
              "_revenueReward": "The new revenue reward contract"
            }
          },
          "split(uint256,uint256)": {
            "details": "This operation burns the original veNFT and creates two new ones      Both new veNFTs maintain the same lock end time as the original      Can only be called by an address that has split permission, and owns or is approved for the veNFT      If called by an approved address, that address will NOT have approval on the new veNFTs      (approvals on the parent do not carry over to children)      Requires that the caller is either the owner or specifically has been granted split permission      Cannot split permanent locks",
            "params": {
              "_amount": "The precise token amount to allocate to the second new veNFT",
              "_from": "The ID of the veNFT to split (will be burned)"
            },
            "returns": {
              "_tokenId1": "ID of the first new veNFT with (original amount - _amount) tokens",
              "_tokenId2": "ID of the second new veNFT with exactly _amount tokens"
            }
          },
          "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
          },
          "toggleSplit(address,bool)": {
            "details": "Can only be called by the team address      Setting permissions for address(0) acts as a global switch for all addresses      If address(0) is set to false, no address can split regardless of individual permissions      If address(0) is set to true, individual permissions apply normally",
            "params": {
              "_account": "The address to modify split permissions for, or address(0) for global setting",
              "_bool": "True to grant permission, false to revoke permission"
            }
          },
          "tokenURI(uint256)": {
            "details": "Returns the Uniform Resource Identifier (URI) for `tokenId` token."
          },
          "totalSupply()": {
            "details": "Sums up all individual veNFT voting powers including both time-based and permanent locks      This represents the total governance voting power in the system right now",
            "returns": {
              "_0": "The aggregate voting power of all veNFTs at the current timestamp"
            }
          },
          "totalSupplyAt(uint256)": {
            "details": "Uses global checkpoints to determine total voting power at any point in the past      Critical for governance votes that need to determine the total voting power at a past block      For timestamps between checkpoints, calculates the interpolated value",
            "params": {
              "_t": "The timestamp at which to query the total voting power"
            },
            "returns": {
              "_0": "The aggregate voting power of all veNFTs at the requested timestamp"
            }
          },
          "transferFrom(address,address,uint256)": {
            "details": "Transfers `tokenId` token from `from` to `to`. WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."
          },
          "unlockPermanent(uint256)": {
            "details": "Converts a permanent lock back to a standard time-based lock      After unlocking, the veNFT's voting power will decay based on the remaining lock time      The lock time will be the original lock end time from before it was made permanent      If the original lock time has already passed, the lock will be immediately withdrawable      Can only be called by the owner or an approved operator      Only callable on veNFTs that are currently permanently locked",
            "params": {
              "_tokenId": "The ID of the veNFT to revert from permanent to standard lock"
            }
          },
          "userPointHistory(uint256,uint256)": {
            "details": "Used to track historical voting power for individual tokens",
            "params": {
              "_loc": "The index of the user checkpoint to retrieve",
              "_tokenId": "The ID of the veNFT to query"
            },
            "returns": {
              "_0": "The UserPoint data at the specified index for the given token"
            }
          },
          "withdraw(uint256)": {
            "details": "Only possible if the lock has expired and is not a permanent lock      This function burns the veNFT and returns the locked tokens to the owner      IMPORTANT: Any unclaimed rebases or rewards will no longer be claimable after calling this      Users should claim all rebases and rewards prior to withdrawing      Can only be called by the owner of the veNFT or an approved address",
            "params": {
              "_tokenId": "The ID of the veNFT to withdraw tokens from"
            }
          }
        },
        "stateVariables": {
          "ERC165_INTERFACE_ID": {
            "details": "ERC165 interface ID of ERC165"
          },
          "ERC4906_INTERFACE_ID": {
            "details": "ERC165 interface ID of ERC4906"
          },
          "ERC6372_INTERFACE_ID": {
            "details": "ERC165 interface ID of ERC6372"
          },
          "ERC721_INTERFACE_ID": {
            "details": "ERC165 interface ID of ERC721"
          },
          "ERC721_METADATA_INTERFACE_ID": {
            "details": "ERC165 interface ID of ERC721Metadata"
          },
          "canSplit": {
            "details": "Used to control which addresses can perform veNFT splitting operations",
            "params": {
              "_account": "The address to check for split permission"
            },
            "return": "True if the account can split veNFTs, false otherwise",
            "returns": {
              "_0": "True if the account can split veNFTs, false otherwise"
            }
          },
          "earlyWithdrawPenalty": {
            "details": "Value is between 0 and 10000 (0% to 100%)",
            "return": "The current penalty percentage in basis points",
            "returns": {
              "_0": "The current penalty percentage in basis points"
            }
          },
          "earlyWithdrawTreasury": {
            "return": "The address of the treasury that collects early withdrawal penalties",
            "returns": {
              "_0": "The address of the treasury that collects early withdrawal penalties"
            }
          },
          "epoch": {
            "return": "The current epoch number",
            "returns": {
              "_0": "The current epoch number"
            }
          },
          "forwarder": {
            "return": "The trusted forwarder address used for meta-transactions",
            "returns": {
              "_0": "The trusted forwarder address used for meta-transactions"
            }
          },
          "idToApprovals": {
            "details": "Mapping from NFT ID to approved address."
          },
          "idToOwner": {
            "details": "Mapping from NFT ID to the address that owns it."
          },
          "ownerToNFTokenCount": {
            "details": "Mapping from owner address to count of his tokens."
          },
          "ownerToNFTokenIdList": {
            "params": {
              "_index": "Index of the token within the owner's list",
              "_owner": "Owner address to query"
            },
            "return": "The tokenId at the given index for the owner",
            "returns": {
              "_0": "The tokenId at the given index for the owner"
            }
          },
          "ownerToOperators": {
            "details": "Mapping from owner address to mapping of operator addresses."
          },
          "ownershipChange": {
            "details": "Mapping from NFT ID to the block number of the last ownership change."
          },
          "permanentLockBalance": {
            "details": "These tokens cannot be withdrawn through normal means",
            "return": "The total amount of permanently locked tokens",
            "returns": {
              "_0": "The total amount of permanently locked tokens"
            }
          },
          "slopeChanges": {
            "details": "Used to calculate future voting power changes due to lock expirations",
            "params": {
              "_timestamp": "The timestamp to check for slope changes"
            },
            "return": "The net change in slope (negative value means decrease in voting power)",
            "returns": {
              "_0": "The net change in slope (negative value means decrease in voting power)"
            }
          },
          "supply": {
            "return": "The total supply of locked tokens",
            "returns": {
              "_0": "The total supply of locked tokens"
            }
          },
          "supportedInterfaces": {
            "details": "Mapping of interface id to bool about whether or not it's supported"
          },
          "team": {
            "return": "The address of the current team multisig with administrative privileges",
            "returns": {
              "_0": "The address of the current team multisig with administrative privileges"
            }
          },
          "token": {
            "return": "The ERC20 token address used to lock and mint veNFTs",
            "returns": {
              "_0": "The ERC20 token address used to lock and mint veNFTs"
            }
          },
          "tokenId": {
            "details": "Used as a counter for minting new tokens and assigning IDs",
            "return": "The current highest token ID value",
            "returns": {
              "_0": "The current highest token ID value"
            }
          }
        },
        "title": "DustLock",
        "version": 1
      },
      "userdoc": {
        "errors": {
          "AddressZero()": [
            {
              "notice": "Used when a zero address is provided where not allowed."
            }
          ],
          "AlreadyOwned()": [
            {
              "notice": "Error thrown when trying to add a token that already has an owner"
            }
          ],
          "AmountTooBig()": [
            {
              "notice": "Error thrown when the requested amount exceeds available balance"
            }
          ],
          "AmountTooSmall()": [
            {
              "notice": "Error thrown when the locked amount is less than minLockAmount"
            }
          ],
          "DepositForLockDurationTooShort()": [
            {
              "notice": "Error thrown when trying to depositFor to a lock expiring within MINTIME"
            }
          ],
          "ERC721ReceiverRejectedTokens()": [
            {
              "notice": "Error thrown when an ERC721 receiver contract rejects the tokens"
            }
          ],
          "ERC721TransferToNonERC721ReceiverImplementer()": [
            {
              "notice": "Error thrown when transferring to an address that doesn't implement ERC721Receiver"
            }
          ],
          "InvalidRevenueRewardContract()": [
            {
              "notice": "Error thrown when setting a revenue reward contract that is not a deployed contract"
            }
          ],
          "InvalidTokenId()": [
            {
              "notice": "Used when a tokenId is invalid."
            }
          ],
          "InvalidWithdrawPenalty()": [
            {
              "notice": "Error thrown when an early withdraw penalty value is invalid (>=10000)"
            }
          ],
          "LockDurationNotInFuture()": [
            {
              "notice": "Error thrown when the lock duration doesn't extend beyond the current time"
            }
          ],
          "LockDurationTooLong()": [
            {
              "notice": "Error thrown when the lock duration exceeds the maximum allowed time"
            }
          ],
          "LockDurationTooShort()": [
            {
              "notice": "Error thrown when the lock duration is less than the minimum required time"
            }
          ],
          "LockExpired()": [
            {
              "notice": "Error thrown when trying to perform an operation on an expired lock"
            }
          ],
          "LockNotExpired()": [
            {
              "notice": "Error thrown when trying to withdraw from a lock that hasn't expired yet"
            }
          ],
          "NoLockFound()": [
            {
              "notice": "Error thrown when no lock is found for the specified token ID"
            }
          ],
          "NotApprovedOrOwner()": [
            {
              "notice": "Error thrown when the caller is neither the owner nor approved for the token"
            }
          ],
          "NotOwner()": [
            {
              "notice": "Error thrown when the caller is not the owner of the token"
            }
          ],
          "NotPendingTeam()": [
            {
              "notice": "Error thrown when a pending team function is called by a non-pending team address"
            }
          ],
          "NotPermanentLock()": [
            {
              "notice": "Error thrown when trying to unlock a non-permanent lock using unlockPermanent"
            }
          ],
          "NotTeam()": [
            {
              "notice": "Error thrown when a team-only function is called by a non-team address"
            }
          ],
          "PRBMath_MulDiv18_Overflow(uint256,uint256)": [
            {
              "notice": "Thrown when the resultant value in {mulDiv18} overflows uint256."
            }
          ],
          "PRBMath_MulDiv_Overflow(uint256,uint256,uint256)": [
            {
              "notice": "Thrown when the resultant value in {mulDiv} overflows uint256."
            }
          ],
          "PRBMath_UD60x18_Convert_Overflow(uint256)": [
            {
              "notice": "Thrown when converting a basic integer to the fixed-point format overflows UD60x18."
            }
          ],
          "PermanentLock()": [
            {
              "notice": "Error thrown when trying to withdraw or modify a permanent lock"
            }
          ],
          "SameAddress()": [
            {
              "notice": "Used when two addresses are the same but must differ."
            }
          ],
          "SameNFT()": [
            {
              "notice": "Error thrown when attempting to merge a veNFT with itself"
            }
          ],
          "SplitNotAllowed()": [
            {
              "notice": "Error thrown when splitting is not allowed for the user"
            }
          ],
          "ZeroAmount()": [
            {
              "notice": "Used when a zero amount is provided where not allowed."
            }
          ]
        },
        "events": {
          "BaseURIUpdated(string,string)": {
            "notice": "Emitted when the base URI is updated"
          },
          "Deposit(address,uint256,uint8,uint256,uint256,uint256)": {
            "notice": "Emitted when tokens are deposited into the veNFT system"
          },
          "EarlyWithdraw(address,uint256,uint256,uint256,uint256)": {
            "notice": "Emitted when tokens are withdrawn before the lock expiry with a penalty"
          },
          "EarlyWithdrawPenaltyUpdated(uint256,uint256)": {
            "notice": "Emitted when the early withdraw penalty is updated"
          },
          "EarlyWithdrawTreasuryUpdated(address,address)": {
            "notice": "Emitted when the early withdraw treasury address is updated"
          },
          "LockPermanent(address,uint256,uint256,uint256)": {
            "notice": "Emitted when a lock is converted to a permanent lock"
          },
          "Merge(address,uint256,uint256,uint256,uint256,uint256,uint256,uint256)": {
            "notice": "Emitted when two veNFTs are merged"
          },
          "MinLockAmountUpdated(uint256,uint256)": {
            "notice": "Emitted when the minimum lock amount is updated"
          },
          "RevenueRewardUpdated(address,address)": {
            "notice": "Emitted when the revenue reward contract is updated"
          },
          "Split(uint256,uint256,uint256,address,uint256,uint256,uint256,uint256)": {
            "notice": "Emitted when a veNFT is split into two separate veNFTs"
          },
          "SplitPermissionUpdated(address,bool)": {
            "notice": "Emitted when the split permission is toggled for an account"
          },
          "Supply(uint256,uint256)": {
            "notice": "Emitted when the total supply of locked tokens changes"
          },
          "TeamAccepted(address,address)": {
            "notice": "Emitted when a proposed team address accepts ownership"
          },
          "TeamProposalCancelled(address,address)": {
            "notice": "Emitted when a team proposal is cancelled"
          },
          "TeamProposed(address,address)": {
            "notice": "Emitted when a new team address is proposed"
          },
          "UnlockPermanent(address,uint256,uint256,uint256)": {
            "notice": "Emitted when a permanent lock is unlocked by governance"
          },
          "Withdraw(address,uint256,uint256,uint256)": {
            "notice": "Emitted when tokens are withdrawn after the lock expiry"
          }
        },
        "kind": "user",
        "methods": {
          "acceptTeam()": {
            "notice": "Accepts the proposed team address to complete the ownership transfer"
          },
          "balanceOfNFT(uint256)": {
            "notice": "Get the current voting power for a specific veNFT"
          },
          "balanceOfNFTAt(uint256,uint256)": {
            "notice": "Get the historical voting power for a veNFT at a specific timestamp"
          },
          "canSplit(address)": {
            "notice": "Check if an account has permission to split veNFTs"
          },
          "cancelTeamProposal()": {
            "notice": "Cancels the pending team proposal"
          },
          "checkpoint()": {
            "notice": "Create a global checkpoint to record the current state of voting power"
          },
          "createLock(uint256,uint256)": {
            "notice": "Create a new lock by depositing tokens for the caller"
          },
          "createLockFor(uint256,uint256,address)": {
            "notice": "Create a new lock by depositing tokens for another address"
          },
          "createLockPermanent(uint256,uint256)": {
            "notice": "Create a new lock for the caller and immediately make it permanent"
          },
          "createLockPermanentFor(uint256,uint256,address)": {
            "notice": "Create a new lock for `to` and immediately make it permanent"
          },
          "depositFor(uint256,uint256)": {
            "notice": "Deposit additional tokens for an existing veNFT lock"
          },
          "earlyWithdraw(uint256)": {
            "notice": "Withdraw tokens from a lock before it expires, with a time-proportional penalty"
          },
          "earlyWithdrawPenalty()": {
            "notice": "Percentage of penalty applied to early withdrawals (in basis points)"
          },
          "earlyWithdrawTreasury()": {
            "notice": "Address that receives penalty fees from early withdrawals"
          },
          "epoch()": {
            "notice": "Total count of epochs witnessed since contract creation"
          },
          "forwarder()": {
            "notice": "Address of Meta-tx Forwarder"
          },
          "increaseAmount(uint256,uint256)": {
            "notice": "Deposit additional tokens for an existing veNFT without modifying the unlock time"
          },
          "increaseUnlockTime(uint256,uint256)": {
            "notice": "Extend the unlock time for an existing veNFT lock"
          },
          "initialize(address,address,string)": {
            "notice": "Initializer (for proxy deployments)"
          },
          "isApprovedOrOwner(address,uint256)": {
            "notice": "Check whether spender is owner or an approved user for a given veNFT"
          },
          "lockPermanent(uint256)": {
            "notice": "Permanently lock a veNFT to give it non-decaying voting power"
          },
          "locked(uint256)": {
            "notice": "Get the lock details for a specific veNFT"
          },
          "merge(uint256,uint256)": {
            "notice": "Merges two veNFTs by combining their locked tokens into a single veNFT"
          },
          "minLockAmount()": {
            "notice": "Minimum amount of DUST required to create or increase a lock (18 decimals)"
          },
          "name()": {
            "notice": "Token name"
          },
          "ownerToNFTokenIdList(address,uint256)": {
            "notice": "Returns the tokenId owned by `_owner` at position `_index`"
          },
          "pendingTeam()": {
            "notice": "Pending team address for two-step ownership transfer"
          },
          "permanentLockBalance()": {
            "notice": "Aggregate balance of permanently locked tokens"
          },
          "pointHistory(uint256)": {
            "notice": "Retrieve a global checkpoint at a specific index"
          },
          "proposeTeam(address)": {
            "notice": "Proposes a new team address for two-step ownership transfer"
          },
          "revenueReward()": {
            "notice": "Revenue reward contract used for distributing external rewards (address(0) if unset)"
          },
          "setBaseURI(string)": {
            "notice": "Updates the base URI for computing tokenURI"
          },
          "setEarlyWithdrawPenalty(uint256)": {
            "notice": "Sets the early withdrawal penalty percentage"
          },
          "setEarlyWithdrawTreasury(address)": {
            "notice": "Sets the treasury address that will receive penalty fees from early withdrawals"
          },
          "setMinLockAmount(uint256)": {
            "notice": "Sets the minimum amount of tokens required to create a veNFT lock"
          },
          "setRevenueReward(address)": {
            "notice": "Sets the revenue reward contract"
          },
          "slopeChanges(uint256)": {
            "notice": "Retrieve the scheduled slope change at a given timestamp"
          },
          "split(uint256,uint256)": {
            "notice": "Splits a veNFT into two new veNFTs with divided token balances"
          },
          "supply()": {
            "notice": "Total amount of tokens currently locked in the contract"
          },
          "symbol()": {
            "notice": "Token symbol"
          },
          "team()": {
            "notice": "Address of Neverland Team multisig"
          },
          "toggleSplit(address,bool)": {
            "notice": "Grant or revoke permission for an address to split veNFTs"
          },
          "token()": {
            "notice": "Address of token (DUST) used to create a veNFT"
          },
          "tokenId()": {
            "notice": "Current total count of veNFT tokens"
          },
          "totalSupply()": {
            "notice": "Calculate the total voting power across all veNFTs at the current timestamp"
          },
          "totalSupplyAt(uint256)": {
            "notice": "Calculate the total historical voting power across all veNFTs at a specific timestamp"
          },
          "unlockPermanent(uint256)": {
            "notice": "Revert a veNFT from permanent lock status back to a standard time-lock"
          },
          "userPointEpoch(uint256)": {
            "notice": "Mapping from veNFT id to user point epoch"
          },
          "userPointHistory(uint256,uint256)": {
            "notice": "Retrieve a user checkpoint for a specific veNFT at a given index"
          },
          "version()": {
            "notice": "Token version"
          },
          "withdraw(uint256)": {
            "notice": "Withdraw all tokens from an expired lock for `_tokenId`"
          }
        },
        "notice": "Vote-escrow (veNFT) contract for DUST; tracks locks and voting power",
        "version": 1
      }
    },
    "settings": {
      "compilationTarget": {
        "src/tokens/DustLock.sol": "DustLock"
      },
      "evmVersion": "paris",
      "libraries": {},
      "metadata": {
        "bytecodeHash": "none",
        "useLiteralContent": true
      },
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "remappings": []
    },
    "sources": {
      "@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n",
        "keccak256": "0x7dbc63091d0a5033ac3d9de8aa0c0445895c8992b56db5db6d781725a2d9f414",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n",
        "keccak256": "0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n",
        "keccak256": "0x2025ccf05f6f1f2fd4e078e552836f525a1864e3854ed555047cd732320ab29b",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "keccak256": "0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n",
        "keccak256": "0x75097e35253e7fb282ee4d7f27a80eaacfa759923185bf17302a89cbc059c5ef",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n",
        "keccak256": "0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC4906.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n",
        "keccak256": "0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC6372.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n",
        "keccak256": "0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n",
        "keccak256": "0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n",
        "keccak256": "0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
        "keccak256": "0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n",
        "keccak256": "0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n",
        "keccak256": "0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n",
        "keccak256": "0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
        "keccak256": "0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "keccak256": "0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/Strings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n",
        "keccak256": "0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
        "keccak256": "0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n",
        "keccak256": "0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/math/SignedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n",
        "keccak256": "0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc",
        "license": "MIT"
      },
      "@prb/math/src/Common.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The maximum value a uint64 number can have.\nuint64 constant MAX_UINT64 = type(uint64).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*ydenominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n",
        "keccak256": "0x8225a3898d2f11f585da1fb82234800e9717fa080dbe53d450fd429a3a632e99",
        "license": "MIT"
      },
      "@prb/math/src/UD60x18.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n/*\n\n          \n   \n      \n       \n                   \n                       \n\n            \n    \n        \n        \n  \n           \n\n*/\n\nimport \"./ud60x18/Casting.sol\";\nimport \"./ud60x18/Constants.sol\";\nimport \"./ud60x18/Conversions.sol\";\nimport \"./ud60x18/Errors.sol\";\nimport \"./ud60x18/Helpers.sol\";\nimport \"./ud60x18/Math.sol\";\nimport \"./ud60x18/ValueType.sol\";\n",
        "keccak256": "0xb98c6f74275914d279e8af6c502c2b1f50d5f6e1ed418d3b0153f5a193206c48",
        "license": "MIT"
      },
      "@prb/math/src/sd1x18/Casting.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as CastingErrors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD1x18 number into SD59x18.\n/// @dev There is no overflow check because SD1x18  SD59x18.\nfunction intoSD59x18(SD1x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(SD1x18.unwrap(x)));\n}\n\n/// @notice Casts an SD1x18 number into UD60x18.\n/// @dev Requirements:\n/// - x  0\nfunction intoUD60x18(SD1x18 x) pure returns (UD60x18 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint128.\n/// @dev Requirements:\n/// - x  0\nfunction intoUint128(SD1x18 x) pure returns (uint128 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint128_Underflow(x);\n    }\n    result = uint128(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint256.\n/// @dev Requirements:\n/// - x  0\nfunction intoUint256(SD1x18 x) pure returns (uint256 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint256_Underflow(x);\n    }\n    result = uint256(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint40.\n/// @dev Requirements:\n/// - x  0\n/// - x  MAX_UINT40\nfunction intoUint40(SD1x18 x) pure returns (uint40 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Underflow(x);\n    }\n    if (xInt > int64(uint64(Common.MAX_UINT40))) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Overflow(x);\n    }\n    result = uint40(uint64(xInt));\n}\n\n/// @notice Alias for {wrap}.\nfunction sd1x18(int64 x) pure returns (SD1x18 result) {\n    result = SD1x18.wrap(x);\n}\n\n/// @notice Unwraps an SD1x18 number into int64.\nfunction unwrap(SD1x18 x) pure returns (int64 result) {\n    result = SD1x18.unwrap(x);\n}\n\n/// @notice Wraps an int64 number into SD1x18.\nfunction wrap(int64 x) pure returns (SD1x18 result) {\n    result = SD1x18.wrap(x);\n}\n",
        "keccak256": "0x5d365f655f01598926c5d4fe5cda277f2cc7736fe38f943c11a32009077ddd5c",
        "license": "MIT"
      },
      "@prb/math/src/sd1x18/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as an SD1x18 number.\nSD1x18 constant E = SD1x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value an SD1x18 number can have.\nint64 constant uMAX_SD1x18 = 9_223372036854775807;\nSD1x18 constant MAX_SD1x18 = SD1x18.wrap(uMAX_SD1x18);\n\n/// @dev The minimum value an SD1x18 number can have.\nint64 constant uMIN_SD1x18 = -9_223372036854775808;\nSD1x18 constant MIN_SD1x18 = SD1x18.wrap(uMIN_SD1x18);\n\n/// @dev PI as an SD1x18 number.\nSD1x18 constant PI = SD1x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of SD1x18.\nSD1x18 constant UNIT = SD1x18.wrap(1e18);\nint64 constant uUNIT = 1e18;\n",
        "keccak256": "0xc14cc32061863d83912f9616de86f3c34f1ac58614b7d504c6ce07ee8efdb8e8",
        "license": "MIT"
      },
      "@prb/math/src/sd1x18/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD1x18_ToUD60x18_Underflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint128.\nerror PRBMath_SD1x18_ToUint128_Underflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint256.\nerror PRBMath_SD1x18_ToUint256_Underflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint40.\nerror PRBMath_SD1x18_ToUint40_Overflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint40.\nerror PRBMath_SD1x18_ToUint40_Underflow(SD1x18 x);\n",
        "keccak256": "0xc3c8b1ab3d19889c356c222a3a2186d45dfc1d3a17b9ad88159bb64ee457baa6",
        "license": "MIT"
      },
      "@prb/math/src/sd1x18/ValueType.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The signed 1.18-decimal fixed-point number representation, which can have up to 1 digit and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type int64. This is useful when end users want to use int64 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype SD1x18 is int64;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for SD1x18 global;\n",
        "keccak256": "0xaa9dc7b562faf45264390d80e2ea10c5295bb8a4f10d76261a3f9c04363734c0",
        "license": "MIT"
      },
      "@prb/math/src/sd21x18/Casting.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as CastingErrors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { SD21x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD21x18 number into SD59x18.\n/// @dev There is no overflow check because SD21x18  SD59x18.\nfunction intoSD59x18(SD21x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(SD21x18.unwrap(x)));\n}\n\n/// @notice Casts an SD21x18 number into UD60x18.\n/// @dev Requirements:\n/// - x  0\nfunction intoUD60x18(SD21x18 x) pure returns (UD60x18 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint128(xInt));\n}\n\n/// @notice Casts an SD21x18 number into uint128.\n/// @dev Requirements:\n/// - x  0\nfunction intoUint128(SD21x18 x) pure returns (uint128 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint128_Underflow(x);\n    }\n    result = uint128(xInt);\n}\n\n/// @notice Casts an SD21x18 number into uint256.\n/// @dev Requirements:\n/// - x  0\nfunction intoUint256(SD21x18 x) pure returns (uint256 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint256_Underflow(x);\n    }\n    result = uint256(uint128(xInt));\n}\n\n/// @notice Casts an SD21x18 number into uint40.\n/// @dev Requirements:\n/// - x  0\n/// - x  MAX_UINT40\nfunction intoUint40(SD21x18 x) pure returns (uint40 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint40_Underflow(x);\n    }\n    if (xInt > int128(uint128(Common.MAX_UINT40))) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint40_Overflow(x);\n    }\n    result = uint40(uint128(xInt));\n}\n\n/// @notice Alias for {wrap}.\nfunction sd21x18(int128 x) pure returns (SD21x18 result) {\n    result = SD21x18.wrap(x);\n}\n\n/// @notice Unwraps an SD21x18 number into int128.\nfunction unwrap(SD21x18 x) pure returns (int128 result) {\n    result = SD21x18.unwrap(x);\n}\n\n/// @notice Wraps an int128 number into SD21x18.\nfunction wrap(int128 x) pure returns (SD21x18 result) {\n    result = SD21x18.wrap(x);\n}\n",
        "keccak256": "0x4a16adddb9ab1f6939dd4567c77205015a11081cb840029b84bbb6fdaf78ee36",
        "license": "MIT"
      },
      "@prb/math/src/sd21x18/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { SD21x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as an SD21x18 number.\nSD21x18 constant E = SD21x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value an SD21x18 number can have.\nint128 constant uMAX_SD21x18 = 170141183460469231731_687303715884105727;\nSD21x18 constant MAX_SD21x18 = SD21x18.wrap(uMAX_SD21x18);\n\n/// @dev The minimum value an SD21x18 number can have.\nint128 constant uMIN_SD21x18 = -170141183460469231731_687303715884105728;\nSD21x18 constant MIN_SD21x18 = SD21x18.wrap(uMIN_SD21x18);\n\n/// @dev PI as an SD21x18 number.\nSD21x18 constant PI = SD21x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of SD21x18.\nSD21x18 constant UNIT = SD21x18.wrap(1e18);\nint128 constant uUNIT = 1e18;\n",
        "keccak256": "0x501c2d5cfdea9450422182059c8df1cb6a859901a07bd59631c3fa24edcc79d4",
        "license": "MIT"
      },
      "@prb/math/src/sd21x18/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { SD21x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint128.\nerror PRBMath_SD21x18_ToUint128_Underflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD21x18_ToUD60x18_Underflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint256.\nerror PRBMath_SD21x18_ToUint256_Underflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint40.\nerror PRBMath_SD21x18_ToUint40_Overflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint40.\nerror PRBMath_SD21x18_ToUint40_Underflow(SD21x18 x);\n",
        "keccak256": "0xc5422ee47eb139274e538e758fb40177a1ba22c2113ef3b3446102f0150bfe0a",
        "license": "MIT"
      },
      "@prb/math/src/sd21x18/ValueType.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The signed 21.18-decimal fixed-point number representation, which can have up to 21 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type int128. This is useful when end users want to use int128 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype SD21x18 is int128;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for SD21x18 global;\n",
        "keccak256": "0x532bba888370bed393464412f4ef3462d654802e71c953ad02d078e3d2701092",
        "license": "MIT"
      },
      "@prb/math/src/sd59x18/Casting.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Errors.sol\" as CastingErrors;\nimport { MAX_UINT128, MAX_UINT40 } from \"../Common.sol\";\nimport { uMAX_SD1x18, uMIN_SD1x18 } from \"../sd1x18/Constants.sol\";\nimport { SD1x18 } from \"../sd1x18/ValueType.sol\";\nimport { uMAX_SD21x18, uMIN_SD21x18 } from \"../sd21x18/Constants.sol\";\nimport { SD21x18 } from \"../sd21x18/ValueType.sol\";\nimport { uMAX_UD2x18 } from \"../ud2x18/Constants.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport { uMAX_UD21x18 } from \"../ud21x18/Constants.sol\";\nimport { UD21x18 } from \"../ud21x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD59x18 number into int256.\n/// @dev This is basically a functional alias for {unwrap}.\nfunction intoInt256(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Casts an SD59x18 number into SD1x18.\n/// @dev Requirements:\n/// - x  uMIN_SD1x18\n/// - x  uMAX_SD1x18\nfunction intoSD1x18(SD59x18 x) pure returns (SD1x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < uMIN_SD1x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Underflow(x);\n    }\n    if (xInt > uMAX_SD1x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Overflow(x);\n    }\n    result = SD1x18.wrap(int64(xInt));\n}\n\n/// @notice Casts an SD59x18 number into SD21x18.\n/// @dev Requirements:\n/// - x  uMIN_SD21x18\n/// - x  uMAX_SD21x18\nfunction intoSD21x18(SD59x18 x) pure returns (SD21x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < uMIN_SD21x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD21x18_Underflow(x);\n    }\n    if (xInt > uMAX_SD21x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD21x18_Overflow(x);\n    }\n    result = SD21x18.wrap(int128(xInt));\n}\n\n/// @notice Casts an SD59x18 number into UD2x18.\n/// @dev Requirements:\n/// - x  0\n/// - x  uMAX_UD2x18\nfunction intoUD2x18(SD59x18 x) pure returns (UD2x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Underflow(x);\n    }\n    if (xInt > int256(uint256(uMAX_UD2x18))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Overflow(x);\n    }\n    result = UD2x18.wrap(uint64(uint256(xInt)));\n}\n\n/// @notice Casts an SD59x18 number into UD21x18.\n/// @dev Requirements:\n/// - x  0\n/// - x  uMAX_UD21x18\nfunction intoUD21x18(SD59x18 x) pure returns (UD21x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD21x18_Underflow(x);\n    }\n    if (xInt > int256(uint256(uMAX_UD21x18))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD21x18_Overflow(x);\n    }\n    result = UD21x18.wrap(uint128(uint256(xInt)));\n}\n\n/// @notice Casts an SD59x18 number into UD60x18.\n/// @dev Requirements:\n/// - x  0\nfunction intoUD60x18(SD59x18 x) pure returns (UD60x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint256(xInt));\n}\n\n/// @notice Casts an SD59x18 number into uint256.\n/// @dev Requirements:\n/// - x  0\nfunction intoUint256(SD59x18 x) pure returns (uint256 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint256_Underflow(x);\n    }\n    result = uint256(xInt);\n}\n\n/// @notice Casts an SD59x18 number into uint128.\n/// @dev Requirements:\n/// - x  0\n/// - x  uMAX_UINT128\nfunction intoUint128(SD59x18 x) pure returns (uint128 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Underflow(x);\n    }\n    if (xInt > int256(uint256(MAX_UINT128))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Overflow(x);\n    }\n    result = uint128(uint256(xInt));\n}\n\n/// @notice Casts an SD59x18 number into uint40.\n/// @dev Requirements:\n/// - x  0\n/// - x  MAX_UINT40\nfunction intoUint40(SD59x18 x) pure returns (uint40 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Underflow(x);\n    }\n    if (xInt > int256(uint256(MAX_UINT40))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(uint256(xInt));\n}\n\n/// @notice Alias for {wrap}.\nfunction sd(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n\n/// @notice Alias for {wrap}.\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n\n/// @notice Unwraps an SD59x18 number into int256.\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Wraps an int256 number into SD59x18.\nfunction wrap(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n",
        "keccak256": "0xdf70d8e70c6d6325f3f7eb028c484bc7189ef902f1d4b5b220af2e550bb5fc39",
        "license": "MIT"
      },
      "@prb/math/src/sd59x18/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { SD59x18 } from \"./ValueType.sol\";\n\n// NOTICE: the \"u\" prefix stands for \"unwrapped\".\n\n/// @dev Euler's number as an SD59x18 number.\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\n\n/// @dev The maximum input permitted in {exp}.\nint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\nSD59x18 constant EXP_MAX_INPUT = SD59x18.wrap(uEXP_MAX_INPUT);\n\n/// @dev Any value less than this returns 0 in {exp}.\nint256 constant uEXP_MIN_THRESHOLD = -41_446531673892822322;\nSD59x18 constant EXP_MIN_THRESHOLD = SD59x18.wrap(uEXP_MIN_THRESHOLD);\n\n/// @dev The maximum input permitted in {exp2}.\nint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\nSD59x18 constant EXP2_MAX_INPUT = SD59x18.wrap(uEXP2_MAX_INPUT);\n\n/// @dev Any value less than this returns 0 in {exp2}.\nint256 constant uEXP2_MIN_THRESHOLD = -59_794705707972522261;\nSD59x18 constant EXP2_MIN_THRESHOLD = SD59x18.wrap(uEXP2_MIN_THRESHOLD);\n\n/// @dev Half the UNIT number.\nint256 constant uHALF_UNIT = 0.5e18;\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\n\n/// @dev $log_2(10)$ as an SD59x18 number.\nint256 constant uLOG2_10 = 3_321928094887362347;\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\n\n/// @dev $log_2(e)$ as an SD59x18 number.\nint256 constant uLOG2_E = 1_442695040888963407;\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\n\n/// @dev The maximum value an SD59x18 number can have.\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\n\n/// @dev The maximum whole value an SD59x18 number can have.\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\n\n/// @dev The minimum value an SD59x18 number can have.\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\n\n/// @dev The minimum whole value an SD59x18 number can have.\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\n\n/// @dev PI as an SD59x18 number.\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of SD59x18.\nint256 constant uUNIT = 1e18;\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\n\n/// @dev The unit number squared.\nint256 constant uUNIT_SQUARED = 1e36;\nSD59x18 constant UNIT_SQUARED = SD59x18.wrap(uUNIT_SQUARED);\n\n/// @dev Zero as an SD59x18 number.\nSD59x18 constant ZERO = SD59x18.wrap(0);\n",
        "keccak256": "0x9bcb8dd6b3e886d140ad1c32747a4f6d29a492529ceb835be878ae837aa6cc3a",
        "license": "MIT"
      },
      "@prb/math/src/sd59x18/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when taking the absolute value of `MIN_SD59x18`.\nerror PRBMath_SD59x18_Abs_MinSD59x18();\n\n/// @notice Thrown when ceiling a number overflows SD59x18.\nerror PRBMath_SD59x18_Ceil_Overflow(SD59x18 x);\n\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMath_SD59x18_Convert_Overflow(int256 x);\n\n/// @notice Thrown when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMath_SD59x18_Convert_Underflow(int256 x);\n\n/// @notice Thrown when dividing two numbers and one of them is `MIN_SD59x18`.\nerror PRBMath_SD59x18_Div_InputTooSmall();\n\n/// @notice Thrown when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\nerror PRBMath_SD59x18_Div_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\nerror PRBMath_SD59x18_Exp_InputTooBig(SD59x18 x);\n\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\nerror PRBMath_SD59x18_Exp2_InputTooBig(SD59x18 x);\n\n/// @notice Thrown when flooring a number underflows SD59x18.\nerror PRBMath_SD59x18_Floor_Underflow(SD59x18 x);\n\n/// @notice Thrown when taking the geometric mean of two numbers and their product is negative.\nerror PRBMath_SD59x18_Gm_NegativeProduct(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\nerror PRBMath_SD59x18_Gm_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD1x18.\nerror PRBMath_SD59x18_IntoSD1x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD1x18.\nerror PRBMath_SD59x18_IntoSD1x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD21x18.\nerror PRBMath_SD59x18_IntoSD21x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD21x18.\nerror PRBMath_SD59x18_IntoSD21x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD2x18.\nerror PRBMath_SD59x18_IntoUD2x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD2x18.\nerror PRBMath_SD59x18_IntoUD2x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD21x18.\nerror PRBMath_SD59x18_IntoUD21x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD21x18.\nerror PRBMath_SD59x18_IntoUD21x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD59x18_IntoUD60x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint128.\nerror PRBMath_SD59x18_IntoUint128_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint128.\nerror PRBMath_SD59x18_IntoUint128_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint256.\nerror PRBMath_SD59x18_IntoUint256_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint40.\nerror PRBMath_SD59x18_IntoUint40_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint40.\nerror PRBMath_SD59x18_IntoUint40_Underflow(SD59x18 x);\n\n/// @notice Thrown when taking the logarithm of a number less than or equal to zero.\nerror PRBMath_SD59x18_Log_InputTooSmall(SD59x18 x);\n\n/// @notice Thrown when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\nerror PRBMath_SD59x18_Mul_InputTooSmall();\n\n/// @notice Thrown when multiplying two numbers and the intermediary absolute result overflows SD59x18.\nerror PRBMath_SD59x18_Mul_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when raising a number to a power and the intermediary absolute result overflows SD59x18.\nerror PRBMath_SD59x18_Powu_Overflow(SD59x18 x, uint256 y);\n\n/// @notice Thrown when taking the square root of a negative number.\nerror PRBMath_SD59x18_Sqrt_NegativeInput(SD59x18 x);\n\n/// @notice Thrown when the calculating the square root overflows SD59x18.\nerror PRBMath_SD59x18_Sqrt_Overflow(SD59x18 x);\n",
        "keccak256": "0x0a79c28c85fc8a450b0801ff2e66114eac4ec565819f5d1d8738904658fe33e2",
        "license": "MIT"
      },
      "@prb/math/src/sd59x18/Helpers.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { wrap } from \"./Casting.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    return wrap(x.unwrap() + y.unwrap());\n}\n\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\n    return wrap(x.unwrap() & bits);\n}\n\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\nfunction and2(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    return wrap(x.unwrap() & y.unwrap());\n}\n\n/// @notice Implements the equal (=) operation in the SD59x18 type.\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() == y.unwrap();\n}\n\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() > y.unwrap();\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() >= y.unwrap();\n}\n\n/// @notice Implements a zero comparison check function in the SD59x18 type.\nfunction isZero(SD59x18 x) pure returns (bool result) {\n    result = x.unwrap() == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() < y.unwrap();\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() <= y.unwrap();\n}\n\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() % y.unwrap());\n}\n\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() != y.unwrap();\n}\n\n/// @notice Implements the NOT (~) bitwise operation in the SD59x18 type.\nfunction not(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(~x.unwrap());\n}\n\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() | y.unwrap());\n}\n\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() - y.unwrap());\n}\n\n/// @notice Implements the checked unary minus operation (-) in the SD59x18 type.\nfunction unary(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(-x.unwrap());\n}\n\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() + y.unwrap());\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() - y.unwrap());\n    }\n}\n\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(-x.unwrap());\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() ^ y.unwrap());\n}\n",
        "keccak256": "0x208570f1657cf730cb6c3d81aa14030e0d45cf906cdedea5059369d7df4bb716",
        "license": "MIT"
      },
      "@prb/math/src/sd59x18/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport {\n    uEXP_MAX_INPUT,\n    uEXP2_MAX_INPUT,\n    uEXP_MIN_THRESHOLD,\n    uEXP2_MIN_THRESHOLD,\n    uHALF_UNIT,\n    uLOG2_10,\n    uLOG2_E,\n    uMAX_SD59x18,\n    uMAX_WHOLE_SD59x18,\n    uMIN_SD59x18,\n    uMIN_WHOLE_SD59x18,\n    UNIT,\n    uUNIT,\n    uUNIT_SQUARED,\n    ZERO\n} from \"./Constants.sol\";\nimport { wrap } from \"./Helpers.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Calculates the absolute value of x.\n///\n/// @dev Requirements:\n/// - x > MIN_SD59x18.\n///\n/// @param x The SD59x18 number for which to calculate the absolute value.\n/// @return result The absolute value of x as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Abs_MinSD59x18();\n    }\n    result = xInt < 0 ? wrap(-xInt) : x;\n}\n\n/// @notice Calculates the arithmetic average of x and y.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The arithmetic average as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n\n    unchecked {\n        // This operation is equivalent to `x / 2 +  y / 2`, and it can never overflow.\n        int256 sum = (xInt >> 1) + (yInt >> 1);\n\n        if (sum < 0) {\n            // If at least one of x and y is odd, add 1 to the result, because shifting negative numbers to the right\n            // rounds toward negative infinity. The right part is equivalent to `sum + (x % 2 == 1 || y % 2 == 1)`.\n            assembly (\"memory-safe\") {\n                result := add(sum, and(or(xInt, yInt), 1))\n            }\n        } else {\n            // Add 1 if both x and y are odd to account for the double 0.5 remainder truncated after shifting.\n            result = wrap(sum + (xInt & yInt & 1));\n        }\n    }\n}\n\n/// @notice Yields the smallest whole number greater than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x  MAX_WHOLE_SD59x18\n///\n/// @param x The SD59x18 number to ceil.\n/// @return result The smallest whole number greater than or equal to x, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt > uMAX_WHOLE_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Ceil_Overflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt > 0) {\n                resultInt += uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number.\n///\n/// @dev This is an extension of {Common.mulDiv} for signed numbers, which works by computing the signs and the absolute\n/// values separately.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv}.\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv}.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The denominator must not be zero.\n/// - The result must fit in SD59x18.\n///\n/// @param x The numerator as an SD59x18 number.\n/// @param y The denominator as an SD59x18 number.\n/// @return result The quotient as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Div_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*UNITy). The resulting value must fit in SD59x18.\n    uint256 resultAbs = Common.mulDiv(xAbs, uint256(uUNIT), yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert Errors.PRBMath_SD59x18_Div_Overflow(x, y);\n    }\n\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\n    // negative, 0 for positive or zero).\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Calculates the natural exponent of x using the following formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {exp2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {exp2}.\n/// - x < 133_084258667509499441.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n\n    // Any input less than the threshold returns zero.\n    // This check also prevents an overflow for very small numbers.\n    if (xInt < uEXP_MIN_THRESHOLD) {\n        return ZERO;\n    }\n\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\n    if (xInt > uEXP_MAX_INPUT) {\n        revert Errors.PRBMath_SD59x18_Exp_InputTooBig(x);\n    }\n\n    unchecked {\n        // Inline the fixed-point multiplication to save gas.\n        int256 doubleUnitProduct = xInt * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method using the following formula:\n///\n/// $$\n/// 2^{-x} = \\frac{1}{2^x}\n/// $$\n///\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n///\n/// Notes:\n/// - If x < -59_794705707972522261, the result is zero.\n///\n/// Requirements:\n/// - x < 192e18.\n/// - The result must fit in SD59x18.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        // The inverse of any number less than the threshold is truncated to zero.\n        if (xInt < uEXP2_MIN_THRESHOLD) {\n            return ZERO;\n        }\n\n        unchecked {\n            // Inline the fixed-point inversion to save gas.\n            result = wrap(uUNIT_SQUARED / exp2(wrap(-xInt)).unwrap());\n        }\n    } else {\n        // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\n        if (xInt > uEXP2_MAX_INPUT) {\n            revert Errors.PRBMath_SD59x18_Exp2_InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\n\n            // It is safe to cast the result to int256 due to the checks above.\n            result = wrap(int256(Common.exp2(x_192x64)));\n        }\n    }\n}\n\n/// @notice Yields the greatest whole number less than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x  MIN_WHOLE_SD59x18\n///\n/// @param x The SD59x18 number to floor.\n/// @return result The greatest whole number less than or equal to x, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < uMIN_WHOLE_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Floor_Underflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt < 0) {\n                resultInt -= uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\n/// of the radix point for negative numbers.\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n/// @param x The SD59x18 number to get the fractional part of.\n/// @return result The fractional part of x as an SD59x18 number.\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() % uUNIT);\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. $\\sqrt{x * y}$.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x * y must fit in SD59x18.\n/// - x * y must not be negative, since complex numbers are not supported.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == 0 || yInt == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Equivalent to `xy / x != y`. Checking for overflow this way is faster than letting Solidity do it.\n        int256 xyInt = xInt * yInt;\n        if (xyInt / xInt != yInt) {\n            revert Errors.PRBMath_SD59x18_Gm_Overflow(x, y);\n        }\n\n        // The product must not be negative, since complex numbers are not supported.\n        if (xyInt < 0) {\n            revert Errors.PRBMath_SD59x18_Gm_NegativeProduct(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\n        // during multiplication. See the comments in {Common.sqrt}.\n        uint256 resultUint = Common.sqrt(uint256(xyInt));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/// @notice Calculates the inverse of x.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x must not be zero.\n///\n/// @param x The SD59x18 number for which to calculate the inverse.\n/// @return result The inverse as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(uUNIT_SQUARED / x.unwrap());\n}\n\n/// @notice Calculates the natural logarithm of x using the following formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\n    // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\n    // {log2} can return is ~195_205294292027477728.\n    result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\n}\n\n/// @notice Calculates the common logarithm of x using the following formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// However, if x is an exact power of ten, a hard coded value is returned.\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The SD59x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    // Note that the `mul` in this block is the standard multiplication operation, not {SD59x18.mul}.\n    // prettier-ignore\n    assembly (\"memory-safe\") {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        default { result := uMAX_SD59x18 }\n    }\n\n    if (result.unwrap() == uMAX_SD59x18) {\n        unchecked {\n            // Inline the fixed-point division to save gas.\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\n///\n/// $$\n/// log_2{x} = n + log_2{y}, \\text{ where } y = x*2^{-n}, \\ y \\in [1, 2)\n/// $$\n///\n/// For $0 \\leq x \\lt 1$, the input is inverted:\n///\n/// $$\n/// log_2{x} = -log_2{\\frac{1}{x}}\n/// $$\n///\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation.\n///\n/// Notes:\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\n///\n/// Requirements:\n/// - x > 0\n///\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt <= 0) {\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    unchecked {\n        int256 sign;\n        if (xInt >= uUNIT) {\n            sign = 1;\n        } else {\n            sign = -1;\n            // Inline the fixed-point inversion to save gas.\n            xInt = uUNIT_SQUARED / xInt;\n        }\n\n        // Calculate the integer part of the logarithm.\n        uint256 n = Common.msb(uint256(xInt / uUNIT));\n\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\n        // because n is at most 255, `UNIT` is 1e18, and the sign is either 1 or -1.\n        int256 resultInt = int256(n) * uUNIT;\n\n        // Calculate $y = x * 2^{-n}$.\n        int256 y = xInt >> n;\n\n        // If y is the unit number, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultInt * sign);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\n        int256 DOUBLE_UNIT = 2e18;\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultInt = resultInt + delta;\n\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\n                y >>= 1;\n            }\n        }\n        resultInt *= sign;\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\n///\n/// @dev Notes:\n/// - Refer to the notes in {Common.mulDiv18}.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv18}.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The result must fit in SD59x18.\n///\n/// @param x The multiplicand as an SD59x18 number.\n/// @param y The multiplier as an SD59x18 number.\n/// @return result The product as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Mul_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*yUNIT). The resulting value must fit in SD59x18.\n    uint256 resultAbs = Common.mulDiv18(xAbs, yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert Errors.PRBMath_SD59x18_Mul_Overflow(x, y);\n    }\n\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\n    // negative, 0 for positive or zero).\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Raises x to the power of y using the following formula:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {exp2}, {log2}, and {mul}.\n/// - Returns `UNIT` for 0^0.\n///\n/// Requirements:\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\n///\n/// @param x The base as an SD59x18 number.\n/// @param y Exponent to raise x to, as an SD59x18 number\n/// @return result x raised to power y, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\n    if (xInt == 0) {\n        return yInt == 0 ? UNIT : ZERO;\n    }\n    // If x is `UNIT`, the result is always `UNIT`.\n    else if (xInt == uUNIT) {\n        return UNIT;\n    }\n\n    // If y is zero, the result is always `UNIT`.\n    if (yInt == 0) {\n        return UNIT;\n    }\n    // If y is `UNIT`, the result is always x.\n    else if (yInt == uUNIT) {\n        return x;\n    }\n\n    // Calculate the result using the formula.\n    result = exp2(mul(log2(x), y));\n}\n\n/// @notice Raises x (an SD59x18 number) to the power y (an unsigned basic integer) using the well-known\n/// algorithm \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv18}.\n/// - Returns `UNIT` for 0^0.\n///\n/// Requirements:\n/// - Refer to the requirements in {abs} and {Common.mulDiv18}.\n/// - The result must fit in SD59x18.\n///\n/// @param x The base as an SD59x18 number.\n/// @param y The exponent as a uint256.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\n    uint256 xAbs = uint256(abs(x).unwrap());\n\n    // Calculate the first iteration of the loop in advance.\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\n\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\n    uint256 yAux = y;\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n        xAbs = Common.mulDiv18(xAbs, xAbs);\n\n        // Equivalent to `y % 2 == 1`.\n        if (yAux & 1 > 0) {\n            resultAbs = Common.mulDiv18(resultAbs, xAbs);\n        }\n    }\n\n    // The result must fit in SD59x18.\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert Errors.PRBMath_SD59x18_Powu_Overflow(x, y);\n    }\n\n    unchecked {\n        // Is the base negative and the exponent odd? If yes, the result should be negative.\n        int256 resultInt = int256(resultAbs);\n        bool isNegative = x.unwrap() < 0 && y & 1 == 1;\n        if (isNegative) {\n            resultInt = -resultInt;\n        }\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - Only the positive root is returned.\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x  0, since complex numbers are not supported.\n/// - x  MAX_SD59x18 / UNIT\n///\n/// @param x The SD59x18 number for which to calculate the square root.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        revert Errors.PRBMath_SD59x18_Sqrt_NegativeInput(x);\n    }\n    if (xInt > uMAX_SD59x18 / uUNIT) {\n        revert Errors.PRBMath_SD59x18_Sqrt_Overflow(x);\n    }\n\n    unchecked {\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two SD59x18 numbers.\n        // In this case, the two numbers are both the square root.\n        uint256 resultUint = Common.sqrt(uint256(xInt * uUNIT));\n        result = wrap(int256(resultUint));\n    }\n}\n",
        "keccak256": "0xd8e8b51db9b3e2fa31a60f6b8ce4ea0112c3364442ede5992aa0aa7a2c925c84",
        "license": "MIT"
      },
      "@prb/math/src/sd59x18/ValueType.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Casting.sol\" as Casting;\nimport \"./Helpers.sol\" as Helpers;\nimport \"./Math.sol\" as Math;\n\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type int256.\ntype SD59x18 is int256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoInt256,\n    Casting.intoSD1x18,\n    Casting.intoSD21x18,\n    Casting.intoUD2x18,\n    Casting.intoUD21x18,\n    Casting.intoUD60x18,\n    Casting.intoUint256,\n    Casting.intoUint128,\n    Casting.intoUint40,\n    Casting.unwrap\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Math.abs,\n    Math.avg,\n    Math.ceil,\n    Math.div,\n    Math.exp,\n    Math.exp2,\n    Math.floor,\n    Math.frac,\n    Math.gm,\n    Math.inv,\n    Math.log10,\n    Math.log2,\n    Math.ln,\n    Math.mul,\n    Math.pow,\n    Math.powu,\n    Math.sqrt\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Helpers.add,\n    Helpers.and,\n    Helpers.eq,\n    Helpers.gt,\n    Helpers.gte,\n    Helpers.isZero,\n    Helpers.lshift,\n    Helpers.lt,\n    Helpers.lte,\n    Helpers.mod,\n    Helpers.neq,\n    Helpers.not,\n    Helpers.or,\n    Helpers.rshift,\n    Helpers.sub,\n    Helpers.uncheckedAdd,\n    Helpers.uncheckedSub,\n    Helpers.uncheckedUnary,\n    Helpers.xor\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    OPERATORS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes it possible to use these operators on the SD59x18 type.\nusing {\n    Helpers.add as +,\n    Helpers.and2 as &,\n    Math.div as /,\n    Helpers.eq as ==,\n    Helpers.gt as >,\n    Helpers.gte as >=,\n    Helpers.lt as <,\n    Helpers.lte as <=,\n    Helpers.mod as %,\n    Math.mul as *,\n    Helpers.neq as !=,\n    Helpers.not as ~,\n    Helpers.or as |,\n    Helpers.sub as -,\n    Helpers.unary as -,\n    Helpers.xor as ^\n} for SD59x18 global;\n",
        "keccak256": "0x76597ba64d37d66e0178512bc9bbc1a031a7634c45e5d5c6e9da87f46952dc9d",
        "license": "MIT"
      },
      "@prb/math/src/ud21x18/Casting.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { UD21x18 } from \"./ValueType.sol\";\n\n/// @notice Casts a UD21x18 number into SD59x18.\n/// @dev There is no overflow check because UD21x18  SD59x18.\nfunction intoSD59x18(UD21x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(uint256(UD21x18.unwrap(x))));\n}\n\n/// @notice Casts a UD21x18 number into UD60x18.\n/// @dev There is no overflow check because UD21x18  UD60x18.\nfunction intoUD60x18(UD21x18 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(UD21x18.unwrap(x));\n}\n\n/// @notice Casts a UD21x18 number into uint128.\n/// @dev This is basically an alias for {unwrap}.\nfunction intoUint128(UD21x18 x) pure returns (uint128 result) {\n    result = UD21x18.unwrap(x);\n}\n\n/// @notice Casts a UD21x18 number into uint256.\n/// @dev There is no overflow check because UD21x18  uint256.\nfunction intoUint256(UD21x18 x) pure returns (uint256 result) {\n    result = uint256(UD21x18.unwrap(x));\n}\n\n/// @notice Casts a UD21x18 number into uint40.\n/// @dev Requirements:\n/// - x  MAX_UINT40\nfunction intoUint40(UD21x18 x) pure returns (uint40 result) {\n    uint128 xUint = UD21x18.unwrap(x);\n    if (xUint > uint128(Common.MAX_UINT40)) {\n        revert Errors.PRBMath_UD21x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud21x18(uint128 x) pure returns (UD21x18 result) {\n    result = UD21x18.wrap(x);\n}\n\n/// @notice Unwrap a UD21x18 number into uint128.\nfunction unwrap(UD21x18 x) pure returns (uint128 result) {\n    result = UD21x18.unwrap(x);\n}\n\n/// @notice Wraps a uint128 number into UD21x18.\nfunction wrap(uint128 x) pure returns (UD21x18 result) {\n    result = UD21x18.wrap(x);\n}\n",
        "keccak256": "0x3821aa57604f6e5b7c9c5c5cc97a6d71116e673cf3fee5f76fcd42b4cefded65",
        "license": "MIT"
      },
      "@prb/math/src/ud21x18/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { UD21x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as a UD21x18 number.\nUD21x18 constant E = UD21x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value a UD21x18 number can have.\nuint128 constant uMAX_UD21x18 = 340282366920938463463_374607431768211455;\nUD21x18 constant MAX_UD21x18 = UD21x18.wrap(uMAX_UD21x18);\n\n/// @dev PI as a UD21x18 number.\nUD21x18 constant PI = UD21x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of UD21x18.\nuint256 constant uUNIT = 1e18;\nUD21x18 constant UNIT = UD21x18.wrap(1e18);\n",
        "keccak256": "0x0997574a1ced6c43bde6d9c9175edc5ad64cbb920a0969a9db68eea543747601",
        "license": "MIT"
      },
      "@prb/math/src/ud21x18/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { UD21x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast a UD21x18 number that doesn't fit in uint40.\nerror PRBMath_UD21x18_IntoUint40_Overflow(UD21x18 x);\n",
        "keccak256": "0x35a1fb789b90f8c90865884d3023deb17fcca5c7146b5ddef823496d835a5415",
        "license": "MIT"
      },
      "@prb/math/src/ud21x18/ValueType.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The unsigned 21.18-decimal fixed-point number representation, which can have up to 21 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type uint128. This is useful when end users want to use uint128 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype UD21x18 is uint128;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for UD21x18 global;\n",
        "keccak256": "0x24838b2b1da371b9259d8ee21534a9f0cb5796aba75a4efca2374627952bee25",
        "license": "MIT"
      },
      "@prb/math/src/ud2x18/Casting.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @notice Casts a UD2x18 number into SD59x18.\n/// @dev There is no overflow check because UD2x18  SD59x18.\nfunction intoSD59x18(UD2x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(uint256(UD2x18.unwrap(x))));\n}\n\n/// @notice Casts a UD2x18 number into UD60x18.\n/// @dev There is no overflow check because UD2x18  UD60x18.\nfunction intoUD60x18(UD2x18 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(UD2x18.unwrap(x));\n}\n\n/// @notice Casts a UD2x18 number into uint128.\n/// @dev There is no overflow check because UD2x18  uint128.\nfunction intoUint128(UD2x18 x) pure returns (uint128 result) {\n    result = uint128(UD2x18.unwrap(x));\n}\n\n/// @notice Casts a UD2x18 number into uint256.\n/// @dev There is no overflow check because UD2x18  uint256.\nfunction intoUint256(UD2x18 x) pure returns (uint256 result) {\n    result = uint256(UD2x18.unwrap(x));\n}\n\n/// @notice Casts a UD2x18 number into uint40.\n/// @dev Requirements:\n/// - x  MAX_UINT40\nfunction intoUint40(UD2x18 x) pure returns (uint40 result) {\n    uint64 xUint = UD2x18.unwrap(x);\n    if (xUint > uint64(Common.MAX_UINT40)) {\n        revert Errors.PRBMath_UD2x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud2x18(uint64 x) pure returns (UD2x18 result) {\n    result = UD2x18.wrap(x);\n}\n\n/// @notice Unwrap a UD2x18 number into uint64.\nfunction unwrap(UD2x18 x) pure returns (uint64 result) {\n    result = UD2x18.unwrap(x);\n}\n\n/// @notice Wraps a uint64 number into UD2x18.\nfunction wrap(uint64 x) pure returns (UD2x18 result) {\n    result = UD2x18.wrap(x);\n}\n",
        "keccak256": "0x0f3141ed054e7c29dbe1acb4b88b18eb05d60e998fba6b4e503a6799faa356d6",
        "license": "MIT"
      },
      "@prb/math/src/ud2x18/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as a UD2x18 number.\nUD2x18 constant E = UD2x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value a UD2x18 number can have.\nuint64 constant uMAX_UD2x18 = 18_446744073709551615;\nUD2x18 constant MAX_UD2x18 = UD2x18.wrap(uMAX_UD2x18);\n\n/// @dev PI as a UD2x18 number.\nUD2x18 constant PI = UD2x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of UD2x18.\nUD2x18 constant UNIT = UD2x18.wrap(1e18);\nuint64 constant uUNIT = 1e18;\n",
        "keccak256": "0x29b0e050c865899e1fb9022b460a7829cdee248c44c4299f068ba80695eec3fc",
        "license": "MIT"
      },
      "@prb/math/src/ud2x18/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast a UD2x18 number that doesn't fit in uint40.\nerror PRBMath_UD2x18_IntoUint40_Overflow(UD2x18 x);\n",
        "keccak256": "0x3b27e2a57438cd30d9c130f84aace24d547e5ed58e8689691d7d92ad2db38ddd",
        "license": "MIT"
      },
      "@prb/math/src/ud2x18/ValueType.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The unsigned 2.18-decimal fixed-point number representation, which can have up to 2 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type uint64. This is useful when end users want to use uint64 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype UD2x18 is uint64;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for UD2x18 global;\n",
        "keccak256": "0x975a2e69b48f34a4c0bd80e8a5609ac67b7264c91992c0944f9ebe7b9e3fc9d0",
        "license": "MIT"
      },
      "@prb/math/src/ud60x18/Casting.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Errors.sol\" as CastingErrors;\nimport { MAX_UINT128, MAX_UINT40 } from \"../Common.sol\";\nimport { uMAX_SD1x18 } from \"../sd1x18/Constants.sol\";\nimport { SD1x18 } from \"../sd1x18/ValueType.sol\";\nimport { uMAX_SD21x18 } from \"../sd21x18/Constants.sol\";\nimport { SD21x18 } from \"../sd21x18/ValueType.sol\";\nimport { uMAX_SD59x18 } from \"../sd59x18/Constants.sol\";\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { uMAX_UD2x18 } from \"../ud2x18/Constants.sol\";\nimport { uMAX_UD21x18 } from \"../ud21x18/Constants.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport { UD21x18 } from \"../ud21x18/ValueType.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Casts a UD60x18 number into SD1x18.\n/// @dev Requirements:\n/// - x  uMAX_SD1x18\nfunction intoSD1x18(UD60x18 x) pure returns (SD1x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(int256(uMAX_SD1x18))) {\n        revert CastingErrors.PRBMath_UD60x18_IntoSD1x18_Overflow(x);\n    }\n    result = SD1x18.wrap(int64(uint64(xUint)));\n}\n\n/// @notice Casts a UD60x18 number into SD21x18.\n/// @dev Requirements:\n/// - x  uMAX_SD21x18\nfunction intoSD21x18(UD60x18 x) pure returns (SD21x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(int256(uMAX_SD21x18))) {\n        revert CastingErrors.PRBMath_UD60x18_IntoSD21x18_Overflow(x);\n    }\n    result = SD21x18.wrap(int128(uint128(xUint)));\n}\n\n/// @notice Casts a UD60x18 number into UD2x18.\n/// @dev Requirements:\n/// - x  uMAX_UD2x18\nfunction intoUD2x18(UD60x18 x) pure returns (UD2x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uMAX_UD2x18) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUD2x18_Overflow(x);\n    }\n    result = UD2x18.wrap(uint64(xUint));\n}\n\n/// @notice Casts a UD60x18 number into UD21x18.\n/// @dev Requirements:\n/// - x  uMAX_UD21x18\nfunction intoUD21x18(UD60x18 x) pure returns (UD21x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uMAX_UD21x18) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUD21x18_Overflow(x);\n    }\n    result = UD21x18.wrap(uint128(xUint));\n}\n\n/// @notice Casts a UD60x18 number into SD59x18.\n/// @dev Requirements:\n/// - x  uMAX_SD59x18\nfunction intoSD59x18(UD60x18 x) pure returns (SD59x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(uMAX_SD59x18)) {\n        revert CastingErrors.PRBMath_UD60x18_IntoSD59x18_Overflow(x);\n    }\n    result = SD59x18.wrap(int256(xUint));\n}\n\n/// @notice Casts a UD60x18 number into uint128.\n/// @dev This is basically an alias for {unwrap}.\nfunction intoUint256(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x);\n}\n\n/// @notice Casts a UD60x18 number into uint128.\n/// @dev Requirements:\n/// - x  MAX_UINT128\nfunction intoUint128(UD60x18 x) pure returns (uint128 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > MAX_UINT128) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUint128_Overflow(x);\n    }\n    result = uint128(xUint);\n}\n\n/// @notice Casts a UD60x18 number into uint40.\n/// @dev Requirements:\n/// - x  MAX_UINT40\nfunction intoUint40(UD60x18 x) pure returns (uint40 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > MAX_UINT40) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud(uint256 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(x);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud60x18(uint256 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(x);\n}\n\n/// @notice Unwraps a UD60x18 number into uint256.\nfunction unwrap(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x);\n}\n\n/// @notice Wraps a uint256 number into the UD60x18 value type.\nfunction wrap(uint256 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(x);\n}\n",
        "keccak256": "0x0803318ddc98b4ba8fbfe70e5ee08d78387fe6ae00982b9960518085a751d7b6",
        "license": "MIT"
      },
      "@prb/math/src/ud60x18/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { UD60x18 } from \"./ValueType.sol\";\n\n// NOTICE: the \"u\" prefix stands for \"unwrapped\".\n\n/// @dev Euler's number as a UD60x18 number.\nUD60x18 constant E = UD60x18.wrap(2_718281828459045235);\n\n/// @dev The maximum input permitted in {exp}.\nuint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\nUD60x18 constant EXP_MAX_INPUT = UD60x18.wrap(uEXP_MAX_INPUT);\n\n/// @dev The maximum input permitted in {exp2}.\nuint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\nUD60x18 constant EXP2_MAX_INPUT = UD60x18.wrap(uEXP2_MAX_INPUT);\n\n/// @dev Half the UNIT number.\nuint256 constant uHALF_UNIT = 0.5e18;\nUD60x18 constant HALF_UNIT = UD60x18.wrap(uHALF_UNIT);\n\n/// @dev $log_2(10)$ as a UD60x18 number.\nuint256 constant uLOG2_10 = 3_321928094887362347;\nUD60x18 constant LOG2_10 = UD60x18.wrap(uLOG2_10);\n\n/// @dev $log_2(e)$ as a UD60x18 number.\nuint256 constant uLOG2_E = 1_442695040888963407;\nUD60x18 constant LOG2_E = UD60x18.wrap(uLOG2_E);\n\n/// @dev The maximum value a UD60x18 number can have.\nuint256 constant uMAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_584007913129639935;\nUD60x18 constant MAX_UD60x18 = UD60x18.wrap(uMAX_UD60x18);\n\n/// @dev The maximum whole value a UD60x18 number can have.\nuint256 constant uMAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_000000000000000000;\nUD60x18 constant MAX_WHOLE_UD60x18 = UD60x18.wrap(uMAX_WHOLE_UD60x18);\n\n/// @dev PI as a UD60x18 number.\nUD60x18 constant PI = UD60x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of UD60x18.\nuint256 constant uUNIT = 1e18;\nUD60x18 constant UNIT = UD60x18.wrap(uUNIT);\n\n/// @dev The unit number squared.\nuint256 constant uUNIT_SQUARED = 1e36;\nUD60x18 constant UNIT_SQUARED = UD60x18.wrap(uUNIT_SQUARED);\n\n/// @dev Zero as a UD60x18 number.\nUD60x18 constant ZERO = UD60x18.wrap(0);\n",
        "keccak256": "0x2b80d26153d3fdcfb3a9ca772d9309d31ed1275f5b8b54c3ffb54d3652b37d90",
        "license": "MIT"
      },
      "@prb/math/src/ud60x18/Conversions.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { uMAX_UD60x18, uUNIT } from \"./Constants.sol\";\nimport { PRBMath_UD60x18_Convert_Overflow } from \"./Errors.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Converts a UD60x18 number to a simple integer by dividing it by `UNIT`.\n/// @dev The result is rounded toward zero.\n/// @param x The UD60x18 number to convert.\n/// @return result The same number in basic integer form.\nfunction convert(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x) / uUNIT;\n}\n\n/// @notice Converts a simple integer to UD60x18 by multiplying it by `UNIT`.\n///\n/// @dev Requirements:\n/// - x  MAX_UD60x18 / UNIT\n///\n/// @param x The basic integer to convert.\n/// @return result The same number converted to UD60x18.\nfunction convert(uint256 x) pure returns (UD60x18 result) {\n    if (x > uMAX_UD60x18 / uUNIT) {\n        revert PRBMath_UD60x18_Convert_Overflow(x);\n    }\n    unchecked {\n        result = UD60x18.wrap(x * uUNIT);\n    }\n}\n",
        "keccak256": "0xd486ecca97abe69acdb28230088f4c7097fbdae5b36c5ae45d5be2faac4c33f2",
        "license": "MIT"
      },
      "@prb/math/src/ud60x18/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when ceiling a number overflows UD60x18.\nerror PRBMath_UD60x18_Ceil_Overflow(UD60x18 x);\n\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows UD60x18.\nerror PRBMath_UD60x18_Convert_Overflow(uint256 x);\n\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\nerror PRBMath_UD60x18_Exp_InputTooBig(UD60x18 x);\n\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\nerror PRBMath_UD60x18_Exp2_InputTooBig(UD60x18 x);\n\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows UD60x18.\nerror PRBMath_UD60x18_Gm_Overflow(UD60x18 x, UD60x18 y);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\nerror PRBMath_UD60x18_IntoSD1x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD21x18.\nerror PRBMath_UD60x18_IntoSD21x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD59x18.\nerror PRBMath_UD60x18_IntoSD59x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\nerror PRBMath_UD60x18_IntoUD2x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD21x18.\nerror PRBMath_UD60x18_IntoUD21x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\nerror PRBMath_UD60x18_IntoUint128_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\nerror PRBMath_UD60x18_IntoUint40_Overflow(UD60x18 x);\n\n/// @notice Thrown when taking the logarithm of a number less than UNIT.\nerror PRBMath_UD60x18_Log_InputTooSmall(UD60x18 x);\n\n/// @notice Thrown when calculating the square root overflows UD60x18.\nerror PRBMath_UD60x18_Sqrt_Overflow(UD60x18 x);\n",
        "keccak256": "0xbab6b0e303d32f3a9d9e2fe881f0392b8c59a73051a4d34f21a403b3961b3044",
        "license": "MIT"
      },
      "@prb/math/src/ud60x18/Helpers.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport { wrap } from \"./Casting.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Implements the checked addition operation (+) in the UD60x18 type.\nfunction add(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() + y.unwrap());\n}\n\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\nfunction and(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() & bits);\n}\n\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\nfunction and2(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() & y.unwrap());\n}\n\n/// @notice Implements the equal operation (==) in the UD60x18 type.\nfunction eq(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() == y.unwrap();\n}\n\n/// @notice Implements the greater than operation (>) in the UD60x18 type.\nfunction gt(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() > y.unwrap();\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the UD60x18 type.\nfunction gte(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() >= y.unwrap();\n}\n\n/// @notice Implements a zero comparison check function in the UD60x18 type.\nfunction isZero(UD60x18 x) pure returns (bool result) {\n    // This wouldn't work if x could be negative.\n    result = x.unwrap() == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the UD60x18 type.\nfunction lshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the UD60x18 type.\nfunction lt(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() < y.unwrap();\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the UD60x18 type.\nfunction lte(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() <= y.unwrap();\n}\n\n/// @notice Implements the checked modulo operation (%) in the UD60x18 type.\nfunction mod(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() % y.unwrap());\n}\n\n/// @notice Implements the not equal operation (!=) in the UD60x18 type.\nfunction neq(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() != y.unwrap();\n}\n\n/// @notice Implements the NOT (~) bitwise operation in the UD60x18 type.\nfunction not(UD60x18 x) pure returns (UD60x18 result) {\n    result = wrap(~x.unwrap());\n}\n\n/// @notice Implements the OR (|) bitwise operation in the UD60x18 type.\nfunction or(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() | y.unwrap());\n}\n\n/// @notice Implements the right shift operation (>>) in the UD60x18 type.\nfunction rshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the UD60x18 type.\nfunction sub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() - y.unwrap());\n}\n\n/// @notice Implements the unchecked addition operation (+) in the UD60x18 type.\nfunction uncheckedAdd(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() + y.unwrap());\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the UD60x18 type.\nfunction uncheckedSub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() - y.unwrap());\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the UD60x18 type.\nfunction xor(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() ^ y.unwrap());\n}\n",
        "keccak256": "0xf5faff881391d2c060029499a666cc5f0bea90a213150bb476fae8f02a5df268",
        "license": "MIT"
      },
      "@prb/math/src/ud60x18/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport { wrap } from \"./Casting.sol\";\nimport {\n    uEXP_MAX_INPUT,\n    uEXP2_MAX_INPUT,\n    uHALF_UNIT,\n    uLOG2_10,\n    uLOG2_E,\n    uMAX_UD60x18,\n    uMAX_WHOLE_UD60x18,\n    UNIT,\n    uUNIT,\n    uUNIT_SQUARED,\n    ZERO\n} from \"./Constants.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the arithmetic average of x and y using the following formula:\n///\n/// $$\n/// avg(x, y) = (x & y) + ((xUint ^ yUint) / 2)\n/// $$\n///\n/// In English, this is what this formula does:\n///\n/// 1. AND x and y.\n/// 2. Calculate half of XOR x and y.\n/// 3. Add the two results together.\n///\n/// This technique is known as SWAR, which stands for \"SIMD within a register\". You can read more about it here:\n/// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// @param x The first operand as a UD60x18 number.\n/// @param y The second operand as a UD60x18 number.\n/// @return result The arithmetic average as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction avg(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    uint256 yUint = y.unwrap();\n    unchecked {\n        result = wrap((xUint & yUint) + ((xUint ^ yUint) >> 1));\n    }\n}\n\n/// @notice Yields the smallest whole number greater than or equal to x.\n///\n/// @dev This is optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x  MAX_WHOLE_UD60x18\n///\n/// @param x The UD60x18 number to ceil.\n/// @return result The smallest whole number greater than or equal to x, as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ceil(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    if (xUint > uMAX_WHOLE_UD60x18) {\n        revert Errors.PRBMath_UD60x18_Ceil_Overflow(x);\n    }\n\n    assembly (\"memory-safe\") {\n        // Equivalent to `x % UNIT`.\n        let remainder := mod(x, uUNIT)\n\n        // Equivalent to `UNIT - remainder`.\n        let delta := sub(uUNIT, remainder)\n\n        // Equivalent to `x + remainder > 0 ? delta : 0`.\n        result := add(x, mul(delta, gt(remainder, 0)))\n    }\n}\n\n/// @notice Divides two UD60x18 numbers, returning a new UD60x18 number.\n///\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv}.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv}.\n///\n/// @param x The numerator as a UD60x18 number.\n/// @param y The denominator as a UD60x18 number.\n/// @return result The quotient as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(Common.mulDiv(x.unwrap(), uUNIT, y.unwrap()));\n}\n\n/// @notice Calculates the natural exponent of x using the following formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// @dev Requirements:\n/// - x  133_084258667509499440\n///\n/// @param x The exponent as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\n    if (xUint > uEXP_MAX_INPUT) {\n        revert Errors.PRBMath_UD60x18_Exp_InputTooBig(x);\n    }\n\n    unchecked {\n        // Inline the fixed-point multiplication to save gas.\n        uint256 doubleUnitProduct = xUint * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n///\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693\n///\n/// Requirements:\n/// - x < 192e18\n/// - The result must fit in UD60x18.\n///\n/// @param x The exponent as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\n    if (xUint > uEXP2_MAX_INPUT) {\n        revert Errors.PRBMath_UD60x18_Exp2_InputTooBig(x);\n    }\n\n    // Convert x to the 192.64-bit fixed-point format.\n    uint256 x_192x64 = (xUint << 64) / uUNIT;\n\n    // Pass x to the {Common.exp2} function, which uses the 192.64-bit fixed-point number representation.\n    result = wrap(Common.exp2(x_192x64));\n}\n\n/// @notice Yields the greatest whole number less than or equal to x.\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n/// @param x The UD60x18 number to floor.\n/// @return result The greatest whole number less than or equal to x, as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction floor(UD60x18 x) pure returns (UD60x18 result) {\n    assembly (\"memory-safe\") {\n        // Equivalent to `x % UNIT`.\n        let remainder := mod(x, uUNIT)\n\n        // Equivalent to `x - remainder > 0 ? remainder : 0)`.\n        result := sub(x, mul(remainder, gt(remainder, 0)))\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x using the odd function definition.\n/// @dev See https://en.wikipedia.org/wiki/Fractional_part.\n/// @param x The UD60x18 number to get the fractional part of.\n/// @return result The fractional part of x as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction frac(UD60x18 x) pure returns (UD60x18 result) {\n    assembly (\"memory-safe\") {\n        result := mod(x, uUNIT)\n    }\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. $\\sqrt{x * y}$, rounding down.\n///\n/// @dev Requirements:\n/// - x * y must fit in UD60x18.\n///\n/// @param x The first operand as a UD60x18 number.\n/// @param y The second operand as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction gm(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    uint256 yUint = y.unwrap();\n    if (xUint == 0 || yUint == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Checking for overflow this way is faster than letting Solidity do it.\n        uint256 xyUint = xUint * yUint;\n        if (xyUint / xUint != yUint) {\n            revert Errors.PRBMath_UD60x18_Gm_Overflow(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\n        // during multiplication. See the comments in {Common.sqrt}.\n        result = wrap(Common.sqrt(xyUint));\n    }\n}\n\n/// @notice Calculates the inverse of x.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x must not be zero.\n///\n/// @param x The UD60x18 number for which to calculate the inverse.\n/// @return result The inverse as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction inv(UD60x18 x) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(uUNIT_SQUARED / x.unwrap());\n    }\n}\n\n/// @notice Calculates the natural logarithm of x using the following formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The UD60x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ln(UD60x18 x) pure returns (UD60x18 result) {\n    unchecked {\n        // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\n        // {log2} can return is ~196_205294292027477728.\n        result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\n    }\n}\n\n/// @notice Calculates the common logarithm of x using the following formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// However, if x is an exact power of ten, a hard coded value is returned.\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The UD60x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log10(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    if (xUint < uUNIT) {\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\n    }\n\n    // Note that the `mul` in this assembly block is the standard multiplication operation, not {UD60x18.mul}.\n    // prettier-ignore\n    assembly (\"memory-safe\") {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 59) }\n        default { result := uMAX_UD60x18 }\n    }\n\n    if (result.unwrap() == uMAX_UD60x18) {\n        unchecked {\n            // Inline the fixed-point division to save gas.\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\n///\n/// $$\n/// log_2{x} = n + log_2{y}, \\text{ where } y = x*2^{-n}, \\ y \\in [1, 2)\n/// $$\n///\n/// For $0 \\leq x \\lt 1$, the input is inverted:\n///\n/// $$\n/// log_2{x} = -log_2{\\frac{1}{x}}\n/// $$\n///\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n///\n/// Notes:\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\n///\n/// Requirements:\n/// - x  UNIT\n///\n/// @param x The UD60x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log2(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    if (xUint < uUNIT) {\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\n    }\n\n    unchecked {\n        // Calculate the integer part of the logarithm.\n        uint256 n = Common.msb(xUint / uUNIT);\n\n        // This is the integer part of the logarithm as a UD60x18 number. The operation can't overflow because n\n        // n is at most 255 and UNIT is 1e18.\n        uint256 resultUint = n * uUNIT;\n\n        // Calculate $y = x * 2^{-n}$.\n        uint256 y = xUint >> n;\n\n        // If y is the unit number, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultUint);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\n        uint256 DOUBLE_UNIT = 2e18;\n        for (uint256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultUint += delta;\n\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\n                y >>= 1;\n            }\n        }\n        result = wrap(resultUint);\n    }\n}\n\n/// @notice Multiplies two UD60x18 numbers together, returning a new UD60x18 number.\n///\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv}.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv}.\n///\n/// @dev See the documentation in {Common.mulDiv18}.\n/// @param x The multiplicand as a UD60x18 number.\n/// @param y The multiplier as a UD60x18 number.\n/// @return result The product as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(Common.mulDiv18(x.unwrap(), y.unwrap()));\n}\n\n/// @notice Raises x to the power of y.\n///\n/// For $1 \\leq x \\leq \\infty$, the following standard formula is used:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// For $0 \\leq x \\lt 1$, since the unsigned {log2} is undefined, an equivalent formula is used:\n///\n/// $$\n/// i = \\frac{1}{x}\n/// w = 2^{log_2{i} * y}\n/// x^y = \\frac{1}{w}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2} and {mul}.\n/// - Returns `UNIT` for 0^0.\n/// - It may not perform well with very small values of x. Consider using SD59x18 as an alternative.\n///\n/// Requirements:\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\n///\n/// @param x The base as a UD60x18 number.\n/// @param y The exponent as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction pow(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    uint256 yUint = y.unwrap();\n\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\n    if (xUint == 0) {\n        return yUint == 0 ? UNIT : ZERO;\n    }\n    // If x is `UNIT`, the result is always `UNIT`.\n    else if (xUint == uUNIT) {\n        return UNIT;\n    }\n\n    // If y is zero, the result is always `UNIT`.\n    if (yUint == 0) {\n        return UNIT;\n    }\n    // If y is `UNIT`, the result is always x.\n    else if (yUint == uUNIT) {\n        return x;\n    }\n\n    // If x is > UNIT, use the standard formula.\n    if (xUint > uUNIT) {\n        result = exp2(mul(log2(x), y));\n    }\n    // Conversely, if x < UNIT, use the equivalent formula.\n    else {\n        UD60x18 i = wrap(uUNIT_SQUARED / xUint);\n        UD60x18 w = exp2(mul(log2(i), y));\n        result = wrap(uUNIT_SQUARED / w.unwrap());\n    }\n}\n\n/// @notice Raises x (a UD60x18 number) to the power y (an unsigned basic integer) using the well-known\n/// algorithm \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv18}.\n/// - Returns `UNIT` for 0^0.\n///\n/// Requirements:\n/// - The result must fit in UD60x18.\n///\n/// @param x The base as a UD60x18 number.\n/// @param y The exponent as a uint256.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction powu(UD60x18 x, uint256 y) pure returns (UD60x18 result) {\n    // Calculate the first iteration of the loop in advance.\n    uint256 xUint = x.unwrap();\n    uint256 resultUint = y & 1 > 0 ? xUint : uUNIT;\n\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\n    for (y >>= 1; y > 0; y >>= 1) {\n        xUint = Common.mulDiv18(xUint, xUint);\n\n        // Equivalent to `y % 2 == 1`.\n        if (y & 1 > 0) {\n            resultUint = Common.mulDiv18(resultUint, xUint);\n        }\n    }\n    result = wrap(resultUint);\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x  MAX_UD60x18 / UNIT\n///\n/// @param x The UD60x18 number for which to calculate the square root.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    unchecked {\n        if (xUint > uMAX_UD60x18 / uUNIT) {\n            revert Errors.PRBMath_UD60x18_Sqrt_Overflow(x);\n        }\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two UD60x18 numbers.\n        // In this case, the two numbers are both the square root.\n        result = wrap(Common.sqrt(xUint * uUNIT));\n    }\n}\n",
        "keccak256": "0xc4e51dfd9af62938e277e90fa724099f239d33727a35909ed48c292a76faf2fc",
        "license": "MIT"
      },
      "@prb/math/src/ud60x18/ValueType.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"./Casting.sol\" as Casting;\nimport \"./Helpers.sol\" as Helpers;\nimport \"./Math.sol\" as Math;\n\n/// @notice The unsigned 60.18-decimal fixed-point number representation, which can have up to 60 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the Solidity type uint256.\n/// @dev The value type is defined here so it can be imported in all other files.\ntype UD60x18 is uint256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD1x18,\n    Casting.intoSD21x18,\n    Casting.intoSD59x18,\n    Casting.intoUD2x18,\n    Casting.intoUD21x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes the functions in this library callable on the UD60x18 type.\nusing {\n    Math.avg,\n    Math.ceil,\n    Math.div,\n    Math.exp,\n    Math.exp2,\n    Math.floor,\n    Math.frac,\n    Math.gm,\n    Math.inv,\n    Math.ln,\n    Math.log10,\n    Math.log2,\n    Math.mul,\n    Math.pow,\n    Math.powu,\n    Math.sqrt\n} for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes the functions in this library callable on the UD60x18 type.\nusing {\n    Helpers.add,\n    Helpers.and,\n    Helpers.eq,\n    Helpers.gt,\n    Helpers.gte,\n    Helpers.isZero,\n    Helpers.lshift,\n    Helpers.lt,\n    Helpers.lte,\n    Helpers.mod,\n    Helpers.neq,\n    Helpers.not,\n    Helpers.or,\n    Helpers.rshift,\n    Helpers.sub,\n    Helpers.uncheckedAdd,\n    Helpers.uncheckedSub,\n    Helpers.xor\n} for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    OPERATORS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes it possible to use these operators on the UD60x18 type.\nusing {\n    Helpers.add as +,\n    Helpers.and2 as &,\n    Math.div as /,\n    Helpers.eq as ==,\n    Helpers.gt as >,\n    Helpers.gte as >=,\n    Helpers.lt as <,\n    Helpers.lte as <=,\n    Helpers.or as |,\n    Helpers.mod as %,\n    Math.mul as *,\n    Helpers.neq as !=,\n    Helpers.not as ~,\n    Helpers.sub as -,\n    Helpers.xor as ^\n} for UD60x18 global;\n",
        "keccak256": "0x1b200baf25d01a8b91b97b42114248636f742b5b7028487ef4daef6621e378a3",
        "license": "MIT"
      },
      "src/interfaces/IDustLock.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {IRevenueReward} from \"./IRevenueReward.sol\";\n\n/**\n * @title IDustLock Interface\n * @notice Interface for the DustLock contract that manages voting escrow NFTs (veNFTs)\n * @dev Combines ERC721 with vote-escrow functionality for governance and reward distribution\n */\ninterface IDustLock is IERC4906, IERC6372, IERC721Metadata {\n    /**\n     * @notice Structure representing a locked token position\n     * @dev Used to track the amount of tokens locked, when they unlock, and if they're permanently locked\n     * @param amount Amount of tokens locked in int256 format for consistency with precision calculations\n     * @param effectiveStart Effective start time for penalty calculations (weighted average on lock operations)\n     * @param end Timestamp when tokens unlock (0 for permanent locks)\n     * @param isPermanent Whether this is a permanent lock that cannot be withdrawn normally\n     */\n    struct LockedBalance {\n        int256 amount;\n        uint256 effectiveStart;\n        uint256 end;\n        bool isPermanent;\n    }\n\n    /**\n     * @notice Checkpoint for tracking user voting power at a specific point in time\n     * @dev Used in the vote-escrow system to track decay of voting power over time\n     * @param bias Voting power at time ts\n     * @param slope Rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanent Amount of permanent (non-decaying) voting power\n     */\n    struct UserPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanent;\n    }\n\n    /**\n     * @notice Global checkpoint for tracking total voting power at a specific point in time\n     * @dev Similar to UserPoint but tracks system-wide totals\n     * @param bias Total voting power at time ts\n     * @param slope Total rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanentLockBalance Total amount of permanently locked tokens\n     */\n    struct GlobalPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanentLockBalance;\n    }\n\n    /**\n     * @notice Types of deposit operations supported by the veNFT system\n     * @param DEPOSIT_FOR_TYPE Adding tokens to an existing lock owned by someone else\n     * @param CREATE_LOCK_TYPE Creating a new lock position\n     * @param INCREASE_LOCK_AMOUNT Adding more tokens to an existing lock\n     * @param INCREASE_UNLOCK_TIME Extending the lock duration of an existing lock\n     */\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /// @notice Error thrown when the locked amount is less than minLockAmount\n    error AmountTooSmall();\n\n    /// @notice Error thrown when the requested amount exceeds available balance\n    error AmountTooBig();\n\n    /// @notice Error thrown when an ERC721 receiver contract rejects the tokens\n    error ERC721ReceiverRejectedTokens();\n\n    /// @notice Error thrown when transferring to an address that doesn't implement ERC721Receiver\n    error ERC721TransferToNonERC721ReceiverImplementer();\n\n    /// @notice Error thrown when an early withdraw penalty value is invalid (>=10000)\n    error InvalidWithdrawPenalty();\n\n    /// @notice Error thrown when the lock duration doesn't extend beyond the current time\n    error LockDurationNotInFuture();\n\n    /// @notice Error thrown when the lock duration exceeds the maximum allowed time\n    error LockDurationTooLong();\n\n    /// @notice Error thrown when the lock duration is less than the minimum required time\n    error LockDurationTooShort();\n\n    /// @notice Error thrown when trying to depositFor to a lock expiring within MINTIME\n    error DepositForLockDurationTooShort();\n\n    /// @notice Error thrown when trying to perform an operation on an expired lock\n    error LockExpired();\n\n    /// @notice Error thrown when trying to withdraw from a lock that hasn't expired yet\n    error LockNotExpired();\n\n    /// @notice Error thrown when no lock is found for the specified token ID\n    error NoLockFound();\n\n    /// @notice Error thrown when the caller is neither the owner nor approved for the token\n    error NotApprovedOrOwner();\n\n    /// @notice Error thrown when trying to unlock a non-permanent lock using unlockPermanent\n    error NotPermanentLock();\n\n    /// @notice Error thrown when the caller is not the owner of the token\n    error NotOwner();\n\n    /// @notice Error thrown when a team-only function is called by a non-team address\n    error NotTeam();\n\n    /// @notice Error thrown when a pending team function is called by a non-pending team address\n    error NotPendingTeam();\n\n    /// @notice Error thrown when trying to withdraw or modify a permanent lock\n    error PermanentLock();\n\n    /// @notice Error thrown when attempting to merge a veNFT with itself\n    error SameNFT();\n\n    /// @notice Error thrown when splitting is not allowed for the user\n    error SplitNotAllowed();\n\n    /// @notice Error thrown when trying to add a token that already has an owner\n    error AlreadyOwned();\n\n    /// @notice Error thrown when setting a revenue reward contract that is not a deployed contract\n    error InvalidRevenueRewardContract();\n\n    /**\n     * @notice Emitted when tokens are deposited into the veNFT system\n     * @param provider Address depositing the tokens\n     * @param tokenId ID of the veNFT being created or modified\n     * @param depositType Type of deposit operation (create, increase amount, etc.)\n     * @param value Amount of tokens deposited\n     * @param locktime Timestamp when the lock expires\n     * @param ts Timestamp when the deposit occurred\n     */\n    event Deposit(\n        address indexed provider,\n        uint256 indexed tokenId,\n        DepositType indexed depositType,\n        uint256 value,\n        uint256 locktime,\n        uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn before the lock expiry with a penalty\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Original locked amount\n     * @param amountReturned Amount returned to the user after penalty\n     * @param ts Timestamp when the early withdrawal occurred\n     */\n    event EarlyWithdraw(\n        address indexed provider, uint256 indexed tokenId, uint256 value, uint256 amountReturned, uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn after the lock expiry\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Amount of tokens withdrawn\n     * @param ts Timestamp when the withdrawal occurred\n     */\n    event Withdraw(address indexed provider, uint256 indexed tokenId, uint256 value, uint256 ts);\n\n    /**\n     * @notice Emitted when a lock is converted to a permanent lock\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being locked permanently\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was created\n     */\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when a permanent lock is unlocked by governance\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being unlocked\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was unlocked\n     */\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when the total supply of locked tokens changes\n     * @param prevSupply Previous total locked supply\n     * @param supply New total locked supply\n     */\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    /**\n     * @notice Emitted when two veNFTs are merged\n     * @param _sender Address initiating the merge\n     * @param _from Source veNFT ID (burned in the process)\n     * @param _to Destination veNFT ID (receives combined balance)\n     * @param _amountFrom Amount of tokens in the source veNFT\n     * @param _amountTo Amount of tokens in the destination veNFT before merge\n     * @param _amountFinal Final amount of tokens in the destination veNFT after merge\n     * @param _locktime New lock expiry time for the merged veNFT\n     * @param _ts Timestamp when the merge occurred\n     */\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a veNFT is split into two separate veNFTs\n     * @param _from Original veNFT ID being split (burned in the process)\n     * @param _tokenId1 First new veNFT ID created from the split\n     * @param _tokenId2 Second new veNFT ID created from the split\n     * @param _sender Address initiating the split\n     * @param _splitAmount1 Amount of tokens allocated to the first veNFT\n     * @param _splitAmount2 Amount of tokens allocated to the second veNFT\n     * @param _locktime Lock expiry time for both new veNFTs\n     * @param _ts Timestamp when the split occurred\n     */\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a new team address is proposed\n     * @param currentTeam The current team address that proposed the change\n     * @param proposedTeam The newly proposed team address\n     */\n    event TeamProposed(address indexed currentTeam, address indexed proposedTeam);\n\n    /**\n     * @notice Emitted when a proposed team address accepts ownership\n     * @param oldTeam The previous team address\n     * @param newTeam The new team address that accepted ownership\n     */\n    event TeamAccepted(address indexed oldTeam, address indexed newTeam);\n\n    /**\n     * @notice Emitted when a team proposal is cancelled\n     * @param currentTeam The current team address that cancelled the proposal\n     * @param cancelledTeam The proposed team address that was cancelled\n     */\n    event TeamProposalCancelled(address indexed currentTeam, address indexed cancelledTeam);\n\n    /**\n     * @notice Emitted when the early withdraw penalty is updated\n     * @param oldPenalty Previous penalty in basis points\n     * @param newPenalty New penalty in basis points\n     */\n    event EarlyWithdrawPenaltyUpdated(uint256 oldPenalty, uint256 newPenalty);\n\n    /**\n     * @notice Emitted when the early withdraw treasury address is updated\n     * @param oldTreasury Previous treasury address\n     * @param newTreasury New treasury address\n     */\n    event EarlyWithdrawTreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Emitted when the minimum lock amount is updated\n     * @param oldAmount Previous minimum lock amount\n     * @param newAmount New minimum lock amount\n     */\n    event MinLockAmountUpdated(uint256 oldAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted when the revenue reward contract is updated\n     * @param oldReward Previous revenue reward contract address\n     * @param newReward New revenue reward contract address\n     */\n    event RevenueRewardUpdated(address indexed oldReward, address indexed newReward);\n\n    /**\n     * @notice Emitted when the split permission is toggled for an account\n     * @param account Address whose permission is updated\n     * @param allowed Whether splitting is now allowed for the account\n     */\n    event SplitPermissionUpdated(address indexed account, bool allowed);\n\n    /**\n     * @notice Emitted when the base URI is updated\n     * @param oldBaseURI Previous base URI\n     * @param newBaseURI New base URI\n     */\n    event BaseURIUpdated(string oldBaseURI, string newBaseURI);\n\n    /*//////////////////////////////////////////////////////////////\n                                STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Address of Meta-tx Forwarder\n     * @return The trusted forwarder address used for meta-transactions\n     */\n    function forwarder() external view returns (address);\n\n    /**\n     * @notice Address of token (DUST) used to create a veNFT\n     * @return The ERC20 token address used to lock and mint veNFTs\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Address of Neverland Team multisig\n     * @return The address of the current team multisig with administrative privileges\n     */\n    function team() external view returns (address);\n\n    /**\n     * @notice Address of pending team for two-step ownership transfer\n     * @return The address of the pending team, or address(0) if no proposal exists\n     */\n    function pendingTeam() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Proposes a new team address for two-step ownership transfer\n     * @dev This is the first step of a two-step ownership transfer process.\n     *      Only the current team can propose a new team address.\n     *      The proposed address must accept ownership to complete the transfer.\n     *      This prevents accidental loss of admin control due to typos or wrong addresses.\n     * @param _newTeam The address of the proposed new team multisig\n     */\n    function proposeTeam(address _newTeam) external;\n\n    /**\n     * @notice Accepts the proposed team address to complete the ownership transfer\n     * @dev This is the second step of the two-step ownership transfer process.\n     *      Only the pending team address can call this function.\n     *      Once called, the caller becomes the new team and the pending team is cleared.\n     *      This ensures that the new team controls the proposed address.\n     */\n    function acceptTeam() external;\n\n    /**\n     * @notice Cancels the pending team proposal\n     * @dev Allows the current team to cancel a pending ownership transfer.\n     *      Only the current team can call this function.\n     *      This is useful if the team made an error in the proposed address.\n     *      After cancellation, a new proposal can be made.\n     */\n    function cancelTeamProposal() external;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the name of the token\n     * @return The name of the veNFT token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token\n     * @return The symbol of the veNFT token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns the version of the contract\n     * @return The current version string of the contract\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice Updates the base URI for computing tokenURI\n     * @dev Can only be called by the team address\n     * @param newBaseURI The new base URI to set for all tokens\n     */\n    function setBaseURI(string memory newBaseURI) external;\n\n    /**\n     * @notice Current total count of veNFT tokens\n     * @dev Used as a counter for minting new tokens and assigning IDs\n     * @return The current highest token ID value\n     */\n    function tokenId() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the tokenId owned by `_owner` at position `_index`\n     * @param _owner Owner address to query\n     * @param _index Index of the token within the owner's list\n     * @return _tokenId The tokenId at the given index for the owner\n     */\n    function ownerToNFTokenIdList(address _owner, uint256 _index) external view returns (uint256 _tokenId);\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @notice Check whether spender is owner or an approved user for a given veNFT\n     * @param _spender The address to approve for the tokenId\n     * @param _tokenId The ID of the veNFT to be approved\n     * @return True if `_spender` is owner or approved for `_tokenId`, false otherwise\n     */\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Total count of epochs witnessed since contract creation\n     * @return The current epoch number\n     */\n    function epoch() external view returns (uint256);\n\n    /**\n     * @notice Total amount of tokens currently locked in the contract\n     * @return The total supply of locked tokens\n     */\n    function supply() external view returns (uint256);\n\n    /**\n     * @notice Aggregate balance of permanently locked tokens\n     * @dev These tokens cannot be withdrawn through normal means\n     * @return The total amount of permanently locked tokens\n     */\n    function permanentLockBalance() external view returns (uint256);\n\n    /**\n     * @notice Percentage of penalty applied to early withdrawals (in basis points)\n     * @dev Value is between 0 and 10000 (0% to 100%)\n     * @return The current penalty percentage in basis points\n     */\n    function earlyWithdrawPenalty() external view returns (uint256);\n\n    /**\n     * @notice Address that receives penalty fees from early withdrawals\n     * @return The address of the treasury that collects early withdrawal penalties\n     */\n    function earlyWithdrawTreasury() external view returns (address);\n\n    /**\n     * @notice Get the current epoch number for a specific veNFT\n     * @param _tokenId The ID of the veNFT to check\n     * @return _epoch The current epoch number for the specified veNFT\n     */\n    function userPointEpoch(uint256 _tokenId) external view returns (uint256 _epoch);\n\n    /**\n     * @notice Retrieve the scheduled slope change at a given timestamp\n     * @dev Used to calculate future voting power changes due to lock expirations\n     * @param _timestamp The timestamp to check for slope changes\n     * @return The net change in slope (negative value means decrease in voting power)\n     */\n    function slopeChanges(uint256 _timestamp) external view returns (int256);\n\n    /**\n     * @notice Check if an account has permission to split veNFTs\n     * @dev Used to control which addresses can perform veNFT splitting operations\n     * @param _account The address to check for split permission\n     * @return True if the account can split veNFTs, false otherwise\n     */\n    function canSplit(address _account) external view returns (bool);\n\n    /**\n     * @notice Retrieve a global checkpoint at a specific index\n     * @dev Used to track historical voting power across all tokens at different points in time\n     * @param _loc The index of the checkpoint to retrieve\n     * @return The GlobalPoint data at the specified index\n     */\n    function pointHistory(uint256 _loc) external view returns (GlobalPoint memory);\n\n    /**\n     * @notice Get the lock details for a specific veNFT\n     * @dev Returns information about lock amount, end time, and permanent status\n     * @param _tokenId The ID of the veNFT to query\n     * @return The LockedBalance struct containing lock information\n     */\n    function locked(uint256 _tokenId) external view returns (LockedBalance memory);\n\n    /**\n     * @notice Retrieve a user checkpoint for a specific veNFT at a given index\n     * @dev Used to track historical voting power for individual tokens\n     * @param _tokenId The ID of the veNFT to query\n     * @param _loc The index of the user checkpoint to retrieve\n     * @return The UserPoint data at the specified index for the given token\n     */\n    function userPointHistory(uint256 _tokenId, uint256 _loc) external view returns (UserPoint memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Create a global checkpoint to record the current state of voting power\n     * @dev Updates the global point history with current voting power data\n     *      This is called automatically by most state-changing functions\n     *      but can be called manually to ensure up-to-date on-chain data\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT lock\n     * @dev Anyone (even a smart contract) can deposit tokens for someone else's lock\n     *      The deposit increases the lock amount but does not extend the lock time\n     *      Cannot be used for locks that have already expired\n     * @param _tokenId The ID of the veNFT to deposit for\n     * @param _value Amount of tokens to add to the existing lock\n     */\n    function depositFor(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Create a new lock by depositing tokens for the caller\n     * @dev Creates a new veNFT representing the locked tokens\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return The ID of the newly created veNFT\n     */\n    function createLock(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock by depositing tokens for another address\n     * @dev Creates a new veNFT representing the locked tokens and assigns it to the specified recipient\n     *      This is useful for protocols that want to create locks on behalf of their users\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return The ID of the newly created veNFT\n     */\n    function createLockFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for the caller and immediately make it permanent\n     * @dev UX convenience to perform \"create lock\" and \"make permanent\" in a single transaction\n     *      Follows the same validation as `createLock` (min amount, duration bounds, week rounding)\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanent(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for `to` and immediately make it permanent\n     * @dev UX convenience to mint the veNFT to `to` and set permanence in one transaction\n     *      Uses `to` as the owner for auth semantics; validation mirrors `createLock`\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanentFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT without modifying the unlock time\n     * @dev Increases the amount of tokens in a lock while keeping the same unlock date\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to increase the amount for\n     * @param _value Additional amount of tokens to add to the lock\n     */\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Extend the unlock time for an existing veNFT lock\n     * @dev Increases the lock duration without changing the token amount\n     *      Cannot extend lock time of permanent locks\n     *      New lock time is rounded down to the nearest week\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to extend the lock duration for\n     * @param _lockDuration New number of seconds until tokens unlock (from current time)\n     */\n    function increaseUnlockTime(uint256 _tokenId, uint256 _lockDuration) external;\n\n    /**\n     * @notice Withdraw all tokens from an expired lock for `_tokenId`\n     * @dev Only possible if the lock has expired and is not a permanent lock\n     *      This function burns the veNFT and returns the locked tokens to the owner\n     *      IMPORTANT: Any unclaimed rebases or rewards will no longer be claimable after calling this\n     *      Users should claim all rebases and rewards prior to withdrawing\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw tokens from\n     */\n    function withdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Withdraw tokens from a lock before it expires, with a time-proportional penalty\n     * @dev Allows users to exit a lock early but with a penalty fee applied\n     *      The penalty is proportional to both `earlyWithdrawPenalty` and remaining time until unlock\n     *      If the lock is permanent, it is internally converted back to a standard time-lock first and\n     *      the early withdraw penalty is computed using the restored lock window. Penalty fees are sent\n     *      to the `earlyWithdrawTreasury` address. Burns the veNFT and returns the nonpenalized portion\n     *      of tokens to the owner. Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw early from\n     */\n    function earlyWithdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Sets the early withdrawal penalty percentage\n     * @dev Can only be called by the team address\n     *      Value is in basis points (0-10000), where 10000 = 100%\n     * @param _earlyWithdrawPenalty The new penalty percentage in basis points\n     */\n    function setEarlyWithdrawPenalty(uint256 _earlyWithdrawPenalty) external;\n\n    /**\n     * @notice Sets the treasury address that will receive penalty fees from early withdrawals\n     * @dev Can only be called by the team address\n     *      The treasury address receives the penalty portion of tokens from early withdrawals\n     * @param _account The address of the new treasury that will receive penalty fees\n     */\n    function setEarlyWithdrawTreasury(address _account) external;\n\n    /**\n     * @notice Merges two veNFTs by combining their locked tokens into a single veNFT\n     * @dev The source veNFT is burned and its tokens are added to the destination veNFT\n     *      The lock duration/semantics of the destination veNFT are preserved\n     *      Rules:\n     *      - permanent + permanent: allowed (destination stays permanent)\n     *      - nonpermanent + permanent: allowed (permanent principal increases)\n     *      - permanent + nonpermanent: reverts\n     *      - expired source or destination: reverts\n     *      Can only be called by an address that owns or is approved for both veNFTs\n     * @param _from The ID of the source veNFT to merge from (will be burned)\n     * @param _to The ID of the destination veNFT to merge into (will receive the combined tokens)\n     */\n    function merge(uint256 _from, uint256 _to) external;\n\n    /**\n     * @notice Splits a veNFT into two new veNFTs with divided token balances\n     * @dev This operation burns the original veNFT and creates two new ones\n     *      Both new veNFTs maintain the same lock end time as the original\n     *      Can only be called by an address that has split permission, and owns or is approved for the veNFT\n     *      If called by an approved address, that address will NOT have approval on the new veNFTs\n     *      (approvals on the parent do not carry over to children)\n     *      Requires that the caller is either the owner or specifically has been granted split permission\n     *      Cannot split permanent locks\n     * @param _from The ID of the veNFT to split (will be burned)\n     * @param _amount The precise token amount to allocate to the second new veNFT\n     * @return _tokenId1 ID of the first new veNFT with (original amount - _amount) tokens\n     * @return _tokenId2 ID of the second new veNFT with exactly _amount tokens\n     */\n    function split(uint256 _from, uint256 _amount) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n    /**\n     * @notice Grant or revoke permission for an address to split veNFTs\n     * @dev Can only be called by the team address\n     *      Setting permissions for address(0) acts as a global switch for all addresses\n     *      If address(0) is set to false, no address can split regardless of individual permissions\n     *      If address(0) is set to true, individual permissions apply normally\n     * @param _account The address to modify split permissions for, or address(0) for global setting\n     * @param _bool True to grant permission, false to revoke permission\n     */\n    function toggleSplit(address _account, bool _bool) external;\n\n    /**\n     * @notice Permanently lock a veNFT to give it non-decaying voting power\n     * @dev Converts a standard time-locked veNFT to a permanent lock\n     *      Once permanent, the veNFT cannot be withdrawn normally (even after the original lock time)\n     *      Permanent locks have constant voting power equal to the locked token amount with no time decay\n     *      Note: time served prior to permanence is not preserved for penalty calculations  if the owner\n     *      later calls `earlyWithdraw`, the position is first unlocked and the penalty window resets to a\n     *      full MAXTIME from the current timestamp\n     *      Can only be called by the owner of the veNFT or an approved address\n     *      Cannot be called on a lock that is already permanent\n     * @param _tokenId The ID of the veNFT to permanently lock\n     */\n    function lockPermanent(uint256 _tokenId) external;\n\n    /**\n     * @notice Revert a veNFT from permanent lock status back to a standard time-lock\n     * @dev Converts a permanent lock back to a standard time-based lock\n     *      After unlocking, the veNFT's voting power will decay based on the remaining lock time\n     *      The lock time will be the original lock end time from before it was made permanent\n     *      If the original lock time has already passed, the lock will be immediately withdrawable\n     *      Can only be called by the owner or an approved operator\n     *      Only callable on veNFTs that are currently permanently locked\n     * @param _tokenId The ID of the veNFT to revert from permanent to standard lock\n     */\n    function unlockPermanent(uint256 _tokenId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                           VOTING POWER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the current voting power for a specific veNFT\n     * @dev Calculates voting power based on lock amount, remaining time, and permanent status\n     *      For standard locks: voting power = amount * (time_left / MAXTIME)\n     *      For permanent locks: voting power = amount (no time decay)\n     *      Returns 0 if called in the same block as a transfer due to checkpoint timing\n     *      This is the core function used for governance voting power determination\n     * @param _tokenId The ID of the veNFT to query voting power for\n     * @return The current voting power of the specified veNFT\n     */\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Get the historical voting power for a veNFT at a specific timestamp\n     * @dev Uses checkpoints to determine voting power at any point in the past\n     *      Crucial for governance systems that need to determine past voting power\n     *      For timestamps between checkpoints, calculates the interpolated value\n     *      Returns 0 for timestamps before the veNFT was created\n     * @param _tokenId The ID of the veNFT to query historical voting power for\n     * @param _t The timestamp at which to query the voting power\n     * @return The voting power of the specified veNFT at the requested timestamp\n     */\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    /**\n     * @notice Calculate the total voting power across all veNFTs at the current timestamp\n     * @dev Sums up all individual veNFT voting powers including both time-based and permanent locks\n     *      This represents the total governance voting power in the system right now\n     * @return The aggregate voting power of all veNFTs at the current timestamp\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Calculate the total historical voting power across all veNFTs at a specific timestamp\n     * @dev Uses global checkpoints to determine total voting power at any point in the past\n     *      Critical for governance votes that need to determine the total voting power at a past block\n     *      For timestamps between checkpoints, calculates the interpolated value\n     * @param _t The timestamp at which to query the total voting power\n     * @return The aggregate voting power of all veNFTs at the requested timestamp\n     */\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC6372\n    function clock() external view returns (uint48);\n\n    /// @inheritdoc IERC6372\n    function CLOCK_MODE() external view returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                          MIN LOCK AMOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the minimum amount of tokens required to create a veNFT lock\n     * @dev This value is used to validate lock creation and prevent spam attacks\n     * @return The minimum lock amount in token units (with 18 decimals)\n     */\n    function minLockAmount() external view returns (uint256);\n\n    /**\n     * @notice Sets the minimum amount of tokens required to create a veNFT lock\n     * @dev Can only be called by the team address. This helps prevent spam and ensures meaningful lock amounts\n     * @param newMinLockAmount The new minimum lock amount in token units (with 18 decimals)\n     */\n    function setMinLockAmount(uint256 newMinLockAmount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                      NOTIFY CONTRACTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the revenue reward contract\n     * @dev Returns address(0) if no revenue reward contract is set\n     * @return The revenue reward contract\n     */\n    function revenueReward() external view returns (IRevenueReward);\n\n    /**\n     * @notice Sets the revenue reward contract\n     * @dev Can only be called by the team address\n     * @param _revenueReward The new revenue reward contract\n     */\n    function setRevenueReward(IRevenueReward _revenueReward) external;\n}\n",
        "keccak256": "0x6b386b558166fbc71e1bf95bee2210f81afd960ab7129ac7503125c1ffb9bc5b",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IRevenueReward.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\n\nimport {IUserVaultFactory} from \"./IUserVaultFactory.sol\";\n\n/**\n * @title IRevenueReward Interface\n * @author Neverland\n * @notice Interface for the RevenueReward contract that manages token rewards distribution\n * @dev Handles reward epochs, claiming rewards, and self-repaying loan functionality\n */\ninterface IRevenueReward {\n    /// @notice Error thrown when a non-distributor address attempts to notify rewards\n    error NotRewardDistributor();\n\n    /// @notice Error thrown when a non-owner address attempts a restricted operation\n    error NotOwner();\n\n    /// @notice Error thrown when a non-DustLock address attempts a restricted operation\n    error NotDustLock();\n\n    /// @notice Error thrown when end timestamp used for calculating rewards is greater than the current time\n    error EndTimestampMoreThanCurrent();\n\n    /// @notice Error thrown when provided arrays are empty or exceed soft size limits\n    error InvalidArrayLengths();\n\n    /// @notice Error thrown when a provided reward token is not registered\n    error UnknownRewardToken();\n\n    /// @notice Error thrown when an array contains duplicate values or is not sorted in ascending order\n    error ArrayNotSortedOrContainsDuplicates();\n\n    /**\n     * @notice Emitted when rewards are claimed\n     * @param tokenId The veNFT id that produced the rewards\n     * @param user The address that received the rewards (owner or configured receiver)\n     * @param token Address of the reward token being claimed\n     * @param amount Amount of rewards claimed\n     */\n    event ClaimRewards(uint256 indexed tokenId, address indexed user, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when new rewards are notified to the contract\n     * @param from Address that notified the rewards (typically the reward distributor)\n     * @param token Address of the reward token being added\n     * @param epoch Reward epoch start timestamp (i.e., start of the week) the amount is credited to\n     * @param amount Amount of rewards added\n     */\n    event NotifyReward(address indexed from, address indexed token, uint256 epoch, uint256 amount);\n\n    /**\n     * @notice Emitted when tokens are recovered from the contract\n     * @param token Address of the token being recovered\n     * @param amount Amount of tokens recovered\n     */\n    event RecoverTokens(address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when self-repaying loan status is updated for a token\n     * @param token ID of the veNFT whose reward redirection is being configured\n     * @param rewardReceiver Address that will receive the rewards (or zero address if disabled)\n     * @param isEnabled Whether self-repaying loan is being enabled (true) or disabled (false)\n     */\n    event SelfRepayingLoanUpdate(uint256 indexed token, address rewardReceiver, bool isEnabled);\n\n    /**\n     * @notice Emitted when the reward distributor address is updated\n     * @param oldDistributor The previous reward distributor\n     * @param newDistributor The new reward distributor\n     */\n    event RewardDistributorUpdated(address indexed oldDistributor, address indexed newDistributor);\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice The address of the DustLock contract that manages veNFTs\n     * @return The IDustLock interface of the connected DustLock contract\n     */\n    function dustLock() external view returns (IDustLock);\n\n    /**\n     * @notice The address of the UserVaultFactory contract that manages user vaults\n     * @return The IUserVaultFactory interface of the connected UserVaultFactory contract\n     */\n    function userVaultFactory() external view returns (IUserVaultFactory);\n\n    /**\n     * @notice The duration of a reward epoch in seconds\n     * @dev This defines the time window for each reward distribution cycle\n     * @return Duration in seconds for each reward epoch\n     */\n    function DURATION() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of tokenIds allowed in a single batch claim.\n     * @return The maximum number of tokenIds accepted in batch calls\n     */\n    function MAX_TOKENIDS() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of reward tokens allowed in a single batch claim.\n     * @return The maximum number of reward tokens accepted in batch calls\n     */\n    function MAX_TOKENS() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                            STORAGE GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the timestamp of the last successfully processed reward claim for a token and veNFT\n     * @dev Used to calculate the amount of rewards earned since the last claim. Value is advanced to the\n     *      claim period end only when there were epochs to process; otherwise it remains unchanged.\n     * @param token The address of the reward token\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp (seconds) when rewards were last processed up to\n     */\n    function lastEarnTime(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the address authorized to add rewards to the contract\n     * @dev This address is the only one that can call notifyRewardAmount\n     *      Typically set to a protocol treasury or governance-controlled address\n     * @return The current reward distributor address\n     */\n    function rewardDistributor() external view returns (address);\n\n    /**\n     * @notice Checks if a token is registered as a valid reward token\n     * @dev Only registered reward tokens can be distributed through the contract\n     *      Tokens are registered automatically the first time they're used in notifyRewardAmount\n     * @param token The address of the token to check\n     * @return True if the token is registered as a reward token, false otherwise\n     */\n    function isRewardToken(address token) external view returns (bool);\n\n    /**\n     * @notice Returns the reward token at a specific index in the list of registered reward tokens\n     * @dev Used to enumerate all reward tokens available in the contract\n     *      Valid indices range from 0 to the number of registered reward tokens minus 1\n     * @param index The index in the reward tokens array\n     * @return The address of the reward token at the specified index\n     */\n    function rewardTokens(uint256 index) external view returns (address);\n\n    /**\n     * @notice Returns the accumulated sum of all reward distributions for a specific token\n     * @dev Used for internal reward accounting and distribution calculations\n     *      This value increases each time new rewards are notified\n     * @param token The address of the reward token\n     * @return The total amount of rewards ever distributed for this token\n     */\n    function totalRewardsPerToken(address token) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of rewards allocated for a specific token at a given epoch start\n     * @dev Rewards are tracked by epoch start timestamp (seconds), with each epoch lasting DURATION seconds.\n     * @param token The address of the reward token\n     * @param epoch The epoch start timestamp (i.e., start of the week)\n     * @return The amount of rewards allocated for the token at that epoch start\n     */\n    function tokenRewardsPerEpoch(address token, uint256 epoch) external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp when a veNFT was minted\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp when the veNFT was minted\n     */\n    function tokenMintTime(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the accumulated fractional remainder of rewards for a veNFT and token, scaled by 1e18.\n     * @dev During per-epoch reward calculations, integer division can leave a remainder that cannot be paid out.\n     *      This function exposes the running sum of those remainders for the given (token, tokenId) pair,\n     *      scaled by a factor of 1e18 to preserve precision (i.e., value is remainder * 1e18 / totalSupplyAt(epoch)).\n     *      This value is informational and not directly claimable; it helps off-chain analytics understand\n     *      the uncredited fractional rewards that have accumulated over time due to rounding.\n     * @param token The address of the reward token being tracked.\n     * @param tokenId The ID of the veNFT whose fractional remainder is queried.\n     * @return scaledRemainder The accumulated fractional rewards remainder, scaled by 1e18.\n     */\n    function tokenRewardsRemainingAccScaled(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the configured reward recipient address for a specific veNFT\n     * @dev When self-repaying loan functionality is enabled, rewards are sent to this address\n     *      Returns address(0) if no special recipient is configured (rewards go to veNFT owner)\n     * @param tokenId The ID of the veNFT to query\n     * @return The address that receives rewards for this veNFT, or address(0) if it's the owner\n     */\n    function tokenRewardReceiver(uint256 tokenId) external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the address authorized to add rewards to the contract\n     * @dev Can only be called by the current reward distributor\n     *      This is a critical permission that controls who can distribute rewards\n     * @param newRewardDistributor The address of the new reward distributor\n     */\n    function setRewardDistributor(address newRewardDistributor) external;\n\n    /**\n     * @notice Adds new rewards to the distribution pool for the next epoch\n     * @dev Can only be called by the authorized reward distributor address.\n     *      Automatically registers new tokens the first time they're used.\n     *      Rewards added during the current epoch become claimable starting the next epoch.\n     *      Emits a NotifyReward event with details about the distribution.\n     *      Reverts: NotRewardDistributor, zero address/amount checks enforced by implementation.\n     * @param token The address of the reward token to distribute\n     * @param amount The amount of rewards to add to the distribution pool\n     */\n    function notifyRewardAmount(address token, uint256 amount) external;\n\n    /**\n     * @notice Recovers unnotified balances of registered reward tokens\n     * @dev Can only be called by the reward distributor\n     *      For each registered reward token, if the contract's token balance exceeds the credited amount\n     *      tracked by totalRewardsPerToken[token], transfers the excess to the reward distributor and emits\n     *      a RecoverTokens event.\n     */\n    function recoverTokens() external;\n\n    /*//////////////////////////////////////////////////////////////\n                            NOTIFICATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Notifies the contract that a new token has been created\n     * @dev Intended to update internal state or trigger logic after a veNFT creation event\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the token (veNFT) that has been created\n     */\n    function notifyTokenMinted(uint256 tokenId) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is transferred\n     * @dev This function is called by the DustLock contract just after transferring a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being transferred\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was transferred\n     * @param from The address of the previous token owner (sender of the transfer)\n     */\n    function notifyAfterTokenTransferred(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is burned\n     * @dev This function is called by the DustLock contract just after burning a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being burned\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was burned\n     * @param from The address of the previous token owner\n     */\n    function notifyAfterTokenBurned(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles bookkeeping after two veNFTs are merged.\n     * @dev Callable only by the DustLock contract.\n     * @param fromToken The tokenId that was merged and is no longer active (source).\n     * @param toToken The tokenId that survives the merge and should receive consolidated accounting (destination).\n     * @param owner The tokens' owner.\n     */\n    function notifyAfterTokenMerged(uint256 fromToken, uint256 toToken, address owner) external;\n\n    /**\n     * @notice Handles bookkeeping after a veNFT is split into two new veNFTs.\n     * @dev Callable only by the DustLock contract.\n     *      - Initializes mint timestamps for the two new tokenIds.\n     *      - Proportionally splits the accumulated fractional rewards remainder (scaled by 1e18)\n     *        from `fromToken` between `tokenId1` and `tokenId2` using their provided amounts.\n     *      - Clears the remainder accumulator for `fromToken` and removes it from any self-repaying\n     *        loan tracking if applicable.\n     * @param fromToken The original tokenId that was split (source).\n     * @param tokenId1 The first resulting tokenId after the split.\n     * @param token1Amount The amount (voting power/shares) assigned to `tokenId1` in the split.\n     * @param tokenId2 The second resulting tokenId after the split.\n     * @param token2Amount The amount (voting power/shares) assigned to `tokenId2` in the split.\n     * @param owner The owner of the tokens involved in the split.\n     */\n    function notifyAfterTokenSplit(\n        uint256 fromToken,\n        uint256 tokenId1,\n        uint256 token1Amount,\n        uint256 tokenId2,\n        uint256 token2Amount,\n        address owner\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens\n     * @dev Calculates earned rewards for each specified token using epoch-based accounting and transfers them\n     *      to the appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured\n     *      via enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     */\n    function getReward(uint256 tokenId, address[] calldata tokens) external;\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp\n     * @dev Similar to getReward, but allows specifying a custom end timestamp for the reward calculation period.\n     *      Calculates earned rewards for each specified token using epoch-based accounting and transfers them to the\n     *      appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured via\n     *      enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to rewardPeriodEndTs to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, EndTimestampMoreThanCurrent, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     * @param rewardPeriodEndTs The end timestamp to calculate rewards up to (must not be in the future)\n     */\n    function getRewardUntilTs(uint256 tokenId, address[] calldata tokens, uint256 rewardPeriodEndTs) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays or unknown tokens.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     */\n    function getRewardBatch(uint256[] calldata tokenIds, address[] calldata tokens) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens up to a specific timestamp.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays, unknown tokens,\n     *      or if `rewardPeriodEndTs` is in the future.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     * @param rewardPeriodEndTs End timestamp for calculation (<= now).\n     */\n    function getRewardUntilTsBatch(uint256[] calldata tokenIds, address[] calldata tokens, uint256 rewardPeriodEndTs)\n        external;\n\n    /*//////////////////////////////////////////////////////////////\n                         SELF-REPAYING LOANS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Enables the self-repaying loan feature for a specific veNFT\n     * @dev Configures a custom reward receiver address (typically a loan contract).\n     *      This allows veNFT owners to use their rewards to automatically repay loans.\n     *      The getReward function must still be called to trigger the reward claim.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner, zero rewardReceiver.\n     * @param tokenId The ID of the veNFT to configure self-repaying loan for\n     */\n    function enableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Disables the self-repaying loan feature for a specific veNFT\n     * @dev Removes the custom reward receiver configuration, returning to default behavior.\n     *      After disabling, all future rewards will go directly to the veNFT owner.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner.\n     * @param tokenId The ID of the veNFT to restore default reward routing for\n     */\n    function disableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Batch enable self-repaying loan with a single receiver for many tokenIds.\n     * @dev Each tokenId must be owned by the caller. Reverts on zero rewardReceiver.\n     * @param tokenIds Array of veNFT ids to configure.\n     */\n    function enableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /**\n     * @notice Batch disable self-repaying loan for many tokenIds.\n     * @dev Each tokenId must be owned by the caller.\n     * @param tokenIds Array of veNFT ids to restore default reward routing.\n     */\n    function disableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Preview unclaimed rewards for a single reward token up to a specific timestamp.\n     * @dev Read-only mirror of claim math; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, UnknownRewardToken if not registered.\n     * @param token Reward token address to preview.\n     * @param tokenId veNFT id to preview for.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return amount Total rewards that would be claimable if claimed up to `endTs`.\n     */\n    function earnedRewards(address token, uint256 tokenId, uint256 endTs) external view returns (uint256 amount);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens at the current timestamp.\n     * @dev Convenience wrapper that uses block.timestamp internally. Returns a matrix of rewards per\n     *      tokenId (outer) per token (inner), and totals per token.\n     *      Reverts: InvalidArrayLengths on bad inputs, UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAll(address[] calldata tokens, uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens up to a specific timestamp.\n     * @dev Read-only; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, InvalidArrayLengths on bad inputs,\n     *      UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAllUntilTs(address[] calldata tokens, uint256[] calldata tokenIds, uint256 endTs)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Returns the number of registered reward tokens\n     * @return The count of reward tokens\n     */\n    function rewardTokensLength() external view returns (uint256);\n\n    /**\n     * @notice Returns the full list of registered reward tokens\n     * @return tokens An array containing all reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory tokens);\n\n    /**\n     * @notice Returns a list of user addresses with at least one active self-repaying loan within a given range.\n     * @dev Iterates over the internal set of users who have enabled self-repaying loans,\n     *      returning addresses from index `from` up to, but not including, index `to`.\n     *      If the specified range exceeds the number of users, the function adjusts accordingly.\n     * @param from The starting index (inclusive) in the user set.\n     * @param to The ending index (exclusive) in the user set.\n     * @return users An array of user addresses in the specified range who have self-repaying loans enabled.\n     */\n    function getUsersWithSelfRepayingLoan(uint256 from, uint256 to) external view returns (address[] memory);\n\n    /**\n     * @notice Returns the list of token IDs for which the given user has enabled a self-repaying loan.\n     * @dev Checks the user's internal set of token IDs with self-repaying loans and returns them as an array.\n     * @param user The address of the user to query.\n     * @return tokenIds An array of token IDs currently associated with self-repaying loans for the user.\n     */\n    function getUserTokensWithSelfRepayingLoan(address user) external view returns (uint256[] memory tokenIds);\n}\n",
        "keccak256": "0xb72598c4cb5b87b2421a6763d847267c173a884a1eeb283b3474a9a4e0066477",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IUserVaultFactory.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title IUserVaultFactory\n * @author Neverland\n * @notice Interface for the UserVaultFactory contract.\n *         Allows creation and retrieval of user-specific vaults.\n */\ninterface IUserVaultFactory {\n    /**\n     * @notice Emitted when a new user vault is created\n     * @param user The user for whom the vault was created\n     * @param vault The address of the created vault\n     */\n    event UserVaultCreated(address indexed user, address indexed vault);\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user. Creates a new vault if none exists\n     * @dev If the vault does not exist, a new BeaconProxy is deployed and initialized for the user\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getUserVault(address user) external view returns (address vault);\n\n    /*//////////////////////////////////////////////////////////////\n                               ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user if it exists\n     * @dev If the vault does not exist, returns address(0)\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getOrCreateUserVault(address user) external returns (address vault);\n}\n",
        "keccak256": "0x2c37e5bc81e701ab66b66aea87f6daedf1ec8adf2685d14a66afe77ea477735e",
        "license": "BUSL-1.1"
      },
      "src/libraries/BalanceLogicLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {ud60x18, convert} from \"@prb/math/src/UD60x18.sol\";\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\n\nimport {SafeCastLibrary} from \"./SafeCastLibrary.sol\";\n\n/**\n * @title BalanceLogicLibrary\n * @author Extended by Neverland\n * @notice Read-only helpers for historical voting power and supply calculations for veDUST\n */\nlibrary BalanceLogicLibrary {\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int128;\n\n    /// Constants\n    uint256 internal constant WEEK = 1 weeks;\n    uint256 internal constant MAX_USER_POINTS = 1_000_000_000;\n    uint256 internal constant MAX_CHECKPOINT_ITERATIONS = 255;\n\n    /**\n     * @notice Binary search to get the user point index for a token id at or prior to a given timestamp\n     * @dev If a user point does not exist prior to the timestamp, this will return 0.\n     * @param _userPointEpoch State of all user point epochs\n     * @param _userPointHistory State of all user point history\n     * @param _tokenId The ID of the veNFT to query\n     * @param _timestamp The timestamp to find the user point at or before\n     * @return User point index\n     */\n    function getPastUserPointIndex(\n        mapping(uint256 => uint256) storage _userPointEpoch,\n        mapping(uint256 => IDustLock.UserPoint[MAX_USER_POINTS]) storage _userPointHistory,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        uint256 _userEpoch = _userPointEpoch[_tokenId];\n        if (_userEpoch == 0) return 0;\n        // First check most recent balance\n        if (_userPointHistory[_tokenId][_userEpoch].ts <= _timestamp) return (_userEpoch);\n        // Next check implicit zero balance\n        if (_userPointHistory[_tokenId][1].ts > _timestamp) return 0;\n\n        uint256 lower = 0;\n        uint256 upper = _userEpoch;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IDustLock.UserPoint storage userPoint = _userPointHistory[_tokenId][center];\n            if (userPoint.ts == _timestamp) {\n                return center;\n            } else if (userPoint.ts < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    /**\n     * @notice Binary search to get the global point index at or prior to a given timestamp\n     * @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\n     * @param _epoch Current global point epoch\n     * @param _pointHistory State of all global point history\n     * @param _timestamp The timestamp to find the global point at or before\n     * @return Global point index\n     */\n    function getPastGlobalPointIndex(\n        uint256 _epoch,\n        mapping(uint256 => IDustLock.GlobalPoint) storage _pointHistory,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        if (_epoch == 0) return 0;\n        // First check most recent balance\n        if (_pointHistory[_epoch].ts <= _timestamp) return (_epoch);\n        // Next check implicit zero balance\n        if (_pointHistory[1].ts > _timestamp) return 0;\n\n        uint256 lower = 0;\n        uint256 upper = _epoch;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IDustLock.GlobalPoint storage globalPoint = _pointHistory[center];\n            if (globalPoint.ts == _timestamp) {\n                return center;\n            } else if (globalPoint.ts < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    /**\n     * @notice Get the current voting power for `_tokenId`\n     * @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n     *      Fetches last user point prior to a certain timestamp, then walks forward to timestamp.\n     * @param _userPointEpoch State of all user point epochs\n     * @param _userPointHistory State of all user point history\n     * @param _tokenId NFT for lock\n     * @param _t Epoch time to return voting power at\n     * @return User voting power\n     */\n    function balanceOfNFTAt(\n        mapping(uint256 => uint256) storage _userPointEpoch,\n        mapping(uint256 => IDustLock.UserPoint[MAX_USER_POINTS]) storage _userPointHistory,\n        uint256 _tokenId,\n        uint256 _t\n    ) external view returns (uint256) {\n        uint256 _epoch = getPastUserPointIndex(_userPointEpoch, _userPointHistory, _tokenId, _t);\n        // epoch 0 is an empty point\n        if (_epoch == 0) return 0;\n        IDustLock.UserPoint memory lastPoint = _userPointHistory[_tokenId][_epoch];\n        if (lastPoint.permanent != 0) {\n            return lastPoint.permanent;\n        } else {\n            // Time difference in seconds, slope is in WAD format\n            // slope * time_seconds gives WAD result\n            lastPoint.bias -= lastPoint.slope * int256(_t - lastPoint.ts);\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // Convert from WAD (18 decimals) back to token units\n            return convert(ud60x18(uint256(lastPoint.bias)));\n        }\n    }\n\n    /**\n     * @notice Calculate total voting power at some point in the past\n     * @param _slopeChanges State of all slopeChanges\n     * @param _pointHistory State of all global point history\n     * @param _epoch The epoch to start search from\n     * @param _t Time to calculate the total voting power at\n     * @return Total voting power at that time\n     */\n    function supplyAt(\n        mapping(uint256 => int256) storage _slopeChanges,\n        mapping(uint256 => IDustLock.GlobalPoint) storage _pointHistory,\n        uint256 _epoch,\n        uint256 _t\n    ) external view returns (uint256) {\n        uint256 epoch_ = getPastGlobalPointIndex(_epoch, _pointHistory, _t);\n        // epoch 0 is an empty point\n        if (epoch_ == 0) return 0;\n        IDustLock.GlobalPoint memory _point = _pointHistory[epoch_];\n        int256 bias = _point.bias;\n        int256 slope = _point.slope;\n        uint256 ts = _point.ts;\n        uint256 tCurr = (ts / WEEK) * WEEK;\n        for (uint256 i = 0; i < MAX_CHECKPOINT_ITERATIONS; ++i) {\n            tCurr += WEEK;\n            int256 dSlope = 0;\n            if (tCurr > _t) {\n                tCurr = _t;\n            } else {\n                dSlope = _slopeChanges[tCurr];\n            }\n            // Time difference in seconds, slope is in WAD format\n            bias -= slope * int256(tCurr - ts);\n            if (tCurr == _t) {\n                break;\n            }\n            slope += dSlope;\n            ts = tCurr;\n        }\n\n        if (bias < 0) {\n            bias = 0;\n        }\n        // Convert from WAD (18 decimals) back to token units\n        return convert(ud60x18(uint256(bias))) + _point.permanentLockBalance;\n    }\n}\n",
        "keccak256": "0xecb050ef8f16ff1f571c177b0d8a97f47d0ff48b2c6711e1e1632bbbf1310e0d",
        "license": "BUSL-1.1"
      },
      "src/libraries/CommonChecksLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonChecksLibrary\n * @author Neverland\n * @notice Shared require/revert helpers for zero/invalid values used across contracts\n */\nlibrary CommonChecksLibrary {\n    /// @notice Used when a zero address is provided where not allowed.\n    error AddressZero();\n    /// @notice Used when a zero amount is provided where not allowed.\n    error ZeroAmount();\n    /// @notice Used when a range is invalid.\n    error InvalidRange();\n    /// @notice Used when two addresses are the same but must differ.\n    error SameAddress();\n    /// @notice Used when a balance is zero.\n    error ZeroBalance();\n    /// @notice Used when a tokenId is invalid.\n    error InvalidTokenId();\n    /// @notice Used when a from address is invalid.\n    error InvalidFromAddress();\n    /// @notice Used when a to address is invalid.\n    error InvalidToAddress();\n    /// @notice Used when a user address is invalid.\n    error InvalidUserAddress();\n    /// @notice Used a function is called by an account that is not permitted.\n    error UnauthorizedAccess();\n\n    /**\n     * @notice Reverts if the provided address is zero\n     * @param addressToCheck The address to check\n     */\n    function revertIfZeroAddress(address addressToCheck) internal pure {\n        if (addressToCheck == address(0)) revert AddressZero();\n    }\n\n    /**\n     * @notice Reverts if the provided amount is zero\n     * @param amount The amount to check\n     */\n    function revertIfZeroAmount(uint256 amount) internal pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n\n    /**\n     * @notice Reverts if the [from, to] range is invalid (from > to)\n     * @param from The start of the range\n     * @param to The end of the range\n     */\n    function revertIfInvalidRange(uint256 from, uint256 to) internal pure {\n        if (from > to) revert InvalidRange();\n    }\n\n    /**\n     * @notice Reverts if the two addresses are the same\n     * @param first The first address to check\n     * @param second The second address to check\n     */\n    function revertIfSameAddress(address first, address second) internal pure {\n        if (first == second) revert SameAddress();\n    }\n\n    /**\n     * @notice Reverts if the balance is zero\n     * @param balance The balance to check\n     */\n    function revertIfZeroBalance(uint256 balance) internal pure {\n        if (balance == 0) revert ZeroBalance();\n    }\n\n    /**\n     * @notice Reverts if the tokenId owner is the zero address\n     * @param owner The owner of the tokenId\n     */\n    function revertIfInvalidTokenId(address owner) internal pure {\n        if (owner == address(0)) revert InvalidTokenId();\n    }\n\n    /**\n     * @notice Reverts if the from address is zero\n     * @param from The from address to check\n     */\n    function revertIfInvalidFromAddress(address from) internal pure {\n        if (from == address(0)) revert InvalidFromAddress();\n    }\n\n    /**\n     * @notice Reverts if the to address is zero\n     * @param to The to address to check\n     */\n    function revertIfInvalidToAddress(address to) internal pure {\n        if (to == address(0)) revert InvalidToAddress();\n    }\n\n    /**\n     * @notice Reverts if the user address is zero\n     * @param user The user address to check\n     */\n    function revertIfInvalidUserAddress(address user) internal pure {\n        if (user == address(0)) revert InvalidUserAddress();\n    }\n}\n",
        "keccak256": "0xa8e23a48af12c93a809845953069be6f296d8d2e93e7cd89e5250b15b5d9f805",
        "license": "BUSL-1.1"
      },
      "src/libraries/CommonLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonLibrary\n * @author Neverland\n * @notice Miscellaneous shared helpers used across the codebase\n */\nlibrary CommonLibrary {\n    /**\n     * @notice Returns true if `account` is a contract.\n     * @dev This uses extcodesize/code.length which returns 0 for contracts in construction.\n     * @param account The address to check.\n     * @return True if code length > 0.\n     */\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n}\n",
        "keccak256": "0x6676bc617b86a7084e9f6cb4d666feeba4c545bb181322ce970aa945e3f017b9",
        "license": "BUSL-1.1"
      },
      "src/libraries/SafeCastLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title SafeCast Library\n * @author velodrome.finance\n * @notice Safely convert unsigned and signed integers without overflow / underflow\n */\nlibrary SafeCastLibrary {\n    error SafeCastOverflow();\n    error SafeCastUnderflow();\n\n    /// @dev Safely convert uint256 to int128\n    function toInt128(uint256 value) internal pure returns (int128) {\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\n        return int128(uint128(value));\n    }\n\n    /// @dev Safely convert int128 to uint256\n    function toUint256(int128 value) internal pure returns (uint256) {\n        if (value < 0) revert SafeCastUnderflow();\n        return uint256(int256(value));\n    }\n\n    /// @dev Safely convert uint256 to int256\n    function toInt256(uint256 value) internal pure returns (int256) {\n        if (value > uint256(type(int256).max)) revert SafeCastOverflow();\n        return int256(value);\n    }\n\n    /// @dev Safely convert int256 to uint256\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) revert SafeCastUnderflow();\n        return uint256(value);\n    }\n}\n",
        "keccak256": "0xe07592a503223015644f868ed75c710db4b5f8d7ef36456f07e0b52f80205ffc",
        "license": "BUSL-1.1"
      },
      "src/tokens/DustLock.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {UD60x18, convert} from \"@prb/math/src/UD60x18.sol\";\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\nimport {IRevenueReward} from \"../interfaces/IRevenueReward.sol\";\n\nimport {BalanceLogicLibrary} from \"../libraries/BalanceLogicLibrary.sol\";\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {CommonLibrary} from \"../libraries/CommonLibrary.sol\";\n\n/**\n * @title DustLock\n * @notice Vote-escrow (veNFT) contract for DUST; tracks locks and voting power\n */\ncontract DustLock is IDustLock, Initializable, ERC2771ContextUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int256;\n    using Strings for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustLock\n    address public override forwarder;\n\n    /*//////////////////////////////////////////////////////////////\n                           STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustLock\n    address public override token;\n    /// @inheritdoc IDustLock\n    address public override team;\n    /// @notice Pending team address for two-step ownership transfer\n    address public pendingTeam;\n\n    mapping(uint256 => GlobalPoint) internal _pointHistory; // epoch -> unsigned global point\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n    /// @dev ERC165 interface ID of ERC4906\n    bytes4 internal constant ERC4906_INTERFACE_ID = 0x49064906;\n    /// @dev ERC165 interface ID of ERC6372\n    bytes4 internal constant ERC6372_INTERFACE_ID = 0xda287a1d;\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @inheritdoc IDustLock\n    uint256 public override tokenId;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _forwarder) ERC2771ContextUpgradeable(_forwarder) {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Initializer (for proxy deployments)\n     * @param _forwarder address of trusted forwarder\n     * @param _token `DUST` token address\n     * @param _baseURI base URI for NFT metadata\n     */\n    function initialize(address _forwarder, address _token, string memory _baseURI) external initializer {\n        CommonChecksLibrary.revertIfZeroAddress(_forwarder);\n        CommonChecksLibrary.revertIfZeroAddress(_token);\n\n        __ReentrancyGuard_init();\n\n        forwarder = _forwarder;\n        token = _token;\n        team = _msgSender();\n        baseURI = _baseURI;\n\n        earlyWithdrawTreasury = _msgSender();\n        earlyWithdrawPenalty = DEFAULT_EARLY_WITHDRAW_PENALTY_BP;\n        minLockAmount = 1e18;\n\n        _pointHistory[0].blk = block.number;\n        _pointHistory[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC4906_INTERFACE_ID] = true;\n        supportedInterfaces[ERC6372_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n        supportedInterfaces[type(IDustLock).interfaceId] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function proposeTeam(address _newTeam) external override {\n        if (_msgSender() != team) revert NotTeam();\n        CommonChecksLibrary.revertIfZeroAddress(_newTeam);\n        CommonChecksLibrary.revertIfSameAddress(_newTeam, team);\n\n        pendingTeam = _newTeam;\n\n        emit TeamProposed(team, _newTeam);\n    }\n\n    /// @inheritdoc IDustLock\n    function acceptTeam() external override {\n        if (_msgSender() != pendingTeam) revert NotPendingTeam();\n\n        address oldTeam = team;\n        team = pendingTeam;\n        pendingTeam = address(0);\n\n        emit TeamAccepted(oldTeam, team);\n    }\n\n    /// @inheritdoc IDustLock\n    function cancelTeamProposal() external override {\n        if (_msgSender() != team) revert NotTeam();\n        CommonChecksLibrary.revertIfZeroAddress(pendingTeam);\n\n        address cancelledTeam = pendingTeam;\n        pendingTeam = address(0);\n\n        emit TeamProposalCancelled(team, cancelledTeam);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Token name\n    string public constant name = \"Voting Escrow DUST\";\n    /// @notice Token symbol\n    string public constant symbol = \"veDUST\";\n    /// @notice Token version\n    string public constant version = \"2.0.0\";\n    /// @notice Base URI for token metadata\n    string internal baseURI;\n\n    /*///////////////////////////////////////////////////////////////\n                                ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        _ownerOfOrRevert(_tokenId);\n\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, _tokenId.toString()) : \"\";\n    }\n\n    /// @inheritdoc IDustLock\n    function setBaseURI(string calldata newBaseURI) external override {\n        if (_msgSender() != team) revert NotTeam();\n\n        string memory oldBaseURIMemory = baseURI;\n        string memory newBaseURIMemory = newBaseURI;\n        baseURI = newBaseURIMemory;\n\n        emit BaseURIUpdated(oldBaseURIMemory, newBaseURIMemory);\n        if (tokenId > 0) emit BatchMetadataUpdate(1, tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint256 => address) internal idToOwner;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint256) internal ownerToNFTokenCount;\n\n    /**\n     * @notice Returns the owner address of a token without reverting.\n     * @dev Returns address(0) if the token does not exist.\n     * @param _tokenId The veNFT id to query ownership for.\n     * @return The current owner address or address(0) if unminted.\n     */\n    function _ownerOf(uint256 _tokenId) internal view returns (address) {\n        address owner = idToOwner[_tokenId];\n        return owner;\n    }\n\n    /**\n     * @notice Returns the owner address of a token or reverts if it is not minted.\n     * @dev Uses CommonChecksLibrary to revert when owner is address(0).\n     * @param _tokenId The veNFT id to query.\n     * @return owner The current owner address.\n     */\n    function _ownerOfOrRevert(uint256 _tokenId) internal view returns (address owner) {\n        owner = _ownerOf(_tokenId);\n        CommonChecksLibrary.revertIfInvalidTokenId(owner);\n    }\n\n    /// @inheritdoc IDustLock\n    function ownerOf(uint256 _tokenId) external view override returns (address) {\n        return _ownerOfOrRevert(_tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function balanceOf(address _owner) external view override returns (uint256) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint256 => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    /// @dev Mapping from NFT ID to the block number of the last ownership change.\n    mapping(uint256 => uint256) internal ownershipChange;\n\n    /// @inheritdoc IDustLock\n    function getApproved(uint256 _tokenId) external view override returns (address) {\n        return idToApprovals[_tokenId];\n    }\n\n    /// @inheritdoc IDustLock\n    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /// @inheritdoc IDustLock\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view override returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /**\n     * @notice Checks whether `_spender` is allowed to manage `_tokenId`.\n     * @dev True if `_spender` is the owner, approved for the token, or approved for all.\n     * @param _spender The address to check permissions for.\n     * @param _tokenId The token id to check against.\n     * @return True if `_spender` is owner or approved.\n     */\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n        address owner = _ownerOf(_tokenId);\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustLock\n    function approve(address _approved, uint256 _tokenId) external override {\n        address sender = _msgSender();\n        address owner = _ownerOfOrRevert(_tokenId);\n        // Throws if `_approved` is the current owner\n        CommonChecksLibrary.revertIfSameAddress(owner, _approved);\n\n        // Check requirements\n        bool senderIsOwner = (_ownerOf(_tokenId) == sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[sender];\n        if (!senderIsOwner && !senderIsApprovedForAll) revert NotApprovedOrOwner();\n\n        // Set the approval\n        idToApprovals[_tokenId] = _approved;\n\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function setApprovalForAll(address _operator, bool _approved) external override {\n        address sender = _msgSender();\n        // Throws if `_operator` is the `msg.sender`\n        CommonChecksLibrary.revertIfSameAddress(_operator, sender);\n\n        ownerToOperators[sender][_operator] = _approved;\n\n        emit ApprovalForAll(sender, _operator, _approved);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           TRANSFER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Transfers `_tokenId` from `_from` to `_to` and performs bookkeeping.\n     * @dev Clears approvals, updates owner counts and index mappings, sets flash-vote block,\n     *      notifies external hooks, and emits the Transfer event. Reverts on invalid ownership\n     *      or insufficient approvals.\n     * @param _from Current owner of the token.\n     * @param _to Recipient address (must be non-zero).\n     * @param _tokenId The token id being transferred.\n     * @param _sender The original caller used for approval checks and receiver callbacks.\n     */\n    function _transferFrom(address _from, address _to, uint256 _tokenId, address _sender) internal {\n        CommonChecksLibrary.revertIfZeroAddress(_to);\n        // Check requirements\n        if (!_isApprovedOrOwner(_sender, _tokenId)) revert NotApprovedOrOwner();\n        // Clear approval. Throws if `_from` is not the current owner\n        if (_ownerOf(_tokenId) != _from) revert NotOwner();\n\n        delete idToApprovals[_tokenId];\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownershipChange[_tokenId] = block.number;\n        // notify other contracts\n        _notifyAfterTokenTransferred(_tokenId, _from, _to, _sender);\n\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function transferFrom(address _from, address _to, uint256 _tokenId) external override nonReentrant {\n        _transferFrom(_from, _to, _tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IDustLock\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override nonReentrant {\n        _safeTransferFrom(_from, _to, _tokenId, \"\", _msgSender());\n    }\n\n    /// @inheritdoc IDustLock\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data)\n        external\n        override\n        nonReentrant\n    {\n        bytes memory data = _data;\n        _safeTransferFrom(_from, _to, _tokenId, data, _msgSender());\n    }\n\n    /**\n     * @notice Safe transfer variant that invokes `onERC721Received` when `_to` is a contract.\n     * @dev Reverts if the target contract rejects the transfer.\n     * @param _from Current owner of the token.\n     * @param _to Recipient address.\n     * @param _tokenId The token id being transferred.\n     * @param _data Additional data forwarded to the receiver hook.\n     * @param sender Original caller used in receiver callback.\n     */\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data, address sender)\n        internal\n    {\n        _transferFrom(_from, _to, _tokenId, sender);\n\n        if (CommonLibrary.isContract(_to)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try IERC721Receiver(_to).onERC721Received(sender, _from, _tokenId, _data) returns (bytes4 response) {\n                if (response != IERC721Receiver(_to).onERC721Received.selector) {\n                    revert ERC721ReceiverRejectedTokens();\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustLock\n    function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustLock\n    mapping(address => mapping(uint256 => uint256)) public override ownerToNFTokenIdList;\n\n    /// @notice Mapping from NFT ID to index of owner\n    mapping(uint256 => uint256) internal tokenToOwnerIndex;\n\n    /**\n     * @notice Internal function to add a NFT to an index mapping to a given address\n     * @param _to address of the receiver\n     * @param _tokenId uint ID Of the token to be added\n     */\n    function _addTokenToOwnerList(address _to, uint256 _tokenId) internal {\n        uint256 currentCount = ownerToNFTokenCount[_to];\n\n        ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = currentCount;\n    }\n\n    /**\n     * @notice Internal function to add a NFT to a given address\n     * @param _to address of the receiver\n     * @param _tokenId uint ID Of the token to be added\n     */\n    function _addTokenTo(address _to, uint256 _tokenId) internal {\n        // Throws if `_tokenId` is owned by someone\n        if (_ownerOf(_tokenId) != address(0)) revert AlreadyOwned();\n\n        // Change the owner\n        idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        ++ownerToNFTokenCount[_to];\n    }\n\n    /**\n     * @notice Internal function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function _mint(address _to, uint256 _tokenId) internal returns (bool) {\n        // Throws if `_to` is zero address\n        CommonChecksLibrary.revertIfZeroAddress(_to);\n\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _addTokenTo(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /**\n     * @notice Internal function to remove a NFT from an index mapping to a given address\n     * @param _from address of the sender\n     * @param _tokenId uint ID Of the token to be removed\n     */\n    function _removeTokenFromOwnerList(address _from, uint256 _tokenId) internal {\n        // Delete\n        uint256 currentCount = ownerToNFTokenCount[_from] - 1;\n        uint256 currentIndex = tokenToOwnerIndex[_tokenId];\n\n        if (currentCount == currentIndex) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint256 lastTokenId = ownerToNFTokenIdList[_from][currentCount];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /**\n     * @notice Remove a NFT from a given address\n     * @param _from address of the sender\n     * @param _tokenId uint ID Of the token to be removed\n     */\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        if (_ownerOf(_tokenId) != _from) revert NotOwner();\n\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        --ownerToNFTokenCount[_from];\n    }\n\n    /**\n     * @notice Burns the veNFT token, removing ownership and permissions. Only callable by approved users or the owner of the token\n     * @dev Must be called prior to updating `LockedBalance`\n     * @param _tokenId The ID of the veNFT token to burn\n     */\n    function _burn(uint256 _tokenId) internal {\n        address sender = _msgSender();\n        if (!_isApprovedOrOwner(sender, _tokenId)) revert NotApprovedOrOwner();\n\n        address owner = _ownerOf(_tokenId);\n        // Clear approval\n        delete idToApprovals[_tokenId];\n        // Remove token\n        _removeTokenFrom(owner, _tokenId);\n\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// Constants\n    uint256 internal constant WEEK = 1 weeks;\n    uint256 internal constant MINTIME = 28 * 24 * 3600;\n    uint256 internal constant MAXTIME = 1 * 365 * 86400;\n    uint256 internal constant MULTIPLIER = 1 ether;\n    uint256 internal constant BASIS_POINTS = 10_000;\n    uint256 internal constant MAX_USER_POINTS = 1_000_000_000;\n    uint256 internal constant MAX_CHECKPOINT_ITERATIONS = 255;\n    uint256 internal constant DEFAULT_EARLY_WITHDRAW_PENALTY_BP = 5_000;\n\n    /// @inheritdoc IDustLock\n    uint256 public override epoch;\n    /// @inheritdoc IDustLock\n    uint256 public override supply;\n\n    /// @notice Mapping from veNFT id to locked balance\n    mapping(uint256 => LockedBalance) internal _locked;\n    /// @notice Mapping from veNFT id to user point history\n    mapping(uint256 => UserPoint[MAX_USER_POINTS]) internal _userPointHistory;\n    /// @notice Mapping from veNFT id to user point epoch\n    mapping(uint256 => uint256) public userPointEpoch;\n\n    /// @inheritdoc IDustLock\n    mapping(uint256 => int256) public override slopeChanges;\n    /// @inheritdoc IDustLock\n    mapping(address => bool) public override canSplit;\n    /// @inheritdoc IDustLock\n    uint256 public override permanentLockBalance;\n    /// @inheritdoc IDustLock\n    uint256 public override earlyWithdrawPenalty;\n    /// @inheritdoc IDustLock\n    address public override earlyWithdrawTreasury;\n\n    /// @inheritdoc IDustLock\n    function locked(uint256 _tokenId) external view override returns (LockedBalance memory) {\n        return _locked[_tokenId];\n    }\n\n    /// @inheritdoc IDustLock\n    function userPointHistory(uint256 _tokenId, uint256 _loc) external view override returns (UserPoint memory) {\n        return _userPointHistory[_tokenId][_loc];\n    }\n\n    /// @inheritdoc IDustLock\n    function pointHistory(uint256 _loc) external view override returns (GlobalPoint memory) {\n        return _pointHistory[_loc];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Record global and per-user voting power data to checkpoints\n     * @dev This critical function:\n     *      1. Updates user voting power points when their lock changes\n     *      2. Updates global voting power points\n     *      3. Updates slope changes for future epochs\n     *      4. Handles both normal and permanent locks\n     * @param _tokenId NFT token ID (0 means only update global checkpoints, no user checkpoint)\n     * @param _oldLocked Previous locked amount / end lock time / permanent status for the user\n     * @param _newLocked New locked amount / end lock time / permanent status for the user\n     */\n    function _checkpoint(uint256 _tokenId, LockedBalance memory _oldLocked, LockedBalance memory _newLocked) internal {\n        UserPoint memory uOld;\n        UserPoint memory uNew;\n        int256 oldDslope = 0;\n        int256 newDslope = 0;\n        uint256 _epoch = epoch;\n\n        if (_tokenId != 0) {\n            uNew.permanent = _newLocked.isPermanent ? _newLocked.amount.toUint256() : 0;\n            // Calculate slopes and biases using PRB Math v4\n            if (_oldLocked.end > block.timestamp && _oldLocked.amount > 0) {\n                uint256 amount = _oldLocked.amount.toUint256();\n                uint256 timeDiff = _oldLocked.end - block.timestamp;\n                uint256 maxTime = MAXTIME;\n\n                // Use PRB Math UD60x18 for 18 decimal precision\n                // Convert inputs to WAD\n                UD60x18 amountWAD = convert(amount);\n                UD60x18 timeDiffWAD = convert(timeDiff);\n                UD60x18 maxTimeWAD = convert(maxTime);\n\n                UD60x18 biasResult = amountWAD.mul(timeDiffWAD).div(maxTimeWAD);\n                uOld.bias = int256(biasResult.intoUint256());\n\n                // Calculate slope with 18 decimal precision: amount / maxTime\n                UD60x18 slopeResult = amountWAD.div(maxTimeWAD);\n                uOld.slope = int256(slopeResult.intoUint256());\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\n                uint256 amount = _newLocked.amount.toUint256();\n                uint256 timeDiff = _newLocked.end - block.timestamp;\n                uint256 maxTime = MAXTIME;\n\n                // Use PRB Math UD60x18 for 18 decimal precision\n                // Convert inputs to WAD\n                UD60x18 amountWAD = convert(amount);\n                UD60x18 timeDiffWAD = convert(timeDiff);\n                UD60x18 maxTimeWAD = convert(maxTime);\n\n                UD60x18 biasResult = amountWAD.mul(timeDiffWAD).div(maxTimeWAD);\n                uNew.bias = int256(biasResult.intoUint256());\n\n                // Calculate slope with 18 decimal precision: amount / maxTime\n                UD60x18 slopeResult = amountWAD.div(maxTimeWAD);\n                uNew.slope = int256(slopeResult.intoUint256());\n            }\n\n            // Read values of scheduled changes in the slope\n            // _oldLocked.end can be in the past and in the future\n            // _newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldDslope = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newDslope = oldDslope;\n                } else {\n                    newDslope = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        GlobalPoint memory lastPoint =\n            GlobalPoint({bias: 0, slope: 0, ts: block.timestamp, blk: block.number, permanentLockBalance: 0});\n        if (_epoch > 0) {\n            lastPoint = _pointHistory[_epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        GlobalPoint memory initialLastPoint = GlobalPoint({\n            bias: lastPoint.bias,\n            slope: lastPoint.slope,\n            ts: lastPoint.ts,\n            blk: lastPoint.blk,\n            permanentLockBalance: lastPoint.permanentLockBalance\n        });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint256 tCurr = (lastCheckpoint / WEEK) * WEEK;\n            for (uint256 i = 0; i < MAX_CHECKPOINT_ITERATIONS; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                tCurr += WEEK; // Initial value of tCurr is always larger than the ts of the last point\n                int256 dSlope = 0;\n                if (tCurr > block.timestamp) {\n                    tCurr = block.timestamp;\n                } else {\n                    dSlope = slopeChanges[tCurr];\n                }\n                // Time difference in seconds, slope is in WAD format\n                // slope * time_seconds gives WAD result\n                lastPoint.bias -= lastPoint.slope * int256(tCurr - lastCheckpoint);\n                lastPoint.slope += dSlope;\n                if (lastPoint.bias < 0) {\n                    // This can happen\n                    lastPoint.bias = 0;\n                }\n                if (lastPoint.slope < 0) {\n                    // This cannot happen - just in case\n                    lastPoint.slope = 0;\n                }\n                lastCheckpoint = tCurr;\n                lastPoint.ts = tCurr;\n                lastPoint.blk = initialLastPoint.blk + (blockSlope * (tCurr - initialLastPoint.ts)) / MULTIPLIER;\n                ++_epoch;\n                if (tCurr == block.timestamp) {\n                    lastPoint.blk = block.number;\n                    break;\n                } else {\n                    _pointHistory[_epoch] = lastPoint;\n                }\n            }\n        }\n\n        if (_tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope += (uNew.slope - uOld.slope);\n            lastPoint.bias += (uNew.bias - uOld.bias);\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            lastPoint.permanentLockBalance = permanentLockBalance;\n        }\n\n        // If timestamp of last global point is the same, overwrite the last global point\n        // Else record the new global point into history\n        // Exclude epoch 0 (note: _epoch is always >= 1, see above)\n        // Two possible outcomes:\n        // Missing global checkpoints in prior weeks. In this case, _epoch = epoch + x, where x > 1\n        // No missing global checkpoints, but timestamp != block.timestamp. Create new checkpoint.\n        // No missing global checkpoints, but timestamp == block.timestamp. Overwrite last checkpoint.\n        if (_epoch != 1 && _pointHistory[_epoch - 1].ts == block.timestamp) {\n            // _epoch = epoch + 1, so we do not increment epoch\n            _pointHistory[_epoch - 1] = lastPoint;\n        } else {\n            // more than one global point may have been written, so we update epoch\n            epoch = _epoch;\n            _pointHistory[_epoch] = lastPoint;\n        }\n\n        if (_tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [_newLocked.end]\n            // and add old_user_slope to [_oldLocked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldDslope was <something> - uOld.slope, so we cancel that\n                oldDslope += uOld.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldDslope -= uNew.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = oldDslope;\n            }\n\n            if (_newLocked.end > block.timestamp) {\n                // update slope if new lock is greater than old lock and is not permanent or if old lock is permanent\n                if ((_newLocked.end > _oldLocked.end)) {\n                    newDslope -= uNew.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = newDslope;\n                }\n                // else: we recorded it already in oldDslope\n            }\n            // If timestamp of last user point is the same, overwrite the last user point\n            // Else record the new user point into history\n            // Exclude epoch 0\n            uNew.ts = block.timestamp;\n            uNew.blk = block.number;\n            uint256 userEpoch = userPointEpoch[_tokenId];\n            if (userEpoch != 0 && _userPointHistory[_tokenId][userEpoch].ts == block.timestamp) {\n                _userPointHistory[_tokenId][userEpoch] = uNew;\n            } else {\n                userPointEpoch[_tokenId] = ++userEpoch;\n                _userPointHistory[_tokenId][userEpoch] = uNew;\n            }\n        }\n    }\n\n    /**\n     * @notice Deposit and lock tokens for an existing veNFT\n     * @dev Core internal function that handles all token deposits including:\n     *      1. Updating supply\n     *      2. Updating token lock parameters\n     *      3. Creating checkpoints for voting power\n     *      4. Transferring tokens from sender to contract\n     *      5. Emitting appropriate events\n     * @param _tokenId The ID of the veNFT that holds the lock\n     * @param _value Amount of tokens to deposit (can be 0 for lock extensions)\n     * @param _unlockTime New time when to unlock the tokens, or 0 if unchanged\n     * @param _oldLocked Previous locked amount, timestamp and permanent status\n     * @param _depositType The type of deposit (create, increase amount, extend time, etc.)\n     */\n    function _depositFor(\n        uint256 _tokenId,\n        uint256 _value,\n        uint256 _unlockTime,\n        LockedBalance memory _oldLocked,\n        DepositType _depositType\n    ) internal {\n        uint256 supplyBefore = supply;\n        supply = supplyBefore + _value;\n\n        // Set newLocked to _oldLocked without mangling memory\n        LockedBalance memory newLocked;\n        (newLocked.amount, newLocked.effectiveStart, newLocked.end, newLocked.isPermanent) =\n            (_oldLocked.amount, _oldLocked.effectiveStart, _oldLocked.end, _oldLocked.isPermanent);\n\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        newLocked.amount += _value.toInt256();\n        if (_unlockTime != 0) {\n            newLocked.end = _unlockTime;\n        }\n\n        // Set effective start time based on deposit type\n        if (_depositType == DepositType.CREATE_LOCK_TYPE) {\n            // Set effective start time to current block timestamp for new locks\n            newLocked.effectiveStart = block.timestamp;\n        } else if (\n            (_depositType == DepositType.INCREASE_LOCK_AMOUNT || _depositType == DepositType.DEPOSIT_FOR_TYPE)\n                && !_oldLocked.isPermanent && !newLocked.isPermanent\n        ) {\n            // Calculate weighted average start time for timed locks\n            newLocked.effectiveStart = _calculateWeightedStart(\n                _oldLocked.amount.toUint256(), _oldLocked.effectiveStart, _value, block.timestamp\n            );\n        }\n\n        _locked[_tokenId] = newLocked;\n\n        // Possibilities:\n        // Both _oldLocked.end could be current or expired (>/< block.timestamp)\n        // or if the lock is a permanent lock, then _oldLocked.end == 0\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // newLocked.end > block.timestamp (always)\n        _checkpoint(_tokenId, _oldLocked, newLocked);\n\n        address from = _msgSender();\n        if (_value != 0) {\n            IERC20(token).safeTransferFrom(from, address(this), _value);\n        }\n\n        emit Deposit(from, _tokenId, _depositType, _value, newLocked.end, block.timestamp);\n        emit Supply(supplyBefore, supply);\n\n        if (_value != 0 || _unlockTime != 0) emit MetadataUpdate(_tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function checkpoint() external override nonReentrant {\n        _checkpoint(0, LockedBalance(0, 0, 0, false), LockedBalance(0, 0, 0, false));\n    }\n\n    /// @inheritdoc IDustLock\n    function depositFor(uint256 _tokenId, uint256 _value) external override nonReentrant {\n        _increaseAmountFor(_tokenId, _value, DepositType.DEPOSIT_FOR_TYPE);\n    }\n\n    /**\n     * @notice Calculates weighted average start timestamp for two lock segments\n     * @dev Calculates the weighted start time of two locks based on their amounts.\n     * @param _amountA Amount of DUST in the first lock.\n     * @param _startA Effective start time of the first lock.\n     * @param _amountB Amount of DUST in the second lock.\n     * @param _startB Effective start time of the second lock.\n     * @return Weighted start time across the two segments\n     */\n    function _calculateWeightedStart(uint256 _amountA, uint256 _startA, uint256 _amountB, uint256 _startB)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 totalAmount = _amountA + _amountB;\n        uint256 numerator = _amountA * _startA + _amountB * _startB;\n        return numerator / totalAmount;\n    }\n\n    /**\n     * @notice This internal function is used by createLock and createLockFor to create a new veNFT\n     * @dev Creates a new lock position by depositing tokens for a specified address.\n     *      Copies `_locked[_tokenId]` (storage) to memory when passed to `_depositFor`. No storage mutation occurs.\n     * @param _value Amount of tokens to deposit\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to Address that will own the newly created veNFT\n     * @return The ID of the newly created veNFT\n     */\n    function _createLock(uint256 _value, uint256 _lockDuration, address _to) internal returns (uint256) {\n        CommonChecksLibrary.revertIfZeroAmount(_value);\n        if (_value < minLockAmount) revert AmountTooSmall();\n\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n        if (unlockTime <= block.timestamp) revert LockDurationNotInFuture();\n        if (unlockTime < block.timestamp + MINTIME) revert LockDurationTooShort();\n        if (unlockTime > block.timestamp + MAXTIME) revert LockDurationTooLong();\n\n        uint256 _tokenId = ++tokenId;\n        _mint(_to, _tokenId);\n        _notifyTokenMinted(_tokenId, _to, _msgSender());\n\n        _depositFor(_tokenId, _value, unlockTime, _locked[_tokenId], DepositType.CREATE_LOCK_TYPE);\n        return _tokenId;\n    }\n\n    /// @inheritdoc IDustLock\n    function createLock(uint256 _value, uint256 _lockDuration) external override nonReentrant returns (uint256) {\n        return _createLock(_value, _lockDuration, _msgSender());\n    }\n\n    /// @inheritdoc IDustLock\n    function createLockFor(uint256 _value, uint256 _lockDuration, address _to)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        return _createLock(_value, _lockDuration, _to);\n    }\n\n    /// @inheritdoc IDustLock\n    function createLockPermanent(uint256 _value, uint256 _lockDuration)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        address owner = _msgSender();\n        uint256 newTokenId = _createLock(_value, _lockDuration, owner);\n        _lockPermanent(owner, newTokenId);\n        return newTokenId;\n    }\n\n    /// @inheritdoc IDustLock\n    function createLockPermanentFor(uint256 _value, uint256 _lockDuration, address _to)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 newTokenId = _createLock(_value, _lockDuration, _to);\n        _lockPermanent(_to, newTokenId);\n        return newTokenId;\n    }\n\n    /**\n     * @notice Internal helper to increase the locked amount for a given veNFT\n     * @param _tokenId The veNFT id to increase the amount for\n     * @param _value The additional amount of DUST to add to the lock\n     * @param _depositType The deposit type (direct increase or depositFor)\n     */\n    function _increaseAmountFor(uint256 _tokenId, uint256 _value, DepositType _depositType) internal {\n        CommonChecksLibrary.revertIfZeroAmount(_value);\n        if (_value < minLockAmount) revert AmountTooSmall();\n\n        LockedBalance memory oldLocked = _locked[_tokenId];\n        if (oldLocked.amount <= 0) revert NoLockFound();\n        if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent) revert LockExpired();\n\n        // Prevent depositFor to locks expiring within MINTIME\n        if (\n            (_depositType == DepositType.DEPOSIT_FOR_TYPE || _depositType == DepositType.INCREASE_LOCK_AMOUNT)\n                && !oldLocked.isPermanent\n        ) {\n            if (oldLocked.end < block.timestamp + MINTIME) revert DepositForLockDurationTooShort();\n        }\n\n        if (oldLocked.isPermanent) permanentLockBalance += _value;\n        _depositFor(_tokenId, _value, 0, oldLocked, _depositType);\n\n        emit MetadataUpdate(_tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function increaseAmount(uint256 _tokenId, uint256 _value) external override nonReentrant {\n        if (!_isApprovedOrOwner(_msgSender(), _tokenId)) revert NotApprovedOrOwner();\n\n        _increaseAmountFor(_tokenId, _value, DepositType.INCREASE_LOCK_AMOUNT);\n    }\n\n    /// @inheritdoc IDustLock\n    function increaseUnlockTime(uint256 _tokenId, uint256 _lockDuration) external override nonReentrant {\n        if (!_isApprovedOrOwner(_msgSender(), _tokenId)) revert NotApprovedOrOwner();\n\n        LockedBalance memory oldLocked = _locked[_tokenId];\n        if (oldLocked.isPermanent) revert PermanentLock();\n        if (oldLocked.end <= block.timestamp) revert LockExpired();\n        if (oldLocked.amount <= 0) revert NoLockFound();\n\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n        if (unlockTime <= oldLocked.end) revert LockDurationNotInFuture();\n        if (unlockTime > block.timestamp + MAXTIME) revert LockDurationTooLong();\n\n        _depositFor(_tokenId, 0, unlockTime, oldLocked, DepositType.INCREASE_UNLOCK_TIME);\n\n        emit MetadataUpdate(_tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function withdraw(uint256 _tokenId) public override nonReentrant {\n        address sender = _msgSender();\n        if (!_isApprovedOrOwner(sender, _tokenId)) revert NotApprovedOrOwner();\n\n        LockedBalance memory oldLocked = _locked[_tokenId];\n        if (oldLocked.isPermanent) revert PermanentLock();\n        if (block.timestamp < oldLocked.end) revert LockNotExpired();\n\n        uint256 value = oldLocked.amount.toUint256();\n\n        // Burn the NFT\n        address owner = _ownerOf(_tokenId);\n        _burn(_tokenId);\n        _notifyAfterTokenBurned(_tokenId, owner, sender);\n\n        _locked[_tokenId] = LockedBalance(0, 0, 0, false);\n        uint256 supplyBefore = supply;\n        supply = supplyBefore - value;\n\n        // oldLocked can have either expired <= timestamp or zero end\n        // oldLocked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, oldLocked, LockedBalance(0, 0, 0, false));\n\n        IERC20(token).safeTransfer(owner, value);\n\n        emit Withdraw(owner, _tokenId, value, block.timestamp);\n        emit Supply(supplyBefore, supply);\n    }\n\n    /// @inheritdoc IDustLock\n    function earlyWithdraw(uint256 _tokenId) external override nonReentrant {\n        address sender = _msgSender();\n        if (!_isApprovedOrOwner(sender, _tokenId)) revert NotApprovedOrOwner();\n\n        LockedBalance memory oldLocked = _locked[_tokenId];\n        if (oldLocked.isPermanent) {\n            unlockPermanent(_tokenId);\n            oldLocked = _locked[_tokenId];\n        }\n\n        uint256 userLockedAmount = oldLocked.amount.toUint256();\n\n        // Burn the NFT\n        address owner = _ownerOf(_tokenId);\n        _burn(_tokenId);\n        _notifyAfterTokenBurned(_tokenId, owner, sender);\n\n        _locked[_tokenId] = LockedBalance(0, 0, 0, false);\n        uint256 supplyBefore = supply;\n        supply = supplyBefore - userLockedAmount;\n\n        // Calculate lock creation time and end time\n        uint256 effectiveStart = oldLocked.effectiveStart;\n        uint256 lockEndTime = oldLocked.end;\n\n        // Calculate penalty based on remaining time from effective start to end\n        // penaltyFactor = (lockEndTime - block.timestamp) / (lockEndTime - effectiveStart)\n        // userPenaltyAmount = earlyWithdrawPenalty * penaltyFactor * userLockedAmount / BASIS_POINTS\n        uint256 remainingTime = lockEndTime > block.timestamp ? lockEndTime - block.timestamp : 0;\n        uint256 totalLockTime = lockEndTime - effectiveStart;\n\n        uint256 userPenaltyAmount;\n        if (totalLockTime > 0 && remainingTime > 0) {\n            // penalty = amount * penalty * remainingTime / (BASIS_POINTS * totalLockTime)\n            userPenaltyAmount =\n                Math.mulDiv(userLockedAmount, earlyWithdrawPenalty * remainingTime, BASIS_POINTS * totalLockTime);\n        } else {\n            userPenaltyAmount = 0;\n        }\n\n        uint256 userTransferAmount = userLockedAmount - userPenaltyAmount;\n        uint256 treasuryTransferAmount = userPenaltyAmount;\n\n        // oldLocked can have either expired <= timestamp or zero end\n        // oldLocked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, oldLocked, LockedBalance(0, 0, 0, false));\n\n        IERC20(token).safeTransfer(owner, userTransferAmount);\n        IERC20(token).safeTransfer(earlyWithdrawTreasury, treasuryTransferAmount);\n\n        emit EarlyWithdraw(owner, _tokenId, userLockedAmount, userTransferAmount, block.timestamp);\n        emit Supply(supplyBefore, supply);\n    }\n\n    /// @inheritdoc IDustLock\n    function setEarlyWithdrawPenalty(uint256 _earlyWithdrawPenalty) external override nonReentrant {\n        if (_msgSender() != team) revert NotTeam();\n        if (_earlyWithdrawPenalty >= BASIS_POINTS) revert InvalidWithdrawPenalty();\n\n        uint256 old = earlyWithdrawPenalty;\n        earlyWithdrawPenalty = _earlyWithdrawPenalty;\n\n        emit EarlyWithdrawPenaltyUpdated(old, _earlyWithdrawPenalty);\n    }\n\n    /// @inheritdoc IDustLock\n    function setEarlyWithdrawTreasury(address _account) external override nonReentrant {\n        if (_msgSender() != team) revert NotTeam();\n        CommonChecksLibrary.revertIfZeroAddress(_account);\n\n        address old = earlyWithdrawTreasury;\n        earlyWithdrawTreasury = _account;\n\n        emit EarlyWithdrawTreasuryUpdated(old, _account);\n    }\n\n    /// @inheritdoc IDustLock\n    function merge(uint256 _from, uint256 _to) external override nonReentrant {\n        address sender = _msgSender();\n        if (_from == _to) revert SameNFT();\n        if (!_isApprovedOrOwner(sender, _from)) revert NotApprovedOrOwner();\n        if (!_isApprovedOrOwner(sender, _to)) revert NotApprovedOrOwner();\n\n        LockedBalance memory oldLockedTo = _locked[_to];\n        if (oldLockedTo.end <= block.timestamp && !oldLockedTo.isPermanent) revert LockExpired();\n\n        LockedBalance memory oldLockedFrom = _locked[_from];\n        if (oldLockedFrom.end <= block.timestamp && !oldLockedFrom.isPermanent) revert LockExpired();\n        if (oldLockedFrom.isPermanent && !oldLockedTo.isPermanent) revert PermanentLock();\n\n        uint256 end = oldLockedFrom.end >= oldLockedTo.end ? oldLockedFrom.end : oldLockedTo.end;\n\n        address owner = _ownerOf(_from);\n        _burn(_from);\n        _locked[_from] = LockedBalance(0, 0, 0, false);\n        _checkpoint(_from, oldLockedFrom, LockedBalance(0, 0, 0, false));\n\n        LockedBalance memory newLockedTo;\n        newLockedTo.amount = oldLockedTo.amount + oldLockedFrom.amount;\n\n        newLockedTo.isPermanent = oldLockedTo.isPermanent;\n        if (newLockedTo.isPermanent) {\n            if (!oldLockedFrom.isPermanent) permanentLockBalance += oldLockedFrom.amount.toUint256();\n        } else {\n            newLockedTo.end = end;\n            // Use weighted average to preserve time served from both locks for timed locks\n            newLockedTo.effectiveStart = _calculateWeightedStart(\n                oldLockedTo.amount.toUint256(),\n                oldLockedTo.effectiveStart,\n                oldLockedFrom.amount.toUint256(),\n                oldLockedFrom.effectiveStart\n            );\n        }\n        _checkpoint(_to, oldLockedTo, newLockedTo);\n        _locked[_to] = newLockedTo;\n\n        _notifyAfterTokenMerged(_from, _to, owner);\n\n        emit Merge(\n            sender,\n            _from,\n            _to,\n            oldLockedFrom.amount.toUint256(),\n            oldLockedTo.amount.toUint256(),\n            newLockedTo.amount.toUint256(),\n            newLockedTo.end,\n            block.timestamp\n        );\n        emit MetadataUpdate(_to);\n    }\n\n    /// @inheritdoc IDustLock\n    function split(uint256 _from, uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256 _tokenId1, uint256 _tokenId2)\n    {\n        CommonChecksLibrary.revertIfZeroAmount(_amount);\n        address owner = _ownerOfOrRevert(_from);\n        address sender = _msgSender();\n        if (!canSplit[owner] && !canSplit[address(0)]) revert SplitNotAllowed();\n        if (!_isApprovedOrOwner(sender, _from)) revert NotApprovedOrOwner();\n\n        LockedBalance memory newLocked = _locked[_from];\n        if (newLocked.end <= block.timestamp && !newLocked.isPermanent) revert LockExpired();\n        if (newLocked.isPermanent) revert PermanentLock();\n        if (_amount < minLockAmount) revert AmountTooSmall();\n\n        int256 splitAmount = _amount.toInt256();\n        if (newLocked.amount <= splitAmount) revert AmountTooBig();\n        if (uint256(newLocked.amount - splitAmount) < minLockAmount) revert AmountTooSmall();\n\n        // Zero out and burn old veNFT\n        _burn(_from);\n        _locked[_from] = LockedBalance(0, 0, 0, false);\n        _checkpoint(_from, newLocked, LockedBalance(0, 0, 0, false));\n\n        // Create new veNFT using old balance - amount\n        newLocked.amount -= splitAmount;\n        uint256 token1Amount = newLocked.amount.toUint256();\n        _tokenId1 = _createSplitNFT(owner, newLocked);\n\n        // Create new veNFT using amount\n        newLocked.amount = splitAmount;\n        _tokenId2 = _createSplitNFT(owner, newLocked);\n\n        _notifyAfterTokenSplit(_from, _tokenId1, token1Amount, _tokenId2, _amount, owner);\n\n        emit Split(\n            _from,\n            _tokenId1,\n            _tokenId2,\n            sender,\n            _locked[_tokenId1].amount.toUint256(),\n            splitAmount.toUint256(),\n            newLocked.end,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Helper function to create a new veNFT as part of the split operation\n     * @dev This function:\n     *      1. Increments the global tokenId counter to get a new ID\n     *      2. Sets the lock parameters for the new token\n     *      3. Creates a checkpoint for the new veNFT\n     *      4. Mints the new veNFT to the specified owner\n     * @param _to Address that will own the new veNFT\n     * @param _newLocked Lock parameters (amount, end time, permanent status) for the new veNFT\n     * @return _tokenId The ID of the newly created veNFT\n     */\n    function _createSplitNFT(address _to, LockedBalance memory _newLocked) private returns (uint256 _tokenId) {\n        _tokenId = ++tokenId;\n        _locked[_tokenId] = _newLocked;\n        _checkpoint(_tokenId, LockedBalance(0, 0, 0, false), _newLocked);\n        _mint(_to, _tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function toggleSplit(address _account, bool _bool) external override {\n        if (_msgSender() != team) revert NotTeam();\n\n        canSplit[_account] = _bool;\n\n        emit SplitPermissionUpdated(_account, _bool);\n    }\n\n    /// @inheritdoc IDustLock\n    function lockPermanent(uint256 _tokenId) external override {\n        _lockPermanent(_msgSender(), _tokenId);\n    }\n\n    /**\n     * @notice Converts a time-locked veNFT into a permanent lock\n     * @dev Core implementation to convert a time-locked veNFT into a permanent lock.\n     *      Centralizes checks, checkpointing and events for reuse by wrappers.\n     *      Copies `_locked[_tokenId]` (storage) to memory when passed to `_checkpoint`. No storage mutation occurs.\n     * @param caller Address used for approval/ownership checks (msg.sender).\n     * @param _tokenId The veNFT id to make permanent.\n     */\n    function _lockPermanent(address caller, uint256 _tokenId) internal {\n        if (!_isApprovedOrOwner(caller, _tokenId)) revert NotApprovedOrOwner();\n        LockedBalance memory _newLocked = _locked[_tokenId];\n        if (_newLocked.isPermanent) revert PermanentLock();\n        if (_newLocked.end <= block.timestamp) revert LockExpired();\n        if (_newLocked.amount <= 0) revert NoLockFound();\n\n        address owner = _ownerOf(_tokenId);\n        uint256 _amount = _newLocked.amount.toUint256();\n        permanentLockBalance += _amount;\n        _newLocked.end = 0;\n        _newLocked.isPermanent = true;\n        _checkpoint(_tokenId, _locked[_tokenId], _newLocked);\n        _locked[_tokenId] = _newLocked;\n\n        emit LockPermanent(owner, _tokenId, _amount, block.timestamp);\n        emit MetadataUpdate(_tokenId);\n    }\n\n    /// @inheritdoc IDustLock\n    function unlockPermanent(uint256 _tokenId) public override {\n        address sender = _msgSender();\n        if (!_isApprovedOrOwner(sender, _tokenId)) revert NotApprovedOrOwner();\n        LockedBalance memory _newLocked = _locked[_tokenId];\n        if (!_newLocked.isPermanent) revert NotPermanentLock();\n\n        address owner = _ownerOf(_tokenId);\n        uint256 _amount = _newLocked.amount.toUint256();\n        permanentLockBalance -= _amount;\n        _newLocked.effectiveStart = block.timestamp;\n        _newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _newLocked.isPermanent = false;\n        _checkpoint(_tokenId, _locked[_tokenId], _newLocked);\n        _locked[_tokenId] = _newLocked;\n\n        emit UnlockPermanent(owner, _tokenId, _amount, block.timestamp);\n        emit MetadataUpdate(_tokenId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Computes voting power for `_tokenId` at timestamp `_t`.\n     * @dev Delegates to BalanceLogicLibrary; wraps internal storage mappings.\n     * @param _tokenId The veNFT id to query.\n     * @param _t The timestamp to evaluate voting power at.\n     * @return The voting power in token units.\n     */\n    function _balanceOfNFTAt(uint256 _tokenId, uint256 _t) internal view returns (uint256) {\n        return BalanceLogicLibrary.balanceOfNFTAt(userPointEpoch, _userPointHistory, _tokenId, _t);\n    }\n\n    /**\n     * @notice Computes total voting power (supply) at a given timestamp.\n     * @dev Delegates to BalanceLogicLibrary; wraps internal storage mappings.\n     * @param _timestamp The timestamp to evaluate.\n     * @return Total voting power in token units.\n     */\n    function _supplyAt(uint256 _timestamp) internal view returns (uint256) {\n        return BalanceLogicLibrary.supplyAt(slopeChanges, _pointHistory, epoch, _timestamp);\n    }\n\n    /// @inheritdoc IDustLock\n    function balanceOfNFT(uint256 _tokenId) public view override returns (uint256) {\n        if (ownershipChange[_tokenId] == block.number) return 0;\n        return _balanceOfNFTAt(_tokenId, block.timestamp);\n    }\n\n    /// @inheritdoc IDustLock\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view override returns (uint256) {\n        return _balanceOfNFTAt(_tokenId, _t);\n    }\n\n    /// @inheritdoc IDustLock\n    function totalSupply() external view override returns (uint256) {\n        return _supplyAt(block.timestamp);\n    }\n\n    /// @inheritdoc IDustLock\n    function totalSupplyAt(uint256 _timestamp) external view override returns (uint256) {\n        return _supplyAt(_timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustLock\n    function clock() external view override returns (uint48) {\n        return uint48(block.timestamp);\n    }\n\n    /// @inheritdoc IDustLock\n    function CLOCK_MODE() external pure override returns (string memory) {\n        return \"mode=timestamp\";\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MIN LOCK AMOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Minimum amount of DUST required to create or increase a lock (18 decimals)\n    uint256 public override minLockAmount;\n\n    /// @inheritdoc IDustLock\n    function setMinLockAmount(uint256 newMinLockAmount) public override {\n        if (_msgSender() != team) revert NotTeam();\n        CommonChecksLibrary.revertIfZeroAmount(newMinLockAmount);\n\n        uint256 old = minLockAmount;\n        minLockAmount = newMinLockAmount;\n\n        emit MinLockAmountUpdated(old, newMinLockAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          NOTIFY CONTRACTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Revenue reward contract used for distributing external rewards (address(0) if unset)\n    IRevenueReward public override revenueReward;\n\n    /// @inheritdoc IDustLock\n    function setRevenueReward(IRevenueReward _revenueReward) public override {\n        if (_msgSender() != team) revert NotTeam();\n\n        IRevenueReward old = revenueReward;\n        address newReward = address(_revenueReward);\n        // Allow disabling by setting to zero address; otherwise require a contract\n        if (newReward != address(0) && !CommonLibrary.isContract(newReward)) revert InvalidRevenueRewardContract();\n\n        revenueReward = _revenueReward;\n\n        emit RevenueRewardUpdated(address(old), newReward);\n    }\n\n    /**\n     * @notice Internal hook to notify the reward system after a token transfer.\n     * @dev No-op if `revenueReward` is unset.\n     * @param _tokenId The transferred token id.\n     * @param _previousOwner The address that previously owned the token.\n     */\n    function _notifyAfterTokenTransferred(\n        uint256 _tokenId,\n        address _previousOwner,\n        address, /* _to */\n        address /* _sender */\n    )\n        internal\n    {\n        if (address(revenueReward) != address(0)) {\n            revenueReward.notifyAfterTokenTransferred(_tokenId, _previousOwner);\n        }\n    }\n\n    /**\n     * @notice Internal hook to notify the reward system after a token burn.\n     * @dev No-op if `revenueReward` is unset.\n     * @param _tokenId The burned token id.\n     * @param _previousOwner The address that previously owned the token.\n     */\n    function _notifyAfterTokenBurned(\n        uint256 _tokenId,\n        address _previousOwner,\n        address /* _sender */\n    )\n        internal\n    {\n        if (address(revenueReward) != address(0)) {\n            revenueReward.notifyAfterTokenBurned(_tokenId, _previousOwner);\n        }\n    }\n\n    /**\n     * @notice Internal hook to notify the reward system after a token mint.\n     * @dev No-op if `revenueReward` is unset.\n     * @param _tokenId The newly minted token id.\n     */\n    function _notifyTokenMinted(\n        uint256 _tokenId,\n        address,\n        /* _owner */\n        address /* _sender */\n    )\n        internal\n    {\n        if (address(revenueReward) != address(0)) {\n            revenueReward.notifyTokenMinted(_tokenId);\n        }\n    }\n\n    /**\n     * @notice Internal hook to notify the reward system after a token merge.\n     * @dev No-op if `revenueReward` is unset.\n     * @param _fromToken The source token id that was burned.\n     * @param _toToken The destination token id that persists.\n     * @param owner The owner involved in the merge.\n     */\n    function _notifyAfterTokenMerged(uint256 _fromToken, uint256 _toToken, address owner) internal {\n        if (address(revenueReward) != address(0)) {\n            revenueReward.notifyAfterTokenMerged(_fromToken, _toToken, owner);\n        }\n    }\n\n    /**\n     * @notice Internal hook to notify the reward system after a token split.\n     * @dev No-op if `revenueReward` is unset.\n     * @param fromToken The original token id that was split.\n     * @param tokenId1 The first resulting token id.\n     * @param token1Amount Amount allocated to `tokenId1`.\n     * @param tokenId2 The second resulting token id.\n     * @param token2Amount Amount allocated to `tokenId2`.\n     * @param owner The owner involved in the split.\n     */\n    function _notifyAfterTokenSplit(\n        uint256 fromToken,\n        uint256 tokenId1,\n        uint256 token1Amount,\n        uint256 tokenId2,\n        uint256 token2Amount,\n        address owner\n    ) internal {\n        if (address(revenueReward) != address(0)) {\n            revenueReward.notifyAfterTokenSplit(fromToken, tokenId1, token1Amount, tokenId2, token2Amount, owner);\n        }\n    }\n\n    // Storage gap for upgradeable safety\n    uint256[50] private __gap;\n}\n",
        "keccak256": "0xe693fd1abf9b85e6d890ba61be0829334d7fa61dd64b83c4309291377ad10376",
        "license": "BUSL-1.1"
      }
    },
    "version": 1
  },
  "proxy": "0xBB4738D05AD1b3Da57a4881baE62Ce9bb1eEeD6C",
  "implementation": "0x3875cdF0d2B4445B763B7FCAC5d28Db2ad6D30e7",
  "proxyAdmin": "0x6400650cED1eD7179143D40b4431c3cC8c068D90"
}