{
  "networkName": "monadMainnet",
  "chainId": 143,
  "contract": "RevenueReward",
  "metadata": {
    "compiler": {
      "version": "0.8.30+commit.73712a01"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_forwarder",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "name": "AddressZero",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ArrayNotSortedOrContainsDuplicates",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "EndTimestampMoreThanCurrent",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidArrayLengths",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidRange",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotDustLock",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotOwner",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotRewardDistributor",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "UnknownRewardToken",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ZeroAmount",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "ClaimRewards",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            }
          ],
          "name": "Initialized",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "epoch",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "NotifyReward",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "RecoverTokens",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "oldDistributor",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newDistributor",
              "type": "address"
            }
          ],
          "name": "RewardDistributorUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "token",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "rewardReceiver",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bool",
              "name": "isEnabled",
              "type": "bool"
            }
          ],
          "name": "SelfRepayingLoanUpdate",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "DURATION",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MAX_TOKENIDS",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MAX_TOKENS",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "disableSelfRepayLoan",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            }
          ],
          "name": "disableSelfRepayLoanBatch",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "dustLock",
          "outputs": [
            {
              "internalType": "contract IDustLock",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTs",
              "type": "uint256"
            }
          ],
          "name": "earnedRewards",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "tokens",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            }
          ],
          "name": "earnedRewardsAll",
          "outputs": [
            {
              "internalType": "uint256[][]",
              "name": "matrix",
              "type": "uint256[][]"
            },
            {
              "internalType": "uint256[]",
              "name": "totals",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "tokens",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "endTs",
              "type": "uint256"
            }
          ],
          "name": "earnedRewardsAllUntilTs",
          "outputs": [
            {
              "internalType": "uint256[][]",
              "name": "matrix",
              "type": "uint256[][]"
            },
            {
              "internalType": "uint256[]",
              "name": "totals",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "enableSelfRepayLoan",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            }
          ],
          "name": "enableSelfRepayLoanBatch",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "tokens",
              "type": "address[]"
            }
          ],
          "name": "getReward",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            },
            {
              "internalType": "address[]",
              "name": "tokens",
              "type": "address[]"
            }
          ],
          "name": "getRewardBatch",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getRewardTokens",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "tokens",
              "type": "address[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "tokens",
              "type": "address[]"
            },
            {
              "internalType": "uint256",
              "name": "rewardPeriodEndTs",
              "type": "uint256"
            }
          ],
          "name": "getRewardUntilTs",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            },
            {
              "internalType": "address[]",
              "name": "tokens",
              "type": "address[]"
            },
            {
              "internalType": "uint256",
              "name": "rewardPeriodEndTs",
              "type": "uint256"
            }
          ],
          "name": "getRewardUntilTsBatch",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getUserTokensWithSelfRepayingLoan",
          "outputs": [
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "to",
              "type": "uint256"
            }
          ],
          "name": "getUsersWithSelfRepayingLoan",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "",
              "type": "address[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_forwarder",
              "type": "address"
            },
            {
              "internalType": "contract IDustLock",
              "name": "_dustLock",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_rewardDistributor",
              "type": "address"
            },
            {
              "internalType": "contract IUserVaultFactory",
              "name": "_userVaultFactory",
              "type": "address"
            }
          ],
          "name": "initialize",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "name": "isRewardToken",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "forwarder",
              "type": "address"
            }
          ],
          "name": "isTrustedForwarder",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "lastEarnTime",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            }
          ],
          "name": "notifyAfterTokenBurned",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "fromToken",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "toToken",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            }
          ],
          "name": "notifyAfterTokenMerged",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "fromToken",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1Amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId2",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token2Amount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            }
          ],
          "name": "notifyAfterTokenSplit",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            }
          ],
          "name": "notifyAfterTokenTransferred",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "notifyRewardAmount",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "notifyTokenMinted",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "recoverTokens",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "rewardDistributor",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "rewardTokens",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "rewardTokensLength",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "newRewardDistributor",
              "type": "address"
            }
          ],
          "name": "setRewardDistributor",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "tokenMintTime",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "tokenRewardReceiver",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "tokenRewardsPerEpoch",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "name": "tokenRewardsRemainingAccScaled",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "name": "totalRewardsPerToken",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "userVaultFactory",
          "outputs": [
            {
              "internalType": "contract IUserVaultFactory",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "devdoc": {
        "author": "Neverland",
        "events": {
          "ClaimRewards(uint256,address,address,uint256)": {
            "params": {
              "amount": "Amount of rewards claimed",
              "token": "Address of the reward token being claimed",
              "tokenId": "The veNFT id that produced the rewards",
              "user": "The address that received the rewards (owner or configured receiver)"
            }
          },
          "Initialized(uint8)": {
            "details": "Triggered when the contract has been initialized or reinitialized."
          },
          "NotifyReward(address,address,uint256,uint256)": {
            "params": {
              "amount": "Amount of rewards added",
              "epoch": "Reward epoch start timestamp (i.e., start of the week) the amount is credited to",
              "from": "Address that notified the rewards (typically the reward distributor)",
              "token": "Address of the reward token being added"
            }
          },
          "RecoverTokens(address,uint256)": {
            "params": {
              "amount": "Amount of tokens recovered",
              "token": "Address of the token being recovered"
            }
          },
          "RewardDistributorUpdated(address,address)": {
            "params": {
              "newDistributor": "The new reward distributor",
              "oldDistributor": "The previous reward distributor"
            }
          },
          "SelfRepayingLoanUpdate(uint256,address,bool)": {
            "params": {
              "isEnabled": "Whether self-repaying loan is being enabled (true) or disabled (false)",
              "rewardReceiver": "Address that will receive the rewards (or zero address if disabled)",
              "token": "ID of the veNFT whose reward redirection is being configured"
            }
          }
        },
        "kind": "dev",
        "methods": {
          "constructor": {
            "custom:oz-upgrades-unsafe-allow": "constructor"
          },
          "disableSelfRepayLoan(uint256)": {
            "details": "Removes the custom reward receiver configuration, returning to default behavior.      After disabling, all future rewards will go directly to the veNFT owner.      Access: callable only by the veNFT owner.      Reverts: NotOwner.",
            "params": {
              "tokenId": "The ID of the veNFT to restore default reward routing for"
            }
          },
          "disableSelfRepayLoanBatch(uint256[])": {
            "details": "Each tokenId must be owned by the caller.",
            "params": {
              "tokenIds": "Array of veNFT ids to restore default reward routing."
            }
          },
          "earnedRewards(address,uint256,uint256)": {
            "details": "Read-only mirror of claim math; does not mutate state, does not advance checkpoints.      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, UnknownRewardToken if not registered.",
            "params": {
              "endTs": "Timestamp (<= now) up to which to compute rewards.",
              "token": "Reward token address to preview.",
              "tokenId": "veNFT id to preview for."
            },
            "returns": {
              "_0": "Total rewards that would be claimable if claimed up to `endTs`."
            }
          },
          "earnedRewardsAll(address[],uint256[])": {
            "details": "Convenience wrapper that uses block.timestamp internally. Returns a matrix of rewards per      tokenId (outer) per token (inner), and totals per token.      Reverts: InvalidArrayLengths on bad inputs, UnknownRewardToken if a token is not registered.",
            "params": {
              "tokenIds": "Array of veNFT ids.",
              "tokens": "Array of reward token addresses."
            },
            "returns": {
              "matrix": "Rewards matrix with shape [tokenIds.length][tokens.length].",
              "totals": "Totals per token across all tokenIds with shape [tokens.length]."
            }
          },
          "earnedRewardsAllUntilTs(address[],uint256[],uint256)": {
            "details": "Read-only; does not mutate state, does not advance checkpoints.      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, InvalidArrayLengths on bad inputs,      UnknownRewardToken if a token is not registered.",
            "params": {
              "endTs": "Timestamp (<= now) up to which to compute rewards.",
              "tokenIds": "Array of veNFT ids.",
              "tokens": "Array of reward token addresses."
            },
            "returns": {
              "matrix": "Rewards matrix with shape [tokenIds.length][tokens.length].",
              "totals": "Totals per token across all tokenIds with shape [tokens.length]."
            }
          },
          "enableSelfRepayLoan(uint256)": {
            "details": "Configures a custom reward receiver address (typically a loan contract).      This allows veNFT owners to use their rewards to automatically repay loans.      The getReward function must still be called to trigger the reward claim.      Access: callable only by the veNFT owner.      Reverts: NotOwner, zero rewardReceiver.",
            "params": {
              "tokenId": "The ID of the veNFT to configure self-repaying loan for"
            }
          },
          "enableSelfRepayLoanBatch(uint256[])": {
            "details": "Each tokenId must be owned by the caller. Reverts on zero rewardReceiver.",
            "params": {
              "tokenIds": "Array of veNFT ids to configure."
            }
          },
          "getReward(uint256,address[])": {
            "details": "Calculates earned rewards for each specified token using epoch-based accounting and transfers them      to the appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured      via enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.      Updates lastEarnTime to track future accruals (only if there were epochs to process).      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.      Reverts: NotOwner, UnknownRewardToken, InvalidArrayLengths.",
            "params": {
              "tokenId": "The ID of the veNFT to claim rewards for",
              "tokens": "Array of reward token addresses to claim (must be registered reward tokens)"
            }
          },
          "getRewardBatch(uint256[],address[])": {
            "details": "Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays or unknown tokens.",
            "params": {
              "tokenIds": "Array of veNFT ids to claim for.",
              "tokens": "Array of reward token addresses to claim."
            }
          },
          "getRewardTokens()": {
            "returns": {
              "tokens": "An array containing all reward token addresses"
            }
          },
          "getRewardUntilTs(uint256,address[],uint256)": {
            "details": "Similar to getReward, but allows specifying a custom end timestamp for the reward calculation period.      Calculates earned rewards for each specified token using epoch-based accounting and transfers them to the      appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured via      enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.      Updates lastEarnTime to rewardPeriodEndTs to track future accruals (only if there were epochs to process).      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.      Reverts: NotOwner, EndTimestampMoreThanCurrent, UnknownRewardToken, InvalidArrayLengths.",
            "params": {
              "rewardPeriodEndTs": "The end timestamp to calculate rewards up to (must not be in the future)",
              "tokenId": "The ID of the veNFT to claim rewards for",
              "tokens": "Array of reward token addresses to claim (must be registered reward tokens)"
            }
          },
          "getRewardUntilTsBatch(uint256[],address[],uint256)": {
            "details": "Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays, unknown tokens,      or if `rewardPeriodEndTs` is in the future.",
            "params": {
              "rewardPeriodEndTs": "End timestamp for calculation (<= now).",
              "tokenIds": "Array of veNFT ids to claim for.",
              "tokens": "Array of reward token addresses to claim."
            }
          },
          "getUserTokensWithSelfRepayingLoan(address)": {
            "details": "Checks the user's internal set of token IDs with self-repaying loans and returns them as an array.",
            "params": {
              "user": "The address of the user to query."
            },
            "returns": {
              "tokenIds": "An array of token IDs currently associated with self-repaying loans for the user."
            }
          },
          "getUsersWithSelfRepayingLoan(uint256,uint256)": {
            "details": "Iterates over the internal set of users who have enabled self-repaying loans,      returning addresses from index `from` up to, but not including, index `to`.      If the specified range exceeds the number of users, the function adjusts accordingly.",
            "params": {
              "from": "The starting index (inclusive) in the user set.",
              "to": "The ending index (exclusive) in the user set."
            },
            "returns": {
              "_0": "users An array of user addresses in the specified range who have self-repaying loans enabled."
            }
          },
          "initialize(address,address,address,address)": {
            "params": {
              "_dustLock": "address of DustLock contract",
              "_forwarder": "address of trusted forwarder",
              "_rewardDistributor": "address of DustRewardsController contract",
              "_userVaultFactory": "address of UserVaultFactory contract"
            }
          },
          "notifyAfterTokenBurned(uint256,address)": {
            "details": "This function is called by the DustLock contract just after burning a token      It performs two main actions:      1. Claims all pending rewards for the token being burned      2. Removes the token from the self-repaying loan tracking if enabled      Can only be called by the DustLock contract.",
            "params": {
              "from": "The address of the previous token owner",
              "tokenId": "The ID of the veNFT token that was burned"
            }
          },
          "notifyAfterTokenMerged(uint256,uint256,address)": {
            "details": "Callable only by the DustLock contract.",
            "params": {
              "fromToken": "The tokenId that was merged and is no longer active (source).",
              "owner": "The tokens' owner.",
              "toToken": "The tokenId that survives the merge and should receive consolidated accounting (destination)."
            }
          },
          "notifyAfterTokenSplit(uint256,uint256,uint256,uint256,uint256,address)": {
            "details": "Callable only by the DustLock contract.      - Initializes mint timestamps for the two new tokenIds.      - Proportionally splits the accumulated fractional rewards remainder (scaled by 1e18)        from `fromToken` between `tokenId1` and `tokenId2` using their provided amounts.      - Clears the remainder accumulator for `fromToken` and removes it from any self-repaying        loan tracking if applicable.",
            "params": {
              "fromToken": "The original tokenId that was split (source).",
              "owner": "The owner of the tokens involved in the split.",
              "token1Amount": "The amount (voting power/shares) assigned to `tokenId1` in the split.",
              "token2Amount": "The amount (voting power/shares) assigned to `tokenId2` in the split.",
              "tokenId1": "The first resulting tokenId after the split.",
              "tokenId2": "The second resulting tokenId after the split."
            }
          },
          "notifyAfterTokenTransferred(uint256,address)": {
            "details": "This function is called by the DustLock contract just after transferring a token      It performs two main actions:      1. Claims all pending rewards for the token being transferred      2. Removes the token from the self-repaying loan tracking if enabled      Can only be called by the DustLock contract.",
            "params": {
              "from": "The address of the previous token owner (sender of the transfer)",
              "tokenId": "The ID of the veNFT token that was transferred"
            }
          },
          "notifyRewardAmount(address,uint256)": {
            "details": "Can only be called by the authorized reward distributor address.      Automatically registers new tokens the first time they're used.      Rewards added during the current epoch become claimable starting the next epoch.      Emits a NotifyReward event with details about the distribution.      Reverts: NotRewardDistributor, zero address/amount checks enforced by implementation.",
            "params": {
              "amount": "The amount of rewards to add to the distribution pool",
              "token": "The address of the reward token to distribute"
            }
          },
          "notifyTokenMinted(uint256)": {
            "details": "Intended to update internal state or trigger logic after a veNFT creation event      Can only be called by the DustLock contract.",
            "params": {
              "tokenId": "The ID of the token (veNFT) that has been created"
            }
          },
          "recoverTokens()": {
            "details": "Can only be called by the reward distributor      For each registered reward token, if the contract's token balance exceeds the credited amount      tracked by totalRewardsPerToken[token], transfers the excess to the reward distributor and emits      a RecoverTokens event."
          },
          "rewardTokensLength()": {
            "returns": {
              "_0": "The count of reward tokens"
            }
          },
          "setRewardDistributor(address)": {
            "details": "Can only be called by the current reward distributor      This is a critical permission that controls who can distribute rewards",
            "params": {
              "newRewardDistributor": "The address of the new reward distributor"
            }
          }
        },
        "stateVariables": {
          "DURATION": {
            "details": "This defines the time window for each reward distribution cycle",
            "return": "Duration in seconds for each reward epoch",
            "returns": {
              "_0": "Duration in seconds for each reward epoch"
            }
          },
          "MAX_TOKENIDS": {
            "return": "The maximum number of tokenIds accepted in batch calls",
            "returns": {
              "_0": "The maximum number of tokenIds accepted in batch calls"
            }
          },
          "MAX_TOKENS": {
            "return": "The maximum number of reward tokens accepted in batch calls",
            "returns": {
              "_0": "The maximum number of reward tokens accepted in batch calls"
            }
          },
          "dustLock": {
            "return": "The IDustLock interface of the connected DustLock contract",
            "returns": {
              "_0": "The IDustLock interface of the connected DustLock contract"
            }
          },
          "isRewardToken": {
            "details": "Only registered reward tokens can be distributed through the contract      Tokens are registered automatically the first time they're used in notifyRewardAmount",
            "params": {
              "token": "The address of the token to check"
            },
            "return": "True if the token is registered as a reward token, false otherwise",
            "returns": {
              "_0": "True if the token is registered as a reward token, false otherwise"
            }
          },
          "lastEarnTime": {
            "details": "Used to calculate the amount of rewards earned since the last claim. Value is advanced to the      claim period end only when there were epochs to process; otherwise it remains unchanged.",
            "params": {
              "token": "The address of the reward token",
              "tokenId": "The ID of the veNFT"
            },
            "return": "The timestamp (seconds) when rewards were last processed up to",
            "returns": {
              "_0": "The timestamp (seconds) when rewards were last processed up to"
            }
          },
          "rewardDistributor": {
            "details": "This address is the only one that can call notifyRewardAmount      Typically set to a protocol treasury or governance-controlled address",
            "return": "The current reward distributor address",
            "returns": {
              "_0": "The current reward distributor address"
            }
          },
          "rewardTokens": {
            "details": "Used to enumerate all reward tokens available in the contract      Valid indices range from 0 to the number of registered reward tokens minus 1",
            "params": {
              "index": "The index in the reward tokens array"
            },
            "return": "The address of the reward token at the specified index",
            "returns": {
              "_0": "The address of the reward token at the specified index"
            }
          },
          "tokenMintTime": {
            "params": {
              "tokenId": "The ID of the veNFT"
            },
            "return": "The timestamp when the veNFT was minted",
            "returns": {
              "_0": "The timestamp when the veNFT was minted"
            }
          },
          "tokenRewardReceiver": {
            "details": "When self-repaying loan functionality is enabled, rewards are sent to this address      Returns address(0) if no special recipient is configured (rewards go to veNFT owner)",
            "params": {
              "tokenId": "The ID of the veNFT to query"
            },
            "return": "The address that receives rewards for this veNFT, or address(0) if it's the owner",
            "returns": {
              "_0": "The address that receives rewards for this veNFT, or address(0) if it's the owner"
            }
          },
          "tokenRewardsPerEpoch": {
            "details": "Rewards are tracked by epoch start timestamp (seconds), with each epoch lasting DURATION seconds.",
            "params": {
              "epoch": "The epoch start timestamp (i.e., start of the week)",
              "token": "The address of the reward token"
            },
            "return": "The amount of rewards allocated for the token at that epoch start",
            "returns": {
              "_0": "The amount of rewards allocated for the token at that epoch start"
            }
          },
          "tokenRewardsRemainingAccScaled": {
            "details": "During per-epoch reward calculations, integer division can leave a remainder that cannot be paid out.      This function exposes the running sum of those remainders for the given (token, tokenId) pair,      scaled by a factor of 1e18 to preserve precision (i.e., value is remainder * 1e18 / totalSupplyAt(epoch)).      This value is informational and not directly claimable; it helps off-chain analytics understand      the uncredited fractional rewards that have accumulated over time due to rounding.",
            "params": {
              "token": "The address of the reward token being tracked.",
              "tokenId": "The ID of the veNFT whose fractional remainder is queried."
            },
            "return": "scaledRemainder The accumulated fractional rewards remainder, scaled by 1e18.",
            "returns": {
              "_0": "scaledRemainder The accumulated fractional rewards remainder, scaled by 1e18."
            }
          },
          "totalRewardsPerToken": {
            "details": "Used for internal reward accounting and distribution calculations      This value increases each time new rewards are notified",
            "params": {
              "token": "The address of the reward token"
            },
            "return": "The total amount of rewards ever distributed for this token",
            "returns": {
              "_0": "The total amount of rewards ever distributed for this token"
            }
          },
          "userTokensWithSelfRepayingLoan": {
            "details": "Mapping of user addresses to their veNFT tokens with self-repaying loan enabled"
          },
          "userVaultFactory": {
            "return": "The IUserVaultFactory interface of the connected UserVaultFactory contract",
            "returns": {
              "_0": "The IUserVaultFactory interface of the connected UserVaultFactory contract"
            }
          },
          "usersWithSelfRepayingLoan": {
            "details": "Set of user addresses with self-repaying loan enabled"
          }
        },
        "title": "RevenueReward",
        "version": 1
      },
      "userdoc": {
        "errors": {
          "AddressZero()": [
            {
              "notice": "Used when a zero address is provided where not allowed."
            }
          ],
          "ArrayNotSortedOrContainsDuplicates()": [
            {
              "notice": "Error thrown when an array contains duplicate values or is not sorted in ascending order"
            }
          ],
          "EndTimestampMoreThanCurrent()": [
            {
              "notice": "Error thrown when end timestamp used for calculating rewards is greater than the current time"
            }
          ],
          "InvalidArrayLengths()": [
            {
              "notice": "Error thrown when provided arrays are empty or exceed soft size limits"
            }
          ],
          "InvalidRange()": [
            {
              "notice": "Used when a range is invalid."
            }
          ],
          "NotDustLock()": [
            {
              "notice": "Error thrown when a non-DustLock address attempts a restricted operation"
            }
          ],
          "NotOwner()": [
            {
              "notice": "Error thrown when a non-owner address attempts a restricted operation"
            }
          ],
          "NotRewardDistributor()": [
            {
              "notice": "Error thrown when a non-distributor address attempts to notify rewards"
            }
          ],
          "UnknownRewardToken()": [
            {
              "notice": "Error thrown when a provided reward token is not registered"
            }
          ],
          "ZeroAmount()": [
            {
              "notice": "Used when a zero amount is provided where not allowed."
            }
          ]
        },
        "events": {
          "ClaimRewards(uint256,address,address,uint256)": {
            "notice": "Emitted when rewards are claimed"
          },
          "NotifyReward(address,address,uint256,uint256)": {
            "notice": "Emitted when new rewards are notified to the contract"
          },
          "RecoverTokens(address,uint256)": {
            "notice": "Emitted when tokens are recovered from the contract"
          },
          "RewardDistributorUpdated(address,address)": {
            "notice": "Emitted when the reward distributor address is updated"
          },
          "SelfRepayingLoanUpdate(uint256,address,bool)": {
            "notice": "Emitted when self-repaying loan status is updated for a token"
          }
        },
        "kind": "user",
        "methods": {
          "DURATION()": {
            "notice": "The duration of a reward epoch in seconds"
          },
          "MAX_TOKENIDS()": {
            "notice": "Maximum number of tokenIds allowed in a single batch claim."
          },
          "MAX_TOKENS()": {
            "notice": "Maximum number of reward tokens allowed in a single batch claim."
          },
          "disableSelfRepayLoan(uint256)": {
            "notice": "Disables the self-repaying loan feature for a specific veNFT"
          },
          "disableSelfRepayLoanBatch(uint256[])": {
            "notice": "Batch disable self-repaying loan for many tokenIds."
          },
          "dustLock()": {
            "notice": "The address of the DustLock contract that manages veNFTs"
          },
          "earnedRewards(address,uint256,uint256)": {
            "notice": "Preview unclaimed rewards for a single reward token up to a specific timestamp."
          },
          "earnedRewardsAll(address[],uint256[])": {
            "notice": "Preview unclaimed rewards for multiple tokenIds and multiple tokens at the current timestamp."
          },
          "earnedRewardsAllUntilTs(address[],uint256[],uint256)": {
            "notice": "Preview unclaimed rewards for multiple tokenIds and multiple tokens up to a specific timestamp."
          },
          "enableSelfRepayLoan(uint256)": {
            "notice": "Enables the self-repaying loan feature for a specific veNFT"
          },
          "enableSelfRepayLoanBatch(uint256[])": {
            "notice": "Batch enable self-repaying loan with a single receiver for many tokenIds."
          },
          "getReward(uint256,address[])": {
            "notice": "Claims accumulated rewards for a specific veNFT across multiple reward tokens"
          },
          "getRewardBatch(uint256[],address[])": {
            "notice": "Batch claim rewards for many tokenIds across a set of tokens."
          },
          "getRewardTokens()": {
            "notice": "Returns the full list of registered reward tokens"
          },
          "getRewardUntilTs(uint256,address[],uint256)": {
            "notice": "Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp"
          },
          "getRewardUntilTsBatch(uint256[],address[],uint256)": {
            "notice": "Batch claim rewards for many tokenIds across a set of tokens up to a specific timestamp."
          },
          "getUserTokensWithSelfRepayingLoan(address)": {
            "notice": "Returns the list of token IDs for which the given user has enabled a self-repaying loan."
          },
          "getUsersWithSelfRepayingLoan(uint256,uint256)": {
            "notice": "Returns a list of user addresses with at least one active self-repaying loan within a given range."
          },
          "initialize(address,address,address,address)": {
            "notice": "Initializes the contract"
          },
          "isRewardToken(address)": {
            "notice": "Checks if a token is registered as a valid reward token"
          },
          "lastEarnTime(address,uint256)": {
            "notice": "Returns the timestamp of the last successfully processed reward claim for a token and veNFT"
          },
          "notifyAfterTokenBurned(uint256,address)": {
            "notice": "Handles necessary operations after a veNFT token is burned"
          },
          "notifyAfterTokenMerged(uint256,uint256,address)": {
            "notice": "Handles bookkeeping after two veNFTs are merged."
          },
          "notifyAfterTokenSplit(uint256,uint256,uint256,uint256,uint256,address)": {
            "notice": "Handles bookkeeping after a veNFT is split into two new veNFTs."
          },
          "notifyAfterTokenTransferred(uint256,address)": {
            "notice": "Handles necessary operations after a veNFT token is transferred"
          },
          "notifyRewardAmount(address,uint256)": {
            "notice": "Adds new rewards to the distribution pool for the next epoch"
          },
          "notifyTokenMinted(uint256)": {
            "notice": "Notifies the contract that a new token has been created"
          },
          "recoverTokens()": {
            "notice": "Recovers unnotified balances of registered reward tokens"
          },
          "rewardDistributor()": {
            "notice": "Returns the address authorized to add rewards to the contract"
          },
          "rewardTokens(uint256)": {
            "notice": "Returns the reward token at a specific index in the list of registered reward tokens"
          },
          "rewardTokensLength()": {
            "notice": "Returns the number of registered reward tokens"
          },
          "setRewardDistributor(address)": {
            "notice": "Updates the address authorized to add rewards to the contract"
          },
          "tokenMintTime(uint256)": {
            "notice": "Returns the timestamp when a veNFT was minted"
          },
          "tokenRewardReceiver(uint256)": {
            "notice": "Returns the configured reward recipient address for a specific veNFT"
          },
          "tokenRewardsPerEpoch(address,uint256)": {
            "notice": "Returns the amount of rewards allocated for a specific token at a given epoch start"
          },
          "tokenRewardsRemainingAccScaled(address,uint256)": {
            "notice": "Returns the accumulated fractional remainder of rewards for a veNFT and token, scaled by 1e18."
          },
          "totalRewardsPerToken(address)": {
            "notice": "Returns the accumulated sum of all reward distributions for a specific token"
          },
          "userVaultFactory()": {
            "notice": "The address of the UserVaultFactory contract that manages user vaults"
          }
        },
        "notice": "Stores ERC20 token rewards and provides them to veDUST owners",
        "version": 1
      }
    },
    "settings": {
      "compilationTarget": {
        "src/rewards/RevenueReward.sol": "RevenueReward"
      },
      "evmVersion": "paris",
      "libraries": {},
      "metadata": {
        "bytecodeHash": "none",
        "useLiteralContent": true
      },
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "remappings": []
    },
    "sources": {
      "@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n",
        "keccak256": "0x7dbc63091d0a5033ac3d9de8aa0c0445895c8992b56db5db6d781725a2d9f414",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n",
        "keccak256": "0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n",
        "keccak256": "0x2025ccf05f6f1f2fd4e078e552836f525a1864e3854ed555047cd732320ab29b",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "keccak256": "0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n",
        "keccak256": "0x75097e35253e7fb282ee4d7f27a80eaacfa759923185bf17302a89cbc059c5ef",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n",
        "keccak256": "0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC4906.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n",
        "keccak256": "0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC6372.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n",
        "keccak256": "0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n",
        "keccak256": "0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n",
        "keccak256": "0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
        "keccak256": "0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n",
        "keccak256": "0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n",
        "keccak256": "0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
        "keccak256": "0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "keccak256": "0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
        "keccak256": "0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n",
        "keccak256": "0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n",
        "keccak256": "0x9f4357008a8f7d8c8bf5d48902e789637538d8c016be5766610901b4bba81514",
        "license": "MIT"
      },
      "src/interfaces/IDustLock.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {IRevenueReward} from \"./IRevenueReward.sol\";\n\n/**\n * @title IDustLock Interface\n * @notice Interface for the DustLock contract that manages voting escrow NFTs (veNFTs)\n * @dev Combines ERC721 with vote-escrow functionality for governance and reward distribution\n */\ninterface IDustLock is IERC4906, IERC6372, IERC721Metadata {\n    /**\n     * @notice Structure representing a locked token position\n     * @dev Used to track the amount of tokens locked, when they unlock, and if they're permanently locked\n     * @param amount Amount of tokens locked in int256 format for consistency with precision calculations\n     * @param effectiveStart Effective start time for penalty calculations (weighted average on lock operations)\n     * @param end Timestamp when tokens unlock (0 for permanent locks)\n     * @param isPermanent Whether this is a permanent lock that cannot be withdrawn normally\n     */\n    struct LockedBalance {\n        int256 amount;\n        uint256 effectiveStart;\n        uint256 end;\n        bool isPermanent;\n    }\n\n    /**\n     * @notice Checkpoint for tracking user voting power at a specific point in time\n     * @dev Used in the vote-escrow system to track decay of voting power over time\n     * @param bias Voting power at time ts\n     * @param slope Rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanent Amount of permanent (non-decaying) voting power\n     */\n    struct UserPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanent;\n    }\n\n    /**\n     * @notice Global checkpoint for tracking total voting power at a specific point in time\n     * @dev Similar to UserPoint but tracks system-wide totals\n     * @param bias Total voting power at time ts\n     * @param slope Total rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanentLockBalance Total amount of permanently locked tokens\n     */\n    struct GlobalPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanentLockBalance;\n    }\n\n    /**\n     * @notice Types of deposit operations supported by the veNFT system\n     * @param DEPOSIT_FOR_TYPE Adding tokens to an existing lock owned by someone else\n     * @param CREATE_LOCK_TYPE Creating a new lock position\n     * @param INCREASE_LOCK_AMOUNT Adding more tokens to an existing lock\n     * @param INCREASE_UNLOCK_TIME Extending the lock duration of an existing lock\n     */\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /// @notice Error thrown when the locked amount is less than minLockAmount\n    error AmountTooSmall();\n\n    /// @notice Error thrown when the requested amount exceeds available balance\n    error AmountTooBig();\n\n    /// @notice Error thrown when an ERC721 receiver contract rejects the tokens\n    error ERC721ReceiverRejectedTokens();\n\n    /// @notice Error thrown when transferring to an address that doesn't implement ERC721Receiver\n    error ERC721TransferToNonERC721ReceiverImplementer();\n\n    /// @notice Error thrown when an early withdraw penalty value is invalid (>=10000)\n    error InvalidWithdrawPenalty();\n\n    /// @notice Error thrown when the lock duration doesn't extend beyond the current time\n    error LockDurationNotInFuture();\n\n    /// @notice Error thrown when the lock duration exceeds the maximum allowed time\n    error LockDurationTooLong();\n\n    /// @notice Error thrown when the lock duration is less than the minimum required time\n    error LockDurationTooShort();\n\n    /// @notice Error thrown when trying to depositFor to a lock expiring within MINTIME\n    error DepositForLockDurationTooShort();\n\n    /// @notice Error thrown when trying to perform an operation on an expired lock\n    error LockExpired();\n\n    /// @notice Error thrown when trying to withdraw from a lock that hasn't expired yet\n    error LockNotExpired();\n\n    /// @notice Error thrown when no lock is found for the specified token ID\n    error NoLockFound();\n\n    /// @notice Error thrown when the caller is neither the owner nor approved for the token\n    error NotApprovedOrOwner();\n\n    /// @notice Error thrown when trying to unlock a non-permanent lock using unlockPermanent\n    error NotPermanentLock();\n\n    /// @notice Error thrown when the caller is not the owner of the token\n    error NotOwner();\n\n    /// @notice Error thrown when a team-only function is called by a non-team address\n    error NotTeam();\n\n    /// @notice Error thrown when a pending team function is called by a non-pending team address\n    error NotPendingTeam();\n\n    /// @notice Error thrown when trying to withdraw or modify a permanent lock\n    error PermanentLock();\n\n    /// @notice Error thrown when attempting to merge a veNFT with itself\n    error SameNFT();\n\n    /// @notice Error thrown when splitting is not allowed for the user\n    error SplitNotAllowed();\n\n    /// @notice Error thrown when trying to add a token that already has an owner\n    error AlreadyOwned();\n\n    /// @notice Error thrown when setting a revenue reward contract that is not a deployed contract\n    error InvalidRevenueRewardContract();\n\n    /**\n     * @notice Emitted when tokens are deposited into the veNFT system\n     * @param provider Address depositing the tokens\n     * @param tokenId ID of the veNFT being created or modified\n     * @param depositType Type of deposit operation (create, increase amount, etc.)\n     * @param value Amount of tokens deposited\n     * @param locktime Timestamp when the lock expires\n     * @param ts Timestamp when the deposit occurred\n     */\n    event Deposit(\n        address indexed provider,\n        uint256 indexed tokenId,\n        DepositType indexed depositType,\n        uint256 value,\n        uint256 locktime,\n        uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn before the lock expiry with a penalty\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Original locked amount\n     * @param amountReturned Amount returned to the user after penalty\n     * @param ts Timestamp when the early withdrawal occurred\n     */\n    event EarlyWithdraw(\n        address indexed provider, uint256 indexed tokenId, uint256 value, uint256 amountReturned, uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn after the lock expiry\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Amount of tokens withdrawn\n     * @param ts Timestamp when the withdrawal occurred\n     */\n    event Withdraw(address indexed provider, uint256 indexed tokenId, uint256 value, uint256 ts);\n\n    /**\n     * @notice Emitted when a lock is converted to a permanent lock\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being locked permanently\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was created\n     */\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when a permanent lock is unlocked by governance\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being unlocked\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was unlocked\n     */\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when the total supply of locked tokens changes\n     * @param prevSupply Previous total locked supply\n     * @param supply New total locked supply\n     */\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    /**\n     * @notice Emitted when two veNFTs are merged\n     * @param _sender Address initiating the merge\n     * @param _from Source veNFT ID (burned in the process)\n     * @param _to Destination veNFT ID (receives combined balance)\n     * @param _amountFrom Amount of tokens in the source veNFT\n     * @param _amountTo Amount of tokens in the destination veNFT before merge\n     * @param _amountFinal Final amount of tokens in the destination veNFT after merge\n     * @param _locktime New lock expiry time for the merged veNFT\n     * @param _ts Timestamp when the merge occurred\n     */\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a veNFT is split into two separate veNFTs\n     * @param _from Original veNFT ID being split (burned in the process)\n     * @param _tokenId1 First new veNFT ID created from the split\n     * @param _tokenId2 Second new veNFT ID created from the split\n     * @param _sender Address initiating the split\n     * @param _splitAmount1 Amount of tokens allocated to the first veNFT\n     * @param _splitAmount2 Amount of tokens allocated to the second veNFT\n     * @param _locktime Lock expiry time for both new veNFTs\n     * @param _ts Timestamp when the split occurred\n     */\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a new team address is proposed\n     * @param currentTeam The current team address that proposed the change\n     * @param proposedTeam The newly proposed team address\n     */\n    event TeamProposed(address indexed currentTeam, address indexed proposedTeam);\n\n    /**\n     * @notice Emitted when a proposed team address accepts ownership\n     * @param oldTeam The previous team address\n     * @param newTeam The new team address that accepted ownership\n     */\n    event TeamAccepted(address indexed oldTeam, address indexed newTeam);\n\n    /**\n     * @notice Emitted when a team proposal is cancelled\n     * @param currentTeam The current team address that cancelled the proposal\n     * @param cancelledTeam The proposed team address that was cancelled\n     */\n    event TeamProposalCancelled(address indexed currentTeam, address indexed cancelledTeam);\n\n    /**\n     * @notice Emitted when the early withdraw penalty is updated\n     * @param oldPenalty Previous penalty in basis points\n     * @param newPenalty New penalty in basis points\n     */\n    event EarlyWithdrawPenaltyUpdated(uint256 oldPenalty, uint256 newPenalty);\n\n    /**\n     * @notice Emitted when the early withdraw treasury address is updated\n     * @param oldTreasury Previous treasury address\n     * @param newTreasury New treasury address\n     */\n    event EarlyWithdrawTreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Emitted when the minimum lock amount is updated\n     * @param oldAmount Previous minimum lock amount\n     * @param newAmount New minimum lock amount\n     */\n    event MinLockAmountUpdated(uint256 oldAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted when the revenue reward contract is updated\n     * @param oldReward Previous revenue reward contract address\n     * @param newReward New revenue reward contract address\n     */\n    event RevenueRewardUpdated(address indexed oldReward, address indexed newReward);\n\n    /**\n     * @notice Emitted when the split permission is toggled for an account\n     * @param account Address whose permission is updated\n     * @param allowed Whether splitting is now allowed for the account\n     */\n    event SplitPermissionUpdated(address indexed account, bool allowed);\n\n    /**\n     * @notice Emitted when the base URI is updated\n     * @param oldBaseURI Previous base URI\n     * @param newBaseURI New base URI\n     */\n    event BaseURIUpdated(string oldBaseURI, string newBaseURI);\n\n    /*//////////////////////////////////////////////////////////////\n                                STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Address of Meta-tx Forwarder\n     * @return The trusted forwarder address used for meta-transactions\n     */\n    function forwarder() external view returns (address);\n\n    /**\n     * @notice Address of token (DUST) used to create a veNFT\n     * @return The ERC20 token address used to lock and mint veNFTs\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Address of Neverland Team multisig\n     * @return The address of the current team multisig with administrative privileges\n     */\n    function team() external view returns (address);\n\n    /**\n     * @notice Address of pending team for two-step ownership transfer\n     * @return The address of the pending team, or address(0) if no proposal exists\n     */\n    function pendingTeam() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Proposes a new team address for two-step ownership transfer\n     * @dev This is the first step of a two-step ownership transfer process.\n     *      Only the current team can propose a new team address.\n     *      The proposed address must accept ownership to complete the transfer.\n     *      This prevents accidental loss of admin control due to typos or wrong addresses.\n     * @param _newTeam The address of the proposed new team multisig\n     */\n    function proposeTeam(address _newTeam) external;\n\n    /**\n     * @notice Accepts the proposed team address to complete the ownership transfer\n     * @dev This is the second step of the two-step ownership transfer process.\n     *      Only the pending team address can call this function.\n     *      Once called, the caller becomes the new team and the pending team is cleared.\n     *      This ensures that the new team controls the proposed address.\n     */\n    function acceptTeam() external;\n\n    /**\n     * @notice Cancels the pending team proposal\n     * @dev Allows the current team to cancel a pending ownership transfer.\n     *      Only the current team can call this function.\n     *      This is useful if the team made an error in the proposed address.\n     *      After cancellation, a new proposal can be made.\n     */\n    function cancelTeamProposal() external;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the name of the token\n     * @return The name of the veNFT token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token\n     * @return The symbol of the veNFT token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns the version of the contract\n     * @return The current version string of the contract\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice Updates the base URI for computing tokenURI\n     * @dev Can only be called by the team address\n     * @param newBaseURI The new base URI to set for all tokens\n     */\n    function setBaseURI(string memory newBaseURI) external;\n\n    /**\n     * @notice Current total count of veNFT tokens\n     * @dev Used as a counter for minting new tokens and assigning IDs\n     * @return The current highest token ID value\n     */\n    function tokenId() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the tokenId owned by `_owner` at position `_index`\n     * @param _owner Owner address to query\n     * @param _index Index of the token within the owner's list\n     * @return _tokenId The tokenId at the given index for the owner\n     */\n    function ownerToNFTokenIdList(address _owner, uint256 _index) external view returns (uint256 _tokenId);\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @notice Check whether spender is owner or an approved user for a given veNFT\n     * @param _spender The address to approve for the tokenId\n     * @param _tokenId The ID of the veNFT to be approved\n     * @return True if `_spender` is owner or approved for `_tokenId`, false otherwise\n     */\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Total count of epochs witnessed since contract creation\n     * @return The current epoch number\n     */\n    function epoch() external view returns (uint256);\n\n    /**\n     * @notice Total amount of tokens currently locked in the contract\n     * @return The total supply of locked tokens\n     */\n    function supply() external view returns (uint256);\n\n    /**\n     * @notice Aggregate balance of permanently locked tokens\n     * @dev These tokens cannot be withdrawn through normal means\n     * @return The total amount of permanently locked tokens\n     */\n    function permanentLockBalance() external view returns (uint256);\n\n    /**\n     * @notice Percentage of penalty applied to early withdrawals (in basis points)\n     * @dev Value is between 0 and 10000 (0% to 100%)\n     * @return The current penalty percentage in basis points\n     */\n    function earlyWithdrawPenalty() external view returns (uint256);\n\n    /**\n     * @notice Address that receives penalty fees from early withdrawals\n     * @return The address of the treasury that collects early withdrawal penalties\n     */\n    function earlyWithdrawTreasury() external view returns (address);\n\n    /**\n     * @notice Get the current epoch number for a specific veNFT\n     * @param _tokenId The ID of the veNFT to check\n     * @return _epoch The current epoch number for the specified veNFT\n     */\n    function userPointEpoch(uint256 _tokenId) external view returns (uint256 _epoch);\n\n    /**\n     * @notice Retrieve the scheduled slope change at a given timestamp\n     * @dev Used to calculate future voting power changes due to lock expirations\n     * @param _timestamp The timestamp to check for slope changes\n     * @return The net change in slope (negative value means decrease in voting power)\n     */\n    function slopeChanges(uint256 _timestamp) external view returns (int256);\n\n    /**\n     * @notice Check if an account has permission to split veNFTs\n     * @dev Used to control which addresses can perform veNFT splitting operations\n     * @param _account The address to check for split permission\n     * @return True if the account can split veNFTs, false otherwise\n     */\n    function canSplit(address _account) external view returns (bool);\n\n    /**\n     * @notice Retrieve a global checkpoint at a specific index\n     * @dev Used to track historical voting power across all tokens at different points in time\n     * @param _loc The index of the checkpoint to retrieve\n     * @return The GlobalPoint data at the specified index\n     */\n    function pointHistory(uint256 _loc) external view returns (GlobalPoint memory);\n\n    /**\n     * @notice Get the lock details for a specific veNFT\n     * @dev Returns information about lock amount, end time, and permanent status\n     * @param _tokenId The ID of the veNFT to query\n     * @return The LockedBalance struct containing lock information\n     */\n    function locked(uint256 _tokenId) external view returns (LockedBalance memory);\n\n    /**\n     * @notice Retrieve a user checkpoint for a specific veNFT at a given index\n     * @dev Used to track historical voting power for individual tokens\n     * @param _tokenId The ID of the veNFT to query\n     * @param _loc The index of the user checkpoint to retrieve\n     * @return The UserPoint data at the specified index for the given token\n     */\n    function userPointHistory(uint256 _tokenId, uint256 _loc) external view returns (UserPoint memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Create a global checkpoint to record the current state of voting power\n     * @dev Updates the global point history with current voting power data\n     *      This is called automatically by most state-changing functions\n     *      but can be called manually to ensure up-to-date on-chain data\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT lock\n     * @dev Anyone (even a smart contract) can deposit tokens for someone else's lock\n     *      The deposit increases the lock amount but does not extend the lock time\n     *      Cannot be used for locks that have already expired\n     * @param _tokenId The ID of the veNFT to deposit for\n     * @param _value Amount of tokens to add to the existing lock\n     */\n    function depositFor(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Create a new lock by depositing tokens for the caller\n     * @dev Creates a new veNFT representing the locked tokens\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return The ID of the newly created veNFT\n     */\n    function createLock(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock by depositing tokens for another address\n     * @dev Creates a new veNFT representing the locked tokens and assigns it to the specified recipient\n     *      This is useful for protocols that want to create locks on behalf of their users\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return The ID of the newly created veNFT\n     */\n    function createLockFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for the caller and immediately make it permanent\n     * @dev UX convenience to perform \"create lock\" and \"make permanent\" in a single transaction\n     *      Follows the same validation as `createLock` (min amount, duration bounds, week rounding)\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanent(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for `to` and immediately make it permanent\n     * @dev UX convenience to mint the veNFT to `to` and set permanence in one transaction\n     *      Uses `to` as the owner for auth semantics; validation mirrors `createLock`\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanentFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT without modifying the unlock time\n     * @dev Increases the amount of tokens in a lock while keeping the same unlock date\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to increase the amount for\n     * @param _value Additional amount of tokens to add to the lock\n     */\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Extend the unlock time for an existing veNFT lock\n     * @dev Increases the lock duration without changing the token amount\n     *      Cannot extend lock time of permanent locks\n     *      New lock time is rounded down to the nearest week\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to extend the lock duration for\n     * @param _lockDuration New number of seconds until tokens unlock (from current time)\n     */\n    function increaseUnlockTime(uint256 _tokenId, uint256 _lockDuration) external;\n\n    /**\n     * @notice Withdraw all tokens from an expired lock for `_tokenId`\n     * @dev Only possible if the lock has expired and is not a permanent lock\n     *      This function burns the veNFT and returns the locked tokens to the owner\n     *      IMPORTANT: Any unclaimed rebases or rewards will no longer be claimable after calling this\n     *      Users should claim all rebases and rewards prior to withdrawing\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw tokens from\n     */\n    function withdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Withdraw tokens from a lock before it expires, with a time-proportional penalty\n     * @dev Allows users to exit a lock early but with a penalty fee applied\n     *      The penalty is proportional to both `earlyWithdrawPenalty` and remaining time until unlock\n     *      If the lock is permanent, it is internally converted back to a standard time-lock first and\n     *      the early withdraw penalty is computed using the restored lock window. Penalty fees are sent\n     *      to the `earlyWithdrawTreasury` address. Burns the veNFT and returns the nonpenalized portion\n     *      of tokens to the owner. Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw early from\n     */\n    function earlyWithdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Sets the early withdrawal penalty percentage\n     * @dev Can only be called by the team address\n     *      Value is in basis points (0-10000), where 10000 = 100%\n     * @param _earlyWithdrawPenalty The new penalty percentage in basis points\n     */\n    function setEarlyWithdrawPenalty(uint256 _earlyWithdrawPenalty) external;\n\n    /**\n     * @notice Sets the treasury address that will receive penalty fees from early withdrawals\n     * @dev Can only be called by the team address\n     *      The treasury address receives the penalty portion of tokens from early withdrawals\n     * @param _account The address of the new treasury that will receive penalty fees\n     */\n    function setEarlyWithdrawTreasury(address _account) external;\n\n    /**\n     * @notice Merges two veNFTs by combining their locked tokens into a single veNFT\n     * @dev The source veNFT is burned and its tokens are added to the destination veNFT\n     *      The lock duration/semantics of the destination veNFT are preserved\n     *      Rules:\n     *      - permanent + permanent: allowed (destination stays permanent)\n     *      - nonpermanent + permanent: allowed (permanent principal increases)\n     *      - permanent + nonpermanent: reverts\n     *      - expired source or destination: reverts\n     *      Can only be called by an address that owns or is approved for both veNFTs\n     * @param _from The ID of the source veNFT to merge from (will be burned)\n     * @param _to The ID of the destination veNFT to merge into (will receive the combined tokens)\n     */\n    function merge(uint256 _from, uint256 _to) external;\n\n    /**\n     * @notice Splits a veNFT into two new veNFTs with divided token balances\n     * @dev This operation burns the original veNFT and creates two new ones\n     *      Both new veNFTs maintain the same lock end time as the original\n     *      Can only be called by an address that has split permission, and owns or is approved for the veNFT\n     *      If called by an approved address, that address will NOT have approval on the new veNFTs\n     *      (approvals on the parent do not carry over to children)\n     *      Requires that the caller is either the owner or specifically has been granted split permission\n     *      Cannot split permanent locks\n     * @param _from The ID of the veNFT to split (will be burned)\n     * @param _amount The precise token amount to allocate to the second new veNFT\n     * @return _tokenId1 ID of the first new veNFT with (original amount - _amount) tokens\n     * @return _tokenId2 ID of the second new veNFT with exactly _amount tokens\n     */\n    function split(uint256 _from, uint256 _amount) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n    /**\n     * @notice Grant or revoke permission for an address to split veNFTs\n     * @dev Can only be called by the team address\n     *      Setting permissions for address(0) acts as a global switch for all addresses\n     *      If address(0) is set to false, no address can split regardless of individual permissions\n     *      If address(0) is set to true, individual permissions apply normally\n     * @param _account The address to modify split permissions for, or address(0) for global setting\n     * @param _bool True to grant permission, false to revoke permission\n     */\n    function toggleSplit(address _account, bool _bool) external;\n\n    /**\n     * @notice Permanently lock a veNFT to give it non-decaying voting power\n     * @dev Converts a standard time-locked veNFT to a permanent lock\n     *      Once permanent, the veNFT cannot be withdrawn normally (even after the original lock time)\n     *      Permanent locks have constant voting power equal to the locked token amount with no time decay\n     *      Note: time served prior to permanence is not preserved for penalty calculations  if the owner\n     *      later calls `earlyWithdraw`, the position is first unlocked and the penalty window resets to a\n     *      full MAXTIME from the current timestamp\n     *      Can only be called by the owner of the veNFT or an approved address\n     *      Cannot be called on a lock that is already permanent\n     * @param _tokenId The ID of the veNFT to permanently lock\n     */\n    function lockPermanent(uint256 _tokenId) external;\n\n    /**\n     * @notice Revert a veNFT from permanent lock status back to a standard time-lock\n     * @dev Converts a permanent lock back to a standard time-based lock\n     *      After unlocking, the veNFT's voting power will decay based on the remaining lock time\n     *      The lock time will be the original lock end time from before it was made permanent\n     *      If the original lock time has already passed, the lock will be immediately withdrawable\n     *      Can only be called by the owner or an approved operator\n     *      Only callable on veNFTs that are currently permanently locked\n     * @param _tokenId The ID of the veNFT to revert from permanent to standard lock\n     */\n    function unlockPermanent(uint256 _tokenId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                           VOTING POWER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the current voting power for a specific veNFT\n     * @dev Calculates voting power based on lock amount, remaining time, and permanent status\n     *      For standard locks: voting power = amount * (time_left / MAXTIME)\n     *      For permanent locks: voting power = amount (no time decay)\n     *      Returns 0 if called in the same block as a transfer due to checkpoint timing\n     *      This is the core function used for governance voting power determination\n     * @param _tokenId The ID of the veNFT to query voting power for\n     * @return The current voting power of the specified veNFT\n     */\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Get the historical voting power for a veNFT at a specific timestamp\n     * @dev Uses checkpoints to determine voting power at any point in the past\n     *      Crucial for governance systems that need to determine past voting power\n     *      For timestamps between checkpoints, calculates the interpolated value\n     *      Returns 0 for timestamps before the veNFT was created\n     * @param _tokenId The ID of the veNFT to query historical voting power for\n     * @param _t The timestamp at which to query the voting power\n     * @return The voting power of the specified veNFT at the requested timestamp\n     */\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    /**\n     * @notice Calculate the total voting power across all veNFTs at the current timestamp\n     * @dev Sums up all individual veNFT voting powers including both time-based and permanent locks\n     *      This represents the total governance voting power in the system right now\n     * @return The aggregate voting power of all veNFTs at the current timestamp\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Calculate the total historical voting power across all veNFTs at a specific timestamp\n     * @dev Uses global checkpoints to determine total voting power at any point in the past\n     *      Critical for governance votes that need to determine the total voting power at a past block\n     *      For timestamps between checkpoints, calculates the interpolated value\n     * @param _t The timestamp at which to query the total voting power\n     * @return The aggregate voting power of all veNFTs at the requested timestamp\n     */\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC6372\n    function clock() external view returns (uint48);\n\n    /// @inheritdoc IERC6372\n    function CLOCK_MODE() external view returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                          MIN LOCK AMOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the minimum amount of tokens required to create a veNFT lock\n     * @dev This value is used to validate lock creation and prevent spam attacks\n     * @return The minimum lock amount in token units (with 18 decimals)\n     */\n    function minLockAmount() external view returns (uint256);\n\n    /**\n     * @notice Sets the minimum amount of tokens required to create a veNFT lock\n     * @dev Can only be called by the team address. This helps prevent spam and ensures meaningful lock amounts\n     * @param newMinLockAmount The new minimum lock amount in token units (with 18 decimals)\n     */\n    function setMinLockAmount(uint256 newMinLockAmount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                      NOTIFY CONTRACTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the revenue reward contract\n     * @dev Returns address(0) if no revenue reward contract is set\n     * @return The revenue reward contract\n     */\n    function revenueReward() external view returns (IRevenueReward);\n\n    /**\n     * @notice Sets the revenue reward contract\n     * @dev Can only be called by the team address\n     * @param _revenueReward The new revenue reward contract\n     */\n    function setRevenueReward(IRevenueReward _revenueReward) external;\n}\n",
        "keccak256": "0x6b386b558166fbc71e1bf95bee2210f81afd960ab7129ac7503125c1ffb9bc5b",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IRevenueReward.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\n\nimport {IUserVaultFactory} from \"./IUserVaultFactory.sol\";\n\n/**\n * @title IRevenueReward Interface\n * @author Neverland\n * @notice Interface for the RevenueReward contract that manages token rewards distribution\n * @dev Handles reward epochs, claiming rewards, and self-repaying loan functionality\n */\ninterface IRevenueReward {\n    /// @notice Error thrown when a non-distributor address attempts to notify rewards\n    error NotRewardDistributor();\n\n    /// @notice Error thrown when a non-owner address attempts a restricted operation\n    error NotOwner();\n\n    /// @notice Error thrown when a non-DustLock address attempts a restricted operation\n    error NotDustLock();\n\n    /// @notice Error thrown when end timestamp used for calculating rewards is greater than the current time\n    error EndTimestampMoreThanCurrent();\n\n    /// @notice Error thrown when provided arrays are empty or exceed soft size limits\n    error InvalidArrayLengths();\n\n    /// @notice Error thrown when a provided reward token is not registered\n    error UnknownRewardToken();\n\n    /// @notice Error thrown when an array contains duplicate values or is not sorted in ascending order\n    error ArrayNotSortedOrContainsDuplicates();\n\n    /**\n     * @notice Emitted when rewards are claimed\n     * @param tokenId The veNFT id that produced the rewards\n     * @param user The address that received the rewards (owner or configured receiver)\n     * @param token Address of the reward token being claimed\n     * @param amount Amount of rewards claimed\n     */\n    event ClaimRewards(uint256 indexed tokenId, address indexed user, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when new rewards are notified to the contract\n     * @param from Address that notified the rewards (typically the reward distributor)\n     * @param token Address of the reward token being added\n     * @param epoch Reward epoch start timestamp (i.e., start of the week) the amount is credited to\n     * @param amount Amount of rewards added\n     */\n    event NotifyReward(address indexed from, address indexed token, uint256 epoch, uint256 amount);\n\n    /**\n     * @notice Emitted when tokens are recovered from the contract\n     * @param token Address of the token being recovered\n     * @param amount Amount of tokens recovered\n     */\n    event RecoverTokens(address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when self-repaying loan status is updated for a token\n     * @param token ID of the veNFT whose reward redirection is being configured\n     * @param rewardReceiver Address that will receive the rewards (or zero address if disabled)\n     * @param isEnabled Whether self-repaying loan is being enabled (true) or disabled (false)\n     */\n    event SelfRepayingLoanUpdate(uint256 indexed token, address rewardReceiver, bool isEnabled);\n\n    /**\n     * @notice Emitted when the reward distributor address is updated\n     * @param oldDistributor The previous reward distributor\n     * @param newDistributor The new reward distributor\n     */\n    event RewardDistributorUpdated(address indexed oldDistributor, address indexed newDistributor);\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice The address of the DustLock contract that manages veNFTs\n     * @return The IDustLock interface of the connected DustLock contract\n     */\n    function dustLock() external view returns (IDustLock);\n\n    /**\n     * @notice The address of the UserVaultFactory contract that manages user vaults\n     * @return The IUserVaultFactory interface of the connected UserVaultFactory contract\n     */\n    function userVaultFactory() external view returns (IUserVaultFactory);\n\n    /**\n     * @notice The duration of a reward epoch in seconds\n     * @dev This defines the time window for each reward distribution cycle\n     * @return Duration in seconds for each reward epoch\n     */\n    function DURATION() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of tokenIds allowed in a single batch claim.\n     * @return The maximum number of tokenIds accepted in batch calls\n     */\n    function MAX_TOKENIDS() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of reward tokens allowed in a single batch claim.\n     * @return The maximum number of reward tokens accepted in batch calls\n     */\n    function MAX_TOKENS() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                            STORAGE GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the timestamp of the last successfully processed reward claim for a token and veNFT\n     * @dev Used to calculate the amount of rewards earned since the last claim. Value is advanced to the\n     *      claim period end only when there were epochs to process; otherwise it remains unchanged.\n     * @param token The address of the reward token\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp (seconds) when rewards were last processed up to\n     */\n    function lastEarnTime(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the address authorized to add rewards to the contract\n     * @dev This address is the only one that can call notifyRewardAmount\n     *      Typically set to a protocol treasury or governance-controlled address\n     * @return The current reward distributor address\n     */\n    function rewardDistributor() external view returns (address);\n\n    /**\n     * @notice Checks if a token is registered as a valid reward token\n     * @dev Only registered reward tokens can be distributed through the contract\n     *      Tokens are registered automatically the first time they're used in notifyRewardAmount\n     * @param token The address of the token to check\n     * @return True if the token is registered as a reward token, false otherwise\n     */\n    function isRewardToken(address token) external view returns (bool);\n\n    /**\n     * @notice Returns the reward token at a specific index in the list of registered reward tokens\n     * @dev Used to enumerate all reward tokens available in the contract\n     *      Valid indices range from 0 to the number of registered reward tokens minus 1\n     * @param index The index in the reward tokens array\n     * @return The address of the reward token at the specified index\n     */\n    function rewardTokens(uint256 index) external view returns (address);\n\n    /**\n     * @notice Returns the accumulated sum of all reward distributions for a specific token\n     * @dev Used for internal reward accounting and distribution calculations\n     *      This value increases each time new rewards are notified\n     * @param token The address of the reward token\n     * @return The total amount of rewards ever distributed for this token\n     */\n    function totalRewardsPerToken(address token) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of rewards allocated for a specific token at a given epoch start\n     * @dev Rewards are tracked by epoch start timestamp (seconds), with each epoch lasting DURATION seconds.\n     * @param token The address of the reward token\n     * @param epoch The epoch start timestamp (i.e., start of the week)\n     * @return The amount of rewards allocated for the token at that epoch start\n     */\n    function tokenRewardsPerEpoch(address token, uint256 epoch) external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp when a veNFT was minted\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp when the veNFT was minted\n     */\n    function tokenMintTime(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the accumulated fractional remainder of rewards for a veNFT and token, scaled by 1e18.\n     * @dev During per-epoch reward calculations, integer division can leave a remainder that cannot be paid out.\n     *      This function exposes the running sum of those remainders for the given (token, tokenId) pair,\n     *      scaled by a factor of 1e18 to preserve precision (i.e., value is remainder * 1e18 / totalSupplyAt(epoch)).\n     *      This value is informational and not directly claimable; it helps off-chain analytics understand\n     *      the uncredited fractional rewards that have accumulated over time due to rounding.\n     * @param token The address of the reward token being tracked.\n     * @param tokenId The ID of the veNFT whose fractional remainder is queried.\n     * @return scaledRemainder The accumulated fractional rewards remainder, scaled by 1e18.\n     */\n    function tokenRewardsRemainingAccScaled(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the configured reward recipient address for a specific veNFT\n     * @dev When self-repaying loan functionality is enabled, rewards are sent to this address\n     *      Returns address(0) if no special recipient is configured (rewards go to veNFT owner)\n     * @param tokenId The ID of the veNFT to query\n     * @return The address that receives rewards for this veNFT, or address(0) if it's the owner\n     */\n    function tokenRewardReceiver(uint256 tokenId) external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the address authorized to add rewards to the contract\n     * @dev Can only be called by the current reward distributor\n     *      This is a critical permission that controls who can distribute rewards\n     * @param newRewardDistributor The address of the new reward distributor\n     */\n    function setRewardDistributor(address newRewardDistributor) external;\n\n    /**\n     * @notice Adds new rewards to the distribution pool for the next epoch\n     * @dev Can only be called by the authorized reward distributor address.\n     *      Automatically registers new tokens the first time they're used.\n     *      Rewards added during the current epoch become claimable starting the next epoch.\n     *      Emits a NotifyReward event with details about the distribution.\n     *      Reverts: NotRewardDistributor, zero address/amount checks enforced by implementation.\n     * @param token The address of the reward token to distribute\n     * @param amount The amount of rewards to add to the distribution pool\n     */\n    function notifyRewardAmount(address token, uint256 amount) external;\n\n    /**\n     * @notice Recovers unnotified balances of registered reward tokens\n     * @dev Can only be called by the reward distributor\n     *      For each registered reward token, if the contract's token balance exceeds the credited amount\n     *      tracked by totalRewardsPerToken[token], transfers the excess to the reward distributor and emits\n     *      a RecoverTokens event.\n     */\n    function recoverTokens() external;\n\n    /*//////////////////////////////////////////////////////////////\n                            NOTIFICATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Notifies the contract that a new token has been created\n     * @dev Intended to update internal state or trigger logic after a veNFT creation event\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the token (veNFT) that has been created\n     */\n    function notifyTokenMinted(uint256 tokenId) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is transferred\n     * @dev This function is called by the DustLock contract just after transferring a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being transferred\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was transferred\n     * @param from The address of the previous token owner (sender of the transfer)\n     */\n    function notifyAfterTokenTransferred(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is burned\n     * @dev This function is called by the DustLock contract just after burning a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being burned\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was burned\n     * @param from The address of the previous token owner\n     */\n    function notifyAfterTokenBurned(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles bookkeeping after two veNFTs are merged.\n     * @dev Callable only by the DustLock contract.\n     * @param fromToken The tokenId that was merged and is no longer active (source).\n     * @param toToken The tokenId that survives the merge and should receive consolidated accounting (destination).\n     * @param owner The tokens' owner.\n     */\n    function notifyAfterTokenMerged(uint256 fromToken, uint256 toToken, address owner) external;\n\n    /**\n     * @notice Handles bookkeeping after a veNFT is split into two new veNFTs.\n     * @dev Callable only by the DustLock contract.\n     *      - Initializes mint timestamps for the two new tokenIds.\n     *      - Proportionally splits the accumulated fractional rewards remainder (scaled by 1e18)\n     *        from `fromToken` between `tokenId1` and `tokenId2` using their provided amounts.\n     *      - Clears the remainder accumulator for `fromToken` and removes it from any self-repaying\n     *        loan tracking if applicable.\n     * @param fromToken The original tokenId that was split (source).\n     * @param tokenId1 The first resulting tokenId after the split.\n     * @param token1Amount The amount (voting power/shares) assigned to `tokenId1` in the split.\n     * @param tokenId2 The second resulting tokenId after the split.\n     * @param token2Amount The amount (voting power/shares) assigned to `tokenId2` in the split.\n     * @param owner The owner of the tokens involved in the split.\n     */\n    function notifyAfterTokenSplit(\n        uint256 fromToken,\n        uint256 tokenId1,\n        uint256 token1Amount,\n        uint256 tokenId2,\n        uint256 token2Amount,\n        address owner\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens\n     * @dev Calculates earned rewards for each specified token using epoch-based accounting and transfers them\n     *      to the appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured\n     *      via enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     */\n    function getReward(uint256 tokenId, address[] calldata tokens) external;\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp\n     * @dev Similar to getReward, but allows specifying a custom end timestamp for the reward calculation period.\n     *      Calculates earned rewards for each specified token using epoch-based accounting and transfers them to the\n     *      appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured via\n     *      enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to rewardPeriodEndTs to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, EndTimestampMoreThanCurrent, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     * @param rewardPeriodEndTs The end timestamp to calculate rewards up to (must not be in the future)\n     */\n    function getRewardUntilTs(uint256 tokenId, address[] calldata tokens, uint256 rewardPeriodEndTs) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays or unknown tokens.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     */\n    function getRewardBatch(uint256[] calldata tokenIds, address[] calldata tokens) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens up to a specific timestamp.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays, unknown tokens,\n     *      or if `rewardPeriodEndTs` is in the future.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     * @param rewardPeriodEndTs End timestamp for calculation (<= now).\n     */\n    function getRewardUntilTsBatch(uint256[] calldata tokenIds, address[] calldata tokens, uint256 rewardPeriodEndTs)\n        external;\n\n    /*//////////////////////////////////////////////////////////////\n                         SELF-REPAYING LOANS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Enables the self-repaying loan feature for a specific veNFT\n     * @dev Configures a custom reward receiver address (typically a loan contract).\n     *      This allows veNFT owners to use their rewards to automatically repay loans.\n     *      The getReward function must still be called to trigger the reward claim.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner, zero rewardReceiver.\n     * @param tokenId The ID of the veNFT to configure self-repaying loan for\n     */\n    function enableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Disables the self-repaying loan feature for a specific veNFT\n     * @dev Removes the custom reward receiver configuration, returning to default behavior.\n     *      After disabling, all future rewards will go directly to the veNFT owner.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner.\n     * @param tokenId The ID of the veNFT to restore default reward routing for\n     */\n    function disableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Batch enable self-repaying loan with a single receiver for many tokenIds.\n     * @dev Each tokenId must be owned by the caller. Reverts on zero rewardReceiver.\n     * @param tokenIds Array of veNFT ids to configure.\n     */\n    function enableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /**\n     * @notice Batch disable self-repaying loan for many tokenIds.\n     * @dev Each tokenId must be owned by the caller.\n     * @param tokenIds Array of veNFT ids to restore default reward routing.\n     */\n    function disableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Preview unclaimed rewards for a single reward token up to a specific timestamp.\n     * @dev Read-only mirror of claim math; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, UnknownRewardToken if not registered.\n     * @param token Reward token address to preview.\n     * @param tokenId veNFT id to preview for.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return amount Total rewards that would be claimable if claimed up to `endTs`.\n     */\n    function earnedRewards(address token, uint256 tokenId, uint256 endTs) external view returns (uint256 amount);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens at the current timestamp.\n     * @dev Convenience wrapper that uses block.timestamp internally. Returns a matrix of rewards per\n     *      tokenId (outer) per token (inner), and totals per token.\n     *      Reverts: InvalidArrayLengths on bad inputs, UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAll(address[] calldata tokens, uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens up to a specific timestamp.\n     * @dev Read-only; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, InvalidArrayLengths on bad inputs,\n     *      UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAllUntilTs(address[] calldata tokens, uint256[] calldata tokenIds, uint256 endTs)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Returns the number of registered reward tokens\n     * @return The count of reward tokens\n     */\n    function rewardTokensLength() external view returns (uint256);\n\n    /**\n     * @notice Returns the full list of registered reward tokens\n     * @return tokens An array containing all reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory tokens);\n\n    /**\n     * @notice Returns a list of user addresses with at least one active self-repaying loan within a given range.\n     * @dev Iterates over the internal set of users who have enabled self-repaying loans,\n     *      returning addresses from index `from` up to, but not including, index `to`.\n     *      If the specified range exceeds the number of users, the function adjusts accordingly.\n     * @param from The starting index (inclusive) in the user set.\n     * @param to The ending index (exclusive) in the user set.\n     * @return users An array of user addresses in the specified range who have self-repaying loans enabled.\n     */\n    function getUsersWithSelfRepayingLoan(uint256 from, uint256 to) external view returns (address[] memory);\n\n    /**\n     * @notice Returns the list of token IDs for which the given user has enabled a self-repaying loan.\n     * @dev Checks the user's internal set of token IDs with self-repaying loans and returns them as an array.\n     * @param user The address of the user to query.\n     * @return tokenIds An array of token IDs currently associated with self-repaying loans for the user.\n     */\n    function getUserTokensWithSelfRepayingLoan(address user) external view returns (uint256[] memory tokenIds);\n}\n",
        "keccak256": "0xb72598c4cb5b87b2421a6763d847267c173a884a1eeb283b3474a9a4e0066477",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IUserVaultFactory.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title IUserVaultFactory\n * @author Neverland\n * @notice Interface for the UserVaultFactory contract.\n *         Allows creation and retrieval of user-specific vaults.\n */\ninterface IUserVaultFactory {\n    /**\n     * @notice Emitted when a new user vault is created\n     * @param user The user for whom the vault was created\n     * @param vault The address of the created vault\n     */\n    event UserVaultCreated(address indexed user, address indexed vault);\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user. Creates a new vault if none exists\n     * @dev If the vault does not exist, a new BeaconProxy is deployed and initialized for the user\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getUserVault(address user) external view returns (address vault);\n\n    /*//////////////////////////////////////////////////////////////\n                               ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user if it exists\n     * @dev If the vault does not exist, returns address(0)\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getOrCreateUserVault(address user) external returns (address vault);\n}\n",
        "keccak256": "0x2c37e5bc81e701ab66b66aea87f6daedf1ec8adf2685d14a66afe77ea477735e",
        "license": "BUSL-1.1"
      },
      "src/libraries/CommonChecksLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonChecksLibrary\n * @author Neverland\n * @notice Shared require/revert helpers for zero/invalid values used across contracts\n */\nlibrary CommonChecksLibrary {\n    /// @notice Used when a zero address is provided where not allowed.\n    error AddressZero();\n    /// @notice Used when a zero amount is provided where not allowed.\n    error ZeroAmount();\n    /// @notice Used when a range is invalid.\n    error InvalidRange();\n    /// @notice Used when two addresses are the same but must differ.\n    error SameAddress();\n    /// @notice Used when a balance is zero.\n    error ZeroBalance();\n    /// @notice Used when a tokenId is invalid.\n    error InvalidTokenId();\n    /// @notice Used when a from address is invalid.\n    error InvalidFromAddress();\n    /// @notice Used when a to address is invalid.\n    error InvalidToAddress();\n    /// @notice Used when a user address is invalid.\n    error InvalidUserAddress();\n    /// @notice Used a function is called by an account that is not permitted.\n    error UnauthorizedAccess();\n\n    /**\n     * @notice Reverts if the provided address is zero\n     * @param addressToCheck The address to check\n     */\n    function revertIfZeroAddress(address addressToCheck) internal pure {\n        if (addressToCheck == address(0)) revert AddressZero();\n    }\n\n    /**\n     * @notice Reverts if the provided amount is zero\n     * @param amount The amount to check\n     */\n    function revertIfZeroAmount(uint256 amount) internal pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n\n    /**\n     * @notice Reverts if the [from, to] range is invalid (from > to)\n     * @param from The start of the range\n     * @param to The end of the range\n     */\n    function revertIfInvalidRange(uint256 from, uint256 to) internal pure {\n        if (from > to) revert InvalidRange();\n    }\n\n    /**\n     * @notice Reverts if the two addresses are the same\n     * @param first The first address to check\n     * @param second The second address to check\n     */\n    function revertIfSameAddress(address first, address second) internal pure {\n        if (first == second) revert SameAddress();\n    }\n\n    /**\n     * @notice Reverts if the balance is zero\n     * @param balance The balance to check\n     */\n    function revertIfZeroBalance(uint256 balance) internal pure {\n        if (balance == 0) revert ZeroBalance();\n    }\n\n    /**\n     * @notice Reverts if the tokenId owner is the zero address\n     * @param owner The owner of the tokenId\n     */\n    function revertIfInvalidTokenId(address owner) internal pure {\n        if (owner == address(0)) revert InvalidTokenId();\n    }\n\n    /**\n     * @notice Reverts if the from address is zero\n     * @param from The from address to check\n     */\n    function revertIfInvalidFromAddress(address from) internal pure {\n        if (from == address(0)) revert InvalidFromAddress();\n    }\n\n    /**\n     * @notice Reverts if the to address is zero\n     * @param to The to address to check\n     */\n    function revertIfInvalidToAddress(address to) internal pure {\n        if (to == address(0)) revert InvalidToAddress();\n    }\n\n    /**\n     * @notice Reverts if the user address is zero\n     * @param user The user address to check\n     */\n    function revertIfInvalidUserAddress(address user) internal pure {\n        if (user == address(0)) revert InvalidUserAddress();\n    }\n}\n",
        "keccak256": "0xa8e23a48af12c93a809845953069be6f296d8d2e93e7cd89e5250b15b5d9f805",
        "license": "BUSL-1.1"
      },
      "src/libraries/EpochTimeLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title EpochTimeLibrary\n * @author Extended by Neverland\n * @notice Shared helpers for epoch time calculations\n */\nlibrary EpochTimeLibrary {\n    uint256 internal constant WEEK = 7 days;\n\n    /**\n     * @notice Returns the start time of the current epoch containing the given timestamp\n     * @dev Calculates the beginning of a week period by removing the remainder when dividing by WEEK\n     * @param timestamp The timestamp to calculate the epoch start for\n     * @return The timestamp for the start of the current epoch\n     */\n    function epochStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK);\n        }\n    }\n\n    /**\n     * @notice Returns the start time of the next epoch after the given timestamp\n     * @dev Calculates the beginning of the next week period by removing the remainder when dividing by WEEK and adding one WEEK\n     * @param timestamp The timestamp to calculate the next epoch from\n     * @return The timestamp for the start of the next epoch\n     */\n    function epochNext(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK;\n        }\n    }\n\n    /**\n     * @notice Returns the start time of the voting window within the current epoch\n     * @dev Voting begins 1 hour after the start of the epoch\n     * @param timestamp The timestamp within the current epoch\n     * @return The timestamp when voting begins in the current epoch\n     */\n    function epochVoteStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + 1 hours;\n        }\n    }\n\n    /**\n     * @notice Returns the end time of the voting window within the current epoch\n     * @dev Voting ends 1 hour before the end of the epoch\n     * @param timestamp The timestamp within the current epoch\n     * @return The timestamp when voting ends in the current epoch\n     */\n    function epochVoteEnd(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK - 1 hours;\n        }\n    }\n}\n",
        "keccak256": "0x5c3e1742bdd83a147f1a62e64d6a8be742cc7132a81252e373f6f810b6aef02d",
        "license": "BUSL-1.1"
      },
      "src/rewards/RevenueReward.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {IUserVaultFactory} from \"../interfaces/IUserVaultFactory.sol\";\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\nimport {IRevenueReward} from \"../interfaces/IRevenueReward.sol\";\n\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\nimport {EpochTimeLibrary} from \"../libraries/EpochTimeLibrary.sol\";\n\n/**\n * @title RevenueReward\n * @author Neverland\n * @notice Stores ERC20 token rewards and provides them to veDUST owners\n */\ncontract RevenueReward is IRevenueReward, Initializable, ERC2771ContextUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _forwarder) ERC2771ContextUpgradeable(_forwarder) {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes the contract\n     * @param _forwarder address of trusted forwarder\n     * @param _dustLock address of DustLock contract\n     * @param _rewardDistributor address of DustRewardsController contract\n     * @param _userVaultFactory address of UserVaultFactory contract\n     */\n    function initialize(\n        address _forwarder,\n        IDustLock _dustLock,\n        address _rewardDistributor,\n        IUserVaultFactory _userVaultFactory\n    ) external initializer {\n        CommonChecksLibrary.revertIfZeroAddress(_forwarder);\n        CommonChecksLibrary.revertIfZeroAddress(address(_dustLock));\n        CommonChecksLibrary.revertIfZeroAddress(_rewardDistributor);\n        CommonChecksLibrary.revertIfZeroAddress(address(_userVaultFactory));\n\n        __ReentrancyGuard_init();\n\n        dustLock = _dustLock;\n        rewardDistributor = _rewardDistributor;\n        userVaultFactory = _userVaultFactory;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRevenueReward\n    uint256 public constant DURATION = 7 days;\n    /// @inheritdoc IRevenueReward\n    uint256 public constant MAX_TOKENS = 32;\n    /// @inheritdoc IRevenueReward\n    uint256 public constant MAX_TOKENIDS = 64;\n\n    /// @notice Scale factor for rewards remaining\n    uint256 private constant REWARDS_REMAINING_SCALE = 1e18;\n\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRevenueReward\n    IDustLock public dustLock;\n    /// @inheritdoc IRevenueReward\n    IUserVaultFactory public userVaultFactory;\n    /// @inheritdoc IRevenueReward\n    address public rewardDistributor;\n\n    /// @inheritdoc IRevenueReward\n    mapping(address => bool) public isRewardToken;\n    /// @inheritdoc IRevenueReward\n    address[] public rewardTokens;\n    /// @inheritdoc IRevenueReward\n    mapping(address => uint256) public totalRewardsPerToken;\n    /// @inheritdoc IRevenueReward\n    mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\n\n    /// @inheritdoc IRevenueReward\n    mapping(address => mapping(uint256 => uint256)) public lastEarnTime;\n    /// @inheritdoc IRevenueReward\n    mapping(address => mapping(uint256 => uint256)) public tokenRewardsRemainingAccScaled;\n    /// @inheritdoc IRevenueReward\n    mapping(uint256 => uint256) public tokenMintTime;\n\n    /// @inheritdoc IRevenueReward\n    mapping(uint256 => address) public tokenRewardReceiver;\n    /// @dev Mapping of user addresses to their veNFT tokens with self-repaying loan enabled\n    mapping(address => EnumerableSet.UintSet) private userTokensWithSelfRepayingLoan;\n    /// @dev Set of user addresses with self-repaying loan enabled\n    EnumerableSet.AddressSet private usersWithSelfRepayingLoan;\n\n    // Storage gap for upgradeability\n    uint256[50] private __gap;\n\n    /*//////////////////////////////////////////////////////////////\n                           ACCESS CONTROL\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Modifier to check if the caller is the DustLock contract\n    modifier onlyDustLock() {\n        if (_msgSender() != address(dustLock)) revert NotDustLock();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRevenueReward\n    function setRewardDistributor(address newRewardDistributor) external override {\n        CommonChecksLibrary.revertIfZeroAddress(newRewardDistributor);\n        if (_msgSender() != rewardDistributor) revert NotRewardDistributor();\n\n        address old = rewardDistributor;\n        rewardDistributor = newRewardDistributor;\n\n        emit RewardDistributorUpdated(old, newRewardDistributor);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function notifyRewardAmount(address token, uint256 amount) external override nonReentrant {\n        CommonChecksLibrary.revertIfZeroAmount(amount);\n        CommonChecksLibrary.revertIfZeroAddress(token);\n        address sender = _msgSender();\n        if (sender != rewardDistributor) revert NotRewardDistributor();\n\n        if (!isRewardToken[token]) {\n            isRewardToken[token] = true;\n            rewardTokens.push(token);\n        }\n\n        totalRewardsPerToken[token] += amount;\n        IERC20(token).safeTransferFrom(sender, address(this), amount);\n\n        uint256 epochNext = EpochTimeLibrary.epochNext(block.timestamp);\n        tokenRewardsPerEpoch[token][epochNext] += amount;\n\n        emit NotifyReward(sender, token, epochNext, amount);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function recoverTokens() external override nonReentrant {\n        if (_msgSender() != rewardDistributor) revert NotRewardDistributor();\n\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; ++i) {\n            address token = rewardTokens[i];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            uint256 credited = totalRewardsPerToken[token];\n            if (balance > credited) {\n                uint256 unnotifiedTokenAmount = balance - credited;\n                IERC20(token).safeTransfer(rewardDistributor, unnotifiedTokenAmount);\n\n                emit RecoverTokens(token, unnotifiedTokenAmount);\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            NOTIFICATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRevenueReward\n    function notifyTokenMinted(uint256 tokenId) external override onlyDustLock {\n        tokenMintTime[tokenId] = block.timestamp;\n    }\n\n    /// @inheritdoc IRevenueReward\n    function notifyAfterTokenTransferred(uint256 tokenId, address from)\n        external\n        virtual\n        override\n        nonReentrant\n        onlyDustLock\n    {\n        _claimRewardsTo(tokenId, from);\n        _removeToken(tokenId, from);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function notifyAfterTokenBurned(uint256 tokenId, address from) external virtual override nonReentrant onlyDustLock {\n        _claimRewardsTo(tokenId, from);\n        _removeToken(tokenId, from);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function notifyAfterTokenMerged(uint256 fromToken, uint256 toToken, address owner)\n        external\n        override\n        nonReentrant\n        onlyDustLock\n    {\n        // Cannot use _resolveRewardsReceiver as fromToken doesn't exist anymore\n        address rewardsReceiver = tokenRewardReceiver[fromToken] == address(0) ? owner : tokenRewardReceiver[fromToken];\n        _claimRewardsTo(fromToken, rewardsReceiver);\n\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; ++i) {\n            tokenRewardsRemainingAccScaled[\n                rewardTokens[i]\n            ][toToken] += tokenRewardsRemainingAccScaled[rewardTokens[i]][fromToken];\n            tokenRewardsRemainingAccScaled[rewardTokens[i]][fromToken] = 0;\n        }\n\n        _removeToken(fromToken, owner);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function notifyAfterTokenSplit(\n        uint256 fromToken,\n        uint256 tokenId1,\n        uint256 token1Amount,\n        uint256 tokenId2,\n        uint256 token2Amount,\n        address owner\n    ) external override nonReentrant onlyDustLock {\n        // Cannot use _resolveRewardsReceiver as fromToken doesn't exist anymore\n        address rewardsReceiver = tokenRewardReceiver[fromToken] == address(0) ? owner : tokenRewardReceiver[fromToken];\n        _claimRewardsTo(fromToken, rewardsReceiver);\n\n        tokenMintTime[tokenId1] = block.timestamp;\n        tokenMintTime[tokenId2] = block.timestamp;\n\n        uint256 newTokenAmount = token1Amount + token2Amount;\n\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; ++i) {\n            uint256 acc = tokenRewardsRemainingAccScaled[rewardTokens[i]][fromToken];\n            if (acc != 0) {\n                uint256 a1 = Math.mulDiv(token1Amount, acc, newTokenAmount);\n                uint256 a2 = acc - a1;\n\n                tokenRewardsRemainingAccScaled[rewardTokens[i]][tokenId1] = a1;\n                tokenRewardsRemainingAccScaled[rewardTokens[i]][tokenId2] = a2;\n                tokenRewardsRemainingAccScaled[rewardTokens[i]][fromToken] = 0;\n            }\n        }\n\n        address receiverFromToken = tokenRewardReceiver[fromToken];\n        // If the original token had a reward receiver (self-repaying loan enabled),\n        // update both new tokens reward receivers and add both tokens to the tracking set\n        if (receiverFromToken != address(0)) {\n            tokenRewardReceiver[tokenId1] = receiverFromToken;\n            tokenRewardReceiver[tokenId2] = receiverFromToken;\n            userTokensWithSelfRepayingLoan[owner].add(tokenId1);\n            userTokensWithSelfRepayingLoan[owner].add(tokenId2);\n        }\n\n        _removeToken(fromToken, owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRevenueReward\n    function getReward(uint256 tokenId, address[] calldata tokens) external override {\n        getRewardUntilTs(tokenId, tokens, block.timestamp);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function getRewardBatch(uint256[] calldata tokenIds, address[] calldata tokens) external override {\n        getRewardUntilTsBatch(tokenIds, tokens, block.timestamp);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function getRewardUntilTs(uint256 tokenId, address[] calldata tokens, uint256 rewardPeriodEndTs)\n        public\n        virtual\n        override\n        nonReentrant\n    {\n        _validateTokensArray(tokens.length);\n        _getRewardUntilTsSingle(tokenId, tokens, rewardPeriodEndTs, _msgSender());\n    }\n\n    /// @inheritdoc IRevenueReward\n    function getRewardUntilTsBatch(uint256[] calldata tokenIds, address[] calldata tokens, uint256 rewardPeriodEndTs)\n        public\n        virtual\n        override\n        nonReentrant\n    {\n        _validateBatchArrays(tokens.length, tokenIds.length);\n\n        address sender = _msgSender();\n        uint256 len = tokenIds.length;\n        for (uint256 i = 0; i < len; ++i) {\n            _getRewardUntilTsSingle(tokenIds[i], tokens, rewardPeriodEndTs, sender);\n        }\n    }\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     * @param rewardPeriodEndTs The end timestamp to calculate rewards up to (must not be in the future)\n     * @param sender The address that called the function\n     */\n    function _getRewardUntilTsSingle(\n        uint256 tokenId,\n        address[] calldata tokens,\n        uint256 rewardPeriodEndTs,\n        address sender\n    ) internal {\n        address rewardsReceiver = _resolveRewardsReceiver(tokenId);\n        if (!dustLock.isApprovedOrOwner(sender, tokenId) && sender != rewardsReceiver) revert NotOwner();\n\n        _claimRewardsUntilTs(tokenId, rewardsReceiver, tokens, rewardPeriodEndTs);\n    }\n\n    /**\n     * @notice Claims accumulated rewards for a veNFT across all registered reward tokens up to now\n     * @dev Calculates earned rewards for each token using epoch-based accounting and transfers them to the receiver.\n     *      Emits a ClaimRewards event per token. Advances lastEarnTime to now only if there were epochs to process.\n     *      Copies `rewardTokens` (storage) to memory when passing to `_claimRewardsUntilTs`; no storage mutation.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param receiver The address to receive the rewards\n     */\n    function _claimRewardsTo(uint256 tokenId, address receiver) internal {\n        _claimRewardsUntilTs(tokenId, receiver, rewardTokens, block.timestamp);\n    }\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp\n     * @dev Calculates earned rewards for each specified token using epoch-based accounting and transfers them to the provided receiver.\n     *      Emits a ClaimRewards event per token. Updates lastEarnTime to rewardPeriodEndTs.\n     *      Reverts if rewardPeriodEndTs is in the future (via _earned).\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param receiver The address to receive the rewards\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     * @param rewardPeriodEndTs The end timestamp to calculate rewards up to (must not be in the future)\n     */\n    function _claimRewardsUntilTs(\n        uint256 tokenId,\n        address receiver,\n        address[] memory tokens,\n        uint256 rewardPeriodEndTs\n    ) internal {\n        uint256 len = tokens.length;\n        for (uint256 i = 0; i < len; ++i) {\n            address token = tokens[i];\n            if (!isRewardToken[token]) revert UnknownRewardToken();\n\n            EarnedResult memory _earnedResult = _earned(token, tokenId, rewardPeriodEndTs);\n\n            if (_earnedResult.success) {\n                lastEarnTime[token][tokenId] = rewardPeriodEndTs;\n                tokenRewardsRemainingAccScaled[token][tokenId] = _earnedResult.rewardRemainders;\n                if (_earnedResult.unclaimedRewards > 0) {\n                    IERC20(token).safeTransfer(receiver, _earnedResult.unclaimedRewards);\n                    emit ClaimRewards(tokenId, receiver, token, _earnedResult.unclaimedRewards);\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         SELF-REPAYING LOANS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRevenueReward\n    function enableSelfRepayLoan(uint256 tokenId) external virtual override nonReentrant {\n        _enableSelfRepayLoan(tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IRevenueReward\n    function enableSelfRepayLoanBatch(uint256[] calldata tokenIds) external override nonReentrant {\n        _validateTokenIdsArray(tokenIds.length);\n\n        address sender = _msgSender();\n        uint256 len = tokenIds.length;\n        for (uint256 i = 0; i < len; ++i) {\n            _enableSelfRepayLoan(tokenIds[i], sender);\n        }\n    }\n\n    /// @inheritdoc IRevenueReward\n    function disableSelfRepayLoan(uint256 tokenId) external virtual override nonReentrant {\n        _disableSelfRepayLoan(tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IRevenueReward\n    function disableSelfRepayLoanBatch(uint256[] calldata tokenIds) external override nonReentrant {\n        _validateTokenIdsArray(tokenIds.length);\n\n        address sender = _msgSender();\n        uint256 len = tokenIds.length;\n        for (uint256 i = 0; i < len; ++i) {\n            _disableSelfRepayLoan(tokenIds[i], sender);\n        }\n    }\n\n    /**\n     * @notice Enables self-repaying loan for a token\n     * @dev Enables self-repaying loan for a token\n     * @param tokenId The ID of the token to enable self-repaying loan for\n     * @param sender The address that called the function\n     */\n    function _enableSelfRepayLoan(uint256 tokenId, address sender) internal {\n        if (sender != dustLock.ownerOf(tokenId)) revert NotOwner();\n\n        address userVault = userVaultFactory.getOrCreateUserVault(sender);\n\n        tokenRewardReceiver[tokenId] = userVault;\n        usersWithSelfRepayingLoan.add(sender);\n        userTokensWithSelfRepayingLoan[sender].add(tokenId);\n\n        emit SelfRepayingLoanUpdate(tokenId, userVault, true);\n    }\n\n    /**\n     * @notice Disables self-repaying loan for a token\n     * @param tokenId The ID of the token to disable self-repaying loan for\n     * @param sender The address that called the function\n     */\n    function _disableSelfRepayLoan(uint256 tokenId, address sender) internal {\n        address tokenOwner = dustLock.ownerOf(tokenId);\n        if (sender != tokenOwner) revert NotOwner();\n\n        _removeToken(tokenId, tokenOwner);\n\n        emit SelfRepayingLoanUpdate(tokenId, address(0), false);\n    }\n\n    /**\n     * @notice Removes a token from the self-repaying loan list\n     * @param tokenId The ID of the token to remove\n     * @param tokenOwner The owner of the token\n     */\n    function _removeToken(uint256 tokenId, address tokenOwner) internal {\n        tokenRewardReceiver[tokenId] = address(0);\n        userTokensWithSelfRepayingLoan[tokenOwner].remove(tokenId);\n        if (userTokensWithSelfRepayingLoan[tokenOwner].length() == 0) {\n            usersWithSelfRepayingLoan.remove(tokenOwner);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ARRAY VALIDATION\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Validates array lengths for single token operations\n     * @param tokensLength Length of tokens array\n     */\n    function _validateTokensArray(uint256 tokensLength) private pure {\n        if (tokensLength == 0 || tokensLength > MAX_TOKENS) revert InvalidArrayLengths();\n    }\n\n    /**\n     * @notice Validates tokenIds array is not empty\n     * @param tokenIdsLength Length of tokenIds array\n     */\n    function _validateTokenIdsArray(uint256 tokenIdsLength) private pure {\n        if (tokenIdsLength == 0) revert InvalidArrayLengths();\n    }\n\n    /**\n     * @notice Validates array lengths for batch operations\n     * @param tokensLength Length of tokens array\n     * @param tokenIdsLength Length of tokenIds array\n     */\n    function _validateBatchArrays(uint256 tokensLength, uint256 tokenIdsLength) private pure {\n        if (tokensLength == 0 || tokenIdsLength == 0 || tokensLength > MAX_TOKENS || tokenIdsLength > MAX_TOKENIDS) {\n            revert InvalidArrayLengths();\n        }\n    }\n\n    /**\n     * @notice Validates that an address array is sorted in ascending order without duplicates\n     * @dev Reverts if the array contains duplicates or is not sorted in ascending order\n     * @param arr The address array to validate\n     */\n    function _validateUniqueArray(address[] calldata arr) private pure {\n        uint256 len = arr.length;\n        for (uint256 i = 1; i < len; ++i) {\n            if (arr[i] <= arr[i - 1]) revert ArrayNotSortedOrContainsDuplicates();\n        }\n    }\n\n    /**\n     * @notice Validates that a uint256 array is sorted in ascending order without duplicates\n     * @dev Reverts if the array contains duplicates or is not sorted in ascending order\n     * @param arr The uint256 array to validate\n     */\n    function _validateUniqueArray(uint256[] calldata arr) private pure {\n        uint256 len = arr.length;\n        for (uint256 i = 1; i < len; ++i) {\n            if (arr[i] <= arr[i - 1]) revert ArrayNotSortedOrContainsDuplicates();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRevenueReward\n    function earnedRewardsAll(address[] calldata tokens, uint256[] calldata tokenIds)\n        external\n        view\n        override\n        returns (uint256[][] memory matrix, uint256[] memory totals)\n    {\n        return earnedRewardsAllUntilTs(tokens, tokenIds, block.timestamp);\n    }\n\n    /// @inheritdoc IRevenueReward\n    function earnedRewardsAllUntilTs(address[] calldata tokens, uint256[] calldata tokenIds, uint256 endTs)\n        public\n        view\n        override\n        returns (uint256[][] memory matrix, uint256[] memory totals)\n    {\n        _validateUniqueArray(tokens);\n        _validateUniqueArray(tokenIds);\n        uint256 numTokens = tokens.length;\n        uint256 numTokenIds = tokenIds.length;\n        _validateBatchArrays(numTokens, numTokenIds);\n\n        totals = new uint256[](numTokens);\n        matrix = new uint256[][](numTokenIds);\n        for (uint256 i = 0; i < numTokenIds; ++i) {\n            uint256 tokenId = tokenIds[i];\n            uint256[] memory row = new uint256[](numTokens);\n            for (uint256 j = 0; j < numTokens; ++j) {\n                address token = tokens[j];\n                uint256 amount = earnedRewards(token, tokenId, endTs);\n                row[j] = amount;\n                totals[j] += amount;\n            }\n            matrix[i] = row;\n        }\n    }\n\n    /// @inheritdoc IRevenueReward\n    function earnedRewards(address token, uint256 tokenId, uint256 endTs) public view override returns (uint256) {\n        if (!isRewardToken[token]) revert UnknownRewardToken();\n\n        EarnedResult memory earnedResult = _earned(token, tokenId, endTs);\n        return earnedResult.unclaimedRewards;\n    }\n\n    /// @inheritdoc IRevenueReward\n    function rewardTokensLength() external view override returns (uint256) {\n        return rewardTokens.length;\n    }\n\n    /// @inheritdoc IRevenueReward\n    function getRewardTokens() external view override returns (address[] memory tokens) {\n        return rewardTokens;\n    }\n\n    /// @inheritdoc IRevenueReward\n    function getUsersWithSelfRepayingLoan(uint256 from, uint256 to) external view override returns (address[] memory) {\n        CommonChecksLibrary.revertIfInvalidRange(from, to);\n\n        uint256 len = usersWithSelfRepayingLoan.length();\n        if (from >= len) return new address[](0);\n        if (to > len) to = len;\n\n        uint256 resLen = to - from;\n        address[] memory users = new address[](resLen);\n        for (uint256 i = 0; i < resLen; ++i) {\n            users[i] = usersWithSelfRepayingLoan.at(from + i);\n        }\n        return users;\n    }\n\n    /// @inheritdoc IRevenueReward\n    function getUserTokensWithSelfRepayingLoan(address user)\n        external\n        view\n        override\n        returns (uint256[] memory tokenIds)\n    {\n        uint256 len = userTokensWithSelfRepayingLoan[user].length();\n        tokenIds = new uint256[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            tokenIds[i] = userTokensWithSelfRepayingLoan[user].at(i);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MATH / INTERNALS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Result structure for reward calculations\n     * @param unclaimedRewards Total amount of rewards ready to be claimed by the user\n     * @param rewardRemainders Scaled fractional remainders carried forward for future accumulation\n     * @param success Flag indicating whether the reward calculation was successful\n     */\n    struct EarnedResult {\n        uint256 unclaimedRewards;\n        uint256 rewardRemainders;\n        bool success;\n    }\n\n    /**\n     * @notice Calculates and accrues rewards from the last claim (or mint) up to `endTs`\n     * @dev Uses epoch-based accounting to prevent reward manipulation:\n     *      1. Iterates all epochs between the last processed time and `endTs`\n     *      2. For each epoch, computes whole-token rewards and fractional remainders\n     *      3. Accumulates whole rewards immediately and carries fractional remainders\n     *         forward in a scaled accumulator for future realization\n     * @param token The reward token address to calculate earnings for\n     * @param tokenId The ID of the veNFT to calculate earnings for\n     * @param endTs Timestamp of the end duration that token rewards are calculated up to\n     * @return EarnedResult struct containing unclaimedRewards, rewardRemainders, and success flag\n     */\n    function _earned(address token, uint256 tokenId, uint256 endTs) internal view returns (EarnedResult memory) {\n        if (endTs > block.timestamp) revert EndTimestampMoreThanCurrent();\n\n        uint256 lastTokenEarnTime = Math.max(lastEarnTime[token][tokenId], tokenMintTime[tokenId]);\n        uint256 startTs = EpochTimeLibrary.epochNext(lastTokenEarnTime);\n        uint256 endTsEpoch = EpochTimeLibrary.epochStart(endTs);\n        if (startTs > endTsEpoch) return EarnedResult(0, 0, false);\n\n        uint256 currTs = startTs;\n        uint256 accumulatedReward = 0;\n        uint256 accumulatedRemainder = tokenRewardsRemainingAccScaled[token][tokenId];\n\n        uint256 numEpochs = (endTsEpoch - startTs) / DURATION;\n        for (uint256 i = 0; i <= numEpochs; ++i) {\n            uint256 tokenSupplyBalanceCurrTs = dustLock.totalSupplyAt(currTs);\n            if (tokenSupplyBalanceCurrTs == 0) {\n                currTs += DURATION;\n                continue;\n            }\n\n            (uint256 rewardAmount, uint256 scaledRemainder) =\n                _calculateEpochReward(token, tokenId, currTs, tokenSupplyBalanceCurrTs);\n            accumulatedReward += rewardAmount;\n            accumulatedRemainder += scaledRemainder;\n            currTs += DURATION;\n        }\n\n        uint256 rewardFromRemaining = accumulatedRemainder / REWARDS_REMAINING_SCALE;\n        uint256 newRemainder = accumulatedRemainder - rewardFromRemaining * REWARDS_REMAINING_SCALE;\n\n        return EarnedResult(accumulatedReward + rewardFromRemaining, newRemainder, true);\n    }\n\n    /**\n     * @notice Calculates reward for a single epoch with overflow protection\n     * @param token The reward token address\n     * @param tokenId The veNFT token ID\n     * @param epochTs The epoch timestamp\n     * @param totalSupply Total voting power supply at the epoch\n     * @return rewardAmount The whole-token reward amount for this epoch\n     * @return scaledRemainder The scaled fractional remainder to accumulate\n     */\n    function _calculateEpochReward(address token, uint256 tokenId, uint256 epochTs, uint256 totalSupply)\n        internal\n        view\n        returns (uint256 rewardAmount, uint256 scaledRemainder)\n    {\n        uint256 rewardsThisEpoch = tokenRewardsPerEpoch[token][epochTs];\n        uint256 userBalanceThisEpoch = dustLock.balanceOfNFTAt(tokenId, epochTs);\n\n        // whole units: floor(rewardsThisEpoch * userBalanceThisEpoch / totalSupply)\n        rewardAmount = Math.mulDiv(rewardsThisEpoch, userBalanceThisEpoch, totalSupply);\n\n        // fractional remainder scaled\n        uint256 remainder = mulmod(rewardsThisEpoch, userBalanceThisEpoch, totalSupply);\n        scaledRemainder = Math.mulDiv(remainder, REWARDS_REMAINING_SCALE, totalSupply);\n    }\n\n    /**\n     * @notice Resolves the rewards receiver for a given tokenId\n     * @dev Prefers the configured tokenRewardReceiver; falls back to current owner (ownerOf reverts if token doesn't exist)\n     * @param tokenId The veNFT token id to resolve the receiver for\n     * @return receiver The address that should receive rewards\n     */\n    function _resolveRewardsReceiver(uint256 tokenId) internal view returns (address receiver) {\n        receiver = tokenRewardReceiver[tokenId];\n        if (receiver == address(0)) receiver = dustLock.ownerOf(tokenId);\n    }\n}\n",
        "keccak256": "0xb6464041119e57eb472e1a3beae20508620fe7568064dc1f0d827dab24ca554f",
        "license": "BUSL-1.1"
      }
    },
    "version": 1
  },
  "proxy": "0xff20ac10eb808B1e31F5CfCa58D80eDE2Ba71c43",
  "implementation": "0x1df0F25344D29F541a53502a96DfeD3066D40b0A",
  "proxyAdmin": "0x6400650cED1eD7179143D40b4431c3cC8c068D90"
}