{
  "networkName": "monadMainnet",
  "chainId": 143,
  "contract": "UserVaultFactory",
  "metadata": {
    "compiler": {
      "version": "0.8.30+commit.73712a01"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [],
          "name": "AddressZero",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            }
          ],
          "name": "Initialized",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "vault",
              "type": "address"
            }
          ],
          "name": "UserVaultCreated",
          "type": "event"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getOrCreateUserVault",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getUserVault",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userVaultBeacon",
              "type": "address"
            },
            {
              "internalType": "contract IUserVaultRegistry",
              "name": "_userVaultRegistry",
              "type": "address"
            },
            {
              "internalType": "contract IPoolAddressesProviderRegistry",
              "name": "_poolAddressesProviderRegistry",
              "type": "address"
            },
            {
              "internalType": "contract IRevenueReward",
              "name": "_revenueReward",
              "type": "address"
            }
          ],
          "name": "initialize",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "poolAddressesProviderRegistry",
          "outputs": [
            {
              "internalType": "contract IPoolAddressesProviderRegistry",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "revenueReward",
          "outputs": [
            {
              "internalType": "contract IRevenueReward",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "userVaultRegistry",
          "outputs": [
            {
              "internalType": "contract IUserVaultRegistry",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "devdoc": {
        "author": "Neverland",
        "events": {
          "Initialized(uint8)": {
            "details": "Triggered when the contract has been initialized or reinitialized."
          },
          "UserVaultCreated(address,address)": {
            "params": {
              "user": "The user for whom the vault was created",
              "vault": "The address of the created vault"
            }
          }
        },
        "kind": "dev",
        "methods": {
          "getOrCreateUserVault(address)": {
            "details": "If the vault does not exist, returns address(0)",
            "params": {
              "user": "The address of the user whose vault is being queried or created"
            },
            "returns": {
              "_0": "The address of the user's vault"
            }
          },
          "getUserVault(address)": {
            "details": "If the vault does not exist, a new BeaconProxy is deployed and initialized for the user",
            "params": {
              "user": "The address of the user whose vault is being queried or created"
            },
            "returns": {
              "_0": "The address of the user's vault"
            }
          },
          "initialize(address,address,address,address)": {
            "params": {
              "_poolAddressesProviderRegistry": "AAVE PoolAddressesProviderRegistry contract",
              "_revenueReward": "RevenueReward contract",
              "_userVaultBeacon": "Address of the UserVault beacon",
              "_userVaultRegistry": "UserVaultRegistry contract"
            }
          }
        },
        "title": "UserVaultFactory",
        "version": 1
      },
      "userdoc": {
        "errors": {
          "AddressZero()": [
            {
              "notice": "Used when a zero address is provided where not allowed."
            }
          ]
        },
        "events": {
          "UserVaultCreated(address,address)": {
            "notice": "Emitted when a new user vault is created"
          }
        },
        "kind": "user",
        "methods": {
          "getOrCreateUserVault(address)": {
            "notice": "Returns the vault address for a given user if it exists"
          },
          "getUserVault(address)": {
            "notice": "Returns the vault address for a given user. Creates a new vault if none exists"
          },
          "initialize(address,address,address,address)": {
            "notice": "Initializes the contract"
          },
          "poolAddressesProviderRegistry()": {
            "notice": "AAVE PoolAddressesProviderRegistry contract"
          },
          "revenueReward()": {
            "notice": "RevenueReward contract"
          },
          "userVaultRegistry()": {
            "notice": "UserVaultRegistry contract"
          }
        },
        "notice": "Factory contract for creating UserVault instances",
        "version": 1
      }
    },
    "settings": {
      "compilationTarget": {
        "src/self-repaying-loans/UserVaultFactory.sol": "UserVaultFactory"
      },
      "evmVersion": "paris",
      "libraries": {},
      "metadata": {
        "bytecodeHash": "none",
        "useLiteralContent": true
      },
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "remappings": []
    },
    "sources": {
      "@aave/core-v3/contracts/interfaces/IAaveOracle.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n",
        "keccak256": "0x15942c0df4ce9f50a9cf172c9ed0efa0abbf841cd8560fbd0da3d6a7dea69a96",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/interfaces/IPool.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n",
        "keccak256": "0xbfd2077251c8dc766a56d45f4b03eb07f3441323e79c0f794efea3657a99747f",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n",
        "keccak256": "0x33d4308d9407b4ee2297fc4ba5acce1a96a6c658189e2778a4f6b90e032fb3b5",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/interfaces/IPoolAddressesProviderRegistry.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProviderRegistry\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool Addresses Provider Registry.\n */\ninterface IPoolAddressesProviderRegistry {\n  /**\n   * @dev Emitted when a new AddressesProvider is registered.\n   * @param addressesProvider The address of the registered PoolAddressesProvider\n   * @param id The id of the registered PoolAddressesProvider\n   */\n  event AddressesProviderRegistered(address indexed addressesProvider, uint256 indexed id);\n\n  /**\n   * @dev Emitted when an AddressesProvider is unregistered.\n   * @param addressesProvider The address of the unregistered PoolAddressesProvider\n   * @param id The id of the unregistered PoolAddressesProvider\n   */\n  event AddressesProviderUnregistered(address indexed addressesProvider, uint256 indexed id);\n\n  /**\n   * @notice Returns the list of registered addresses providers\n   * @return The list of addresses providers\n   */\n  function getAddressesProvidersList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the id of a registered PoolAddressesProvider\n   * @param addressesProvider The address of the PoolAddressesProvider\n   * @return The id of the PoolAddressesProvider or 0 if is not registered\n   */\n  function getAddressesProviderIdByAddress(\n    address addressesProvider\n  ) external view returns (uint256);\n\n  /**\n   * @notice Returns the address of a registered PoolAddressesProvider\n   * @param id The id of the market\n   * @return The address of the PoolAddressesProvider with the given id or zero address if it is not registered\n   */\n  function getAddressesProviderAddressById(uint256 id) external view returns (address);\n\n  /**\n   * @notice Registers an addresses provider\n   * @dev The PoolAddressesProvider must not already be registered in the registry\n   * @dev The id must not be used by an already registered PoolAddressesProvider\n   * @param provider The address of the new PoolAddressesProvider\n   * @param id The id for the new PoolAddressesProvider, referring to the market it belongs to\n   */\n  function registerAddressesProvider(address provider, uint256 id) external;\n\n  /**\n   * @notice Removes an addresses provider from the list of registered addresses providers\n   * @param provider The PoolAddressesProvider address\n   */\n  function unregisterAddressesProvider(address provider) external;\n}\n",
        "keccak256": "0x71ae9fcb634382141cce4c138230280f50b98fc47ba1d90cbc2d15ef8224fab1",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/interfaces/IPriceOracleGetter.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n",
        "keccak256": "0xfe72e94869ca91465a7f57282b8d367b2c9ba798fdc13ac8546304db8d971df6",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n",
        "keccak256": "0x771cb99fd8519c974f7e12130387c4d9a997a6e8d0ac10e4303b842fe53efa88",
        "license": "BUSL-1.1"
      },
      "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n",
        "keccak256": "0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n",
        "keccak256": "0x2025ccf05f6f1f2fd4e078e552836f525a1864e3854ed555047cd732320ab29b",
        "license": "MIT"
      },
      "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "keccak256": "0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n",
        "keccak256": "0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC1967.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n",
        "keccak256": "0x3cbef5ebc24b415252e2f8c0c9254555d30d9f085603b4b80d9b5ed20ab87e90",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC4906.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n",
        "keccak256": "0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC6372.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n",
        "keccak256": "0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n",
        "keccak256": "0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n",
        "keccak256": "0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff",
        "license": "MIT"
      },
      "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n",
        "keccak256": "0x3b21ae06bf5957f73fa16754b0669c77b7abd8ba6c072d35c3281d446fdb86c2",
        "license": "MIT"
      },
      "@openzeppelin/contracts/proxy/Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n",
        "keccak256": "0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27",
        "license": "MIT"
      },
      "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n",
        "keccak256": "0x85439e74ab467b6a23d45d32bdc9506cbc3760320289afd605f11638c4138e95",
        "license": "MIT"
      },
      "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n",
        "keccak256": "0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61",
        "license": "MIT"
      },
      "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n",
        "keccak256": "0x3d6069be9b4c01fb81840fb9c2c4dc58dd6a6a4aafaa2c6837de8699574d84c6",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n",
        "keccak256": "0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n",
        "keccak256": "0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
        "keccak256": "0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n",
        "keccak256": "0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n",
        "keccak256": "0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
        "keccak256": "0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "keccak256": "0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n",
        "keccak256": "0xf09e68aa0dc6722a25bc46490e8d48ed864466d17313b8a0b254c36b54e49899",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
        "keccak256": "0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1",
        "license": "MIT"
      },
      "src/interfaces/IDustLock.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {IRevenueReward} from \"./IRevenueReward.sol\";\n\n/**\n * @title IDustLock Interface\n * @notice Interface for the DustLock contract that manages voting escrow NFTs (veNFTs)\n * @dev Combines ERC721 with vote-escrow functionality for governance and reward distribution\n */\ninterface IDustLock is IERC4906, IERC6372, IERC721Metadata {\n    /**\n     * @notice Structure representing a locked token position\n     * @dev Used to track the amount of tokens locked, when they unlock, and if they're permanently locked\n     * @param amount Amount of tokens locked in int256 format for consistency with precision calculations\n     * @param effectiveStart Effective start time for penalty calculations (weighted average on lock operations)\n     * @param end Timestamp when tokens unlock (0 for permanent locks)\n     * @param isPermanent Whether this is a permanent lock that cannot be withdrawn normally\n     */\n    struct LockedBalance {\n        int256 amount;\n        uint256 effectiveStart;\n        uint256 end;\n        bool isPermanent;\n    }\n\n    /**\n     * @notice Checkpoint for tracking user voting power at a specific point in time\n     * @dev Used in the vote-escrow system to track decay of voting power over time\n     * @param bias Voting power at time ts\n     * @param slope Rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanent Amount of permanent (non-decaying) voting power\n     */\n    struct UserPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanent;\n    }\n\n    /**\n     * @notice Global checkpoint for tracking total voting power at a specific point in time\n     * @dev Similar to UserPoint but tracks system-wide totals\n     * @param bias Total voting power at time ts\n     * @param slope Total rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanentLockBalance Total amount of permanently locked tokens\n     */\n    struct GlobalPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanentLockBalance;\n    }\n\n    /**\n     * @notice Types of deposit operations supported by the veNFT system\n     * @param DEPOSIT_FOR_TYPE Adding tokens to an existing lock owned by someone else\n     * @param CREATE_LOCK_TYPE Creating a new lock position\n     * @param INCREASE_LOCK_AMOUNT Adding more tokens to an existing lock\n     * @param INCREASE_UNLOCK_TIME Extending the lock duration of an existing lock\n     */\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /// @notice Error thrown when the locked amount is less than minLockAmount\n    error AmountTooSmall();\n\n    /// @notice Error thrown when the requested amount exceeds available balance\n    error AmountTooBig();\n\n    /// @notice Error thrown when an ERC721 receiver contract rejects the tokens\n    error ERC721ReceiverRejectedTokens();\n\n    /// @notice Error thrown when transferring to an address that doesn't implement ERC721Receiver\n    error ERC721TransferToNonERC721ReceiverImplementer();\n\n    /// @notice Error thrown when an early withdraw penalty value is invalid (>=10000)\n    error InvalidWithdrawPenalty();\n\n    /// @notice Error thrown when the lock duration doesn't extend beyond the current time\n    error LockDurationNotInFuture();\n\n    /// @notice Error thrown when the lock duration exceeds the maximum allowed time\n    error LockDurationTooLong();\n\n    /// @notice Error thrown when the lock duration is less than the minimum required time\n    error LockDurationTooShort();\n\n    /// @notice Error thrown when trying to depositFor to a lock expiring within MINTIME\n    error DepositForLockDurationTooShort();\n\n    /// @notice Error thrown when trying to perform an operation on an expired lock\n    error LockExpired();\n\n    /// @notice Error thrown when trying to withdraw from a lock that hasn't expired yet\n    error LockNotExpired();\n\n    /// @notice Error thrown when no lock is found for the specified token ID\n    error NoLockFound();\n\n    /// @notice Error thrown when the caller is neither the owner nor approved for the token\n    error NotApprovedOrOwner();\n\n    /// @notice Error thrown when trying to unlock a non-permanent lock using unlockPermanent\n    error NotPermanentLock();\n\n    /// @notice Error thrown when the caller is not the owner of the token\n    error NotOwner();\n\n    /// @notice Error thrown when a team-only function is called by a non-team address\n    error NotTeam();\n\n    /// @notice Error thrown when a pending team function is called by a non-pending team address\n    error NotPendingTeam();\n\n    /// @notice Error thrown when trying to withdraw or modify a permanent lock\n    error PermanentLock();\n\n    /// @notice Error thrown when attempting to merge a veNFT with itself\n    error SameNFT();\n\n    /// @notice Error thrown when splitting is not allowed for the user\n    error SplitNotAllowed();\n\n    /// @notice Error thrown when trying to add a token that already has an owner\n    error AlreadyOwned();\n\n    /// @notice Error thrown when setting a revenue reward contract that is not a deployed contract\n    error InvalidRevenueRewardContract();\n\n    /**\n     * @notice Emitted when tokens are deposited into the veNFT system\n     * @param provider Address depositing the tokens\n     * @param tokenId ID of the veNFT being created or modified\n     * @param depositType Type of deposit operation (create, increase amount, etc.)\n     * @param value Amount of tokens deposited\n     * @param locktime Timestamp when the lock expires\n     * @param ts Timestamp when the deposit occurred\n     */\n    event Deposit(\n        address indexed provider,\n        uint256 indexed tokenId,\n        DepositType indexed depositType,\n        uint256 value,\n        uint256 locktime,\n        uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn before the lock expiry with a penalty\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Original locked amount\n     * @param amountReturned Amount returned to the user after penalty\n     * @param ts Timestamp when the early withdrawal occurred\n     */\n    event EarlyWithdraw(\n        address indexed provider, uint256 indexed tokenId, uint256 value, uint256 amountReturned, uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn after the lock expiry\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Amount of tokens withdrawn\n     * @param ts Timestamp when the withdrawal occurred\n     */\n    event Withdraw(address indexed provider, uint256 indexed tokenId, uint256 value, uint256 ts);\n\n    /**\n     * @notice Emitted when a lock is converted to a permanent lock\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being locked permanently\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was created\n     */\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when a permanent lock is unlocked by governance\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being unlocked\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was unlocked\n     */\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when the total supply of locked tokens changes\n     * @param prevSupply Previous total locked supply\n     * @param supply New total locked supply\n     */\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    /**\n     * @notice Emitted when two veNFTs are merged\n     * @param _sender Address initiating the merge\n     * @param _from Source veNFT ID (burned in the process)\n     * @param _to Destination veNFT ID (receives combined balance)\n     * @param _amountFrom Amount of tokens in the source veNFT\n     * @param _amountTo Amount of tokens in the destination veNFT before merge\n     * @param _amountFinal Final amount of tokens in the destination veNFT after merge\n     * @param _locktime New lock expiry time for the merged veNFT\n     * @param _ts Timestamp when the merge occurred\n     */\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a veNFT is split into two separate veNFTs\n     * @param _from Original veNFT ID being split (burned in the process)\n     * @param _tokenId1 First new veNFT ID created from the split\n     * @param _tokenId2 Second new veNFT ID created from the split\n     * @param _sender Address initiating the split\n     * @param _splitAmount1 Amount of tokens allocated to the first veNFT\n     * @param _splitAmount2 Amount of tokens allocated to the second veNFT\n     * @param _locktime Lock expiry time for both new veNFTs\n     * @param _ts Timestamp when the split occurred\n     */\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a new team address is proposed\n     * @param currentTeam The current team address that proposed the change\n     * @param proposedTeam The newly proposed team address\n     */\n    event TeamProposed(address indexed currentTeam, address indexed proposedTeam);\n\n    /**\n     * @notice Emitted when a proposed team address accepts ownership\n     * @param oldTeam The previous team address\n     * @param newTeam The new team address that accepted ownership\n     */\n    event TeamAccepted(address indexed oldTeam, address indexed newTeam);\n\n    /**\n     * @notice Emitted when a team proposal is cancelled\n     * @param currentTeam The current team address that cancelled the proposal\n     * @param cancelledTeam The proposed team address that was cancelled\n     */\n    event TeamProposalCancelled(address indexed currentTeam, address indexed cancelledTeam);\n\n    /**\n     * @notice Emitted when the early withdraw penalty is updated\n     * @param oldPenalty Previous penalty in basis points\n     * @param newPenalty New penalty in basis points\n     */\n    event EarlyWithdrawPenaltyUpdated(uint256 oldPenalty, uint256 newPenalty);\n\n    /**\n     * @notice Emitted when the early withdraw treasury address is updated\n     * @param oldTreasury Previous treasury address\n     * @param newTreasury New treasury address\n     */\n    event EarlyWithdrawTreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Emitted when the minimum lock amount is updated\n     * @param oldAmount Previous minimum lock amount\n     * @param newAmount New minimum lock amount\n     */\n    event MinLockAmountUpdated(uint256 oldAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted when the revenue reward contract is updated\n     * @param oldReward Previous revenue reward contract address\n     * @param newReward New revenue reward contract address\n     */\n    event RevenueRewardUpdated(address indexed oldReward, address indexed newReward);\n\n    /**\n     * @notice Emitted when the split permission is toggled for an account\n     * @param account Address whose permission is updated\n     * @param allowed Whether splitting is now allowed for the account\n     */\n    event SplitPermissionUpdated(address indexed account, bool allowed);\n\n    /**\n     * @notice Emitted when the base URI is updated\n     * @param oldBaseURI Previous base URI\n     * @param newBaseURI New base URI\n     */\n    event BaseURIUpdated(string oldBaseURI, string newBaseURI);\n\n    /*//////////////////////////////////////////////////////////////\n                                STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Address of Meta-tx Forwarder\n     * @return The trusted forwarder address used for meta-transactions\n     */\n    function forwarder() external view returns (address);\n\n    /**\n     * @notice Address of token (DUST) used to create a veNFT\n     * @return The ERC20 token address used to lock and mint veNFTs\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Address of Neverland Team multisig\n     * @return The address of the current team multisig with administrative privileges\n     */\n    function team() external view returns (address);\n\n    /**\n     * @notice Address of pending team for two-step ownership transfer\n     * @return The address of the pending team, or address(0) if no proposal exists\n     */\n    function pendingTeam() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Proposes a new team address for two-step ownership transfer\n     * @dev This is the first step of a two-step ownership transfer process.\n     *      Only the current team can propose a new team address.\n     *      The proposed address must accept ownership to complete the transfer.\n     *      This prevents accidental loss of admin control due to typos or wrong addresses.\n     * @param _newTeam The address of the proposed new team multisig\n     */\n    function proposeTeam(address _newTeam) external;\n\n    /**\n     * @notice Accepts the proposed team address to complete the ownership transfer\n     * @dev This is the second step of the two-step ownership transfer process.\n     *      Only the pending team address can call this function.\n     *      Once called, the caller becomes the new team and the pending team is cleared.\n     *      This ensures that the new team controls the proposed address.\n     */\n    function acceptTeam() external;\n\n    /**\n     * @notice Cancels the pending team proposal\n     * @dev Allows the current team to cancel a pending ownership transfer.\n     *      Only the current team can call this function.\n     *      This is useful if the team made an error in the proposed address.\n     *      After cancellation, a new proposal can be made.\n     */\n    function cancelTeamProposal() external;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the name of the token\n     * @return The name of the veNFT token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token\n     * @return The symbol of the veNFT token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns the version of the contract\n     * @return The current version string of the contract\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice Updates the base URI for computing tokenURI\n     * @dev Can only be called by the team address\n     * @param newBaseURI The new base URI to set for all tokens\n     */\n    function setBaseURI(string memory newBaseURI) external;\n\n    /**\n     * @notice Current total count of veNFT tokens\n     * @dev Used as a counter for minting new tokens and assigning IDs\n     * @return The current highest token ID value\n     */\n    function tokenId() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the tokenId owned by `_owner` at position `_index`\n     * @param _owner Owner address to query\n     * @param _index Index of the token within the owner's list\n     * @return _tokenId The tokenId at the given index for the owner\n     */\n    function ownerToNFTokenIdList(address _owner, uint256 _index) external view returns (uint256 _tokenId);\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @notice Check whether spender is owner or an approved user for a given veNFT\n     * @param _spender The address to approve for the tokenId\n     * @param _tokenId The ID of the veNFT to be approved\n     * @return True if `_spender` is owner or approved for `_tokenId`, false otherwise\n     */\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Total count of epochs witnessed since contract creation\n     * @return The current epoch number\n     */\n    function epoch() external view returns (uint256);\n\n    /**\n     * @notice Total amount of tokens currently locked in the contract\n     * @return The total supply of locked tokens\n     */\n    function supply() external view returns (uint256);\n\n    /**\n     * @notice Aggregate balance of permanently locked tokens\n     * @dev These tokens cannot be withdrawn through normal means\n     * @return The total amount of permanently locked tokens\n     */\n    function permanentLockBalance() external view returns (uint256);\n\n    /**\n     * @notice Percentage of penalty applied to early withdrawals (in basis points)\n     * @dev Value is between 0 and 10000 (0% to 100%)\n     * @return The current penalty percentage in basis points\n     */\n    function earlyWithdrawPenalty() external view returns (uint256);\n\n    /**\n     * @notice Address that receives penalty fees from early withdrawals\n     * @return The address of the treasury that collects early withdrawal penalties\n     */\n    function earlyWithdrawTreasury() external view returns (address);\n\n    /**\n     * @notice Get the current epoch number for a specific veNFT\n     * @param _tokenId The ID of the veNFT to check\n     * @return _epoch The current epoch number for the specified veNFT\n     */\n    function userPointEpoch(uint256 _tokenId) external view returns (uint256 _epoch);\n\n    /**\n     * @notice Retrieve the scheduled slope change at a given timestamp\n     * @dev Used to calculate future voting power changes due to lock expirations\n     * @param _timestamp The timestamp to check for slope changes\n     * @return The net change in slope (negative value means decrease in voting power)\n     */\n    function slopeChanges(uint256 _timestamp) external view returns (int256);\n\n    /**\n     * @notice Check if an account has permission to split veNFTs\n     * @dev Used to control which addresses can perform veNFT splitting operations\n     * @param _account The address to check for split permission\n     * @return True if the account can split veNFTs, false otherwise\n     */\n    function canSplit(address _account) external view returns (bool);\n\n    /**\n     * @notice Retrieve a global checkpoint at a specific index\n     * @dev Used to track historical voting power across all tokens at different points in time\n     * @param _loc The index of the checkpoint to retrieve\n     * @return The GlobalPoint data at the specified index\n     */\n    function pointHistory(uint256 _loc) external view returns (GlobalPoint memory);\n\n    /**\n     * @notice Get the lock details for a specific veNFT\n     * @dev Returns information about lock amount, end time, and permanent status\n     * @param _tokenId The ID of the veNFT to query\n     * @return The LockedBalance struct containing lock information\n     */\n    function locked(uint256 _tokenId) external view returns (LockedBalance memory);\n\n    /**\n     * @notice Retrieve a user checkpoint for a specific veNFT at a given index\n     * @dev Used to track historical voting power for individual tokens\n     * @param _tokenId The ID of the veNFT to query\n     * @param _loc The index of the user checkpoint to retrieve\n     * @return The UserPoint data at the specified index for the given token\n     */\n    function userPointHistory(uint256 _tokenId, uint256 _loc) external view returns (UserPoint memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Create a global checkpoint to record the current state of voting power\n     * @dev Updates the global point history with current voting power data\n     *      This is called automatically by most state-changing functions\n     *      but can be called manually to ensure up-to-date on-chain data\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT lock\n     * @dev Anyone (even a smart contract) can deposit tokens for someone else's lock\n     *      The deposit increases the lock amount but does not extend the lock time\n     *      Cannot be used for locks that have already expired\n     * @param _tokenId The ID of the veNFT to deposit for\n     * @param _value Amount of tokens to add to the existing lock\n     */\n    function depositFor(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Create a new lock by depositing tokens for the caller\n     * @dev Creates a new veNFT representing the locked tokens\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return The ID of the newly created veNFT\n     */\n    function createLock(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock by depositing tokens for another address\n     * @dev Creates a new veNFT representing the locked tokens and assigns it to the specified recipient\n     *      This is useful for protocols that want to create locks on behalf of their users\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return The ID of the newly created veNFT\n     */\n    function createLockFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for the caller and immediately make it permanent\n     * @dev UX convenience to perform \"create lock\" and \"make permanent\" in a single transaction\n     *      Follows the same validation as `createLock` (min amount, duration bounds, week rounding)\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanent(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for `to` and immediately make it permanent\n     * @dev UX convenience to mint the veNFT to `to` and set permanence in one transaction\n     *      Uses `to` as the owner for auth semantics; validation mirrors `createLock`\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanentFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT without modifying the unlock time\n     * @dev Increases the amount of tokens in a lock while keeping the same unlock date\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to increase the amount for\n     * @param _value Additional amount of tokens to add to the lock\n     */\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Extend the unlock time for an existing veNFT lock\n     * @dev Increases the lock duration without changing the token amount\n     *      Cannot extend lock time of permanent locks\n     *      New lock time is rounded down to the nearest week\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to extend the lock duration for\n     * @param _lockDuration New number of seconds until tokens unlock (from current time)\n     */\n    function increaseUnlockTime(uint256 _tokenId, uint256 _lockDuration) external;\n\n    /**\n     * @notice Withdraw all tokens from an expired lock for `_tokenId`\n     * @dev Only possible if the lock has expired and is not a permanent lock\n     *      This function burns the veNFT and returns the locked tokens to the owner\n     *      IMPORTANT: Any unclaimed rebases or rewards will no longer be claimable after calling this\n     *      Users should claim all rebases and rewards prior to withdrawing\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw tokens from\n     */\n    function withdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Withdraw tokens from a lock before it expires, with a time-proportional penalty\n     * @dev Allows users to exit a lock early but with a penalty fee applied\n     *      The penalty is proportional to both `earlyWithdrawPenalty` and remaining time until unlock\n     *      If the lock is permanent, it is internally converted back to a standard time-lock first and\n     *      the early withdraw penalty is computed using the restored lock window. Penalty fees are sent\n     *      to the `earlyWithdrawTreasury` address. Burns the veNFT and returns the nonpenalized portion\n     *      of tokens to the owner. Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw early from\n     */\n    function earlyWithdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Sets the early withdrawal penalty percentage\n     * @dev Can only be called by the team address\n     *      Value is in basis points (0-10000), where 10000 = 100%\n     * @param _earlyWithdrawPenalty The new penalty percentage in basis points\n     */\n    function setEarlyWithdrawPenalty(uint256 _earlyWithdrawPenalty) external;\n\n    /**\n     * @notice Sets the treasury address that will receive penalty fees from early withdrawals\n     * @dev Can only be called by the team address\n     *      The treasury address receives the penalty portion of tokens from early withdrawals\n     * @param _account The address of the new treasury that will receive penalty fees\n     */\n    function setEarlyWithdrawTreasury(address _account) external;\n\n    /**\n     * @notice Merges two veNFTs by combining their locked tokens into a single veNFT\n     * @dev The source veNFT is burned and its tokens are added to the destination veNFT\n     *      The lock duration/semantics of the destination veNFT are preserved\n     *      Rules:\n     *      - permanent + permanent: allowed (destination stays permanent)\n     *      - nonpermanent + permanent: allowed (permanent principal increases)\n     *      - permanent + nonpermanent: reverts\n     *      - expired source or destination: reverts\n     *      Can only be called by an address that owns or is approved for both veNFTs\n     * @param _from The ID of the source veNFT to merge from (will be burned)\n     * @param _to The ID of the destination veNFT to merge into (will receive the combined tokens)\n     */\n    function merge(uint256 _from, uint256 _to) external;\n\n    /**\n     * @notice Splits a veNFT into two new veNFTs with divided token balances\n     * @dev This operation burns the original veNFT and creates two new ones\n     *      Both new veNFTs maintain the same lock end time as the original\n     *      Can only be called by an address that has split permission, and owns or is approved for the veNFT\n     *      If called by an approved address, that address will NOT have approval on the new veNFTs\n     *      (approvals on the parent do not carry over to children)\n     *      Requires that the caller is either the owner or specifically has been granted split permission\n     *      Cannot split permanent locks\n     * @param _from The ID of the veNFT to split (will be burned)\n     * @param _amount The precise token amount to allocate to the second new veNFT\n     * @return _tokenId1 ID of the first new veNFT with (original amount - _amount) tokens\n     * @return _tokenId2 ID of the second new veNFT with exactly _amount tokens\n     */\n    function split(uint256 _from, uint256 _amount) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n    /**\n     * @notice Grant or revoke permission for an address to split veNFTs\n     * @dev Can only be called by the team address\n     *      Setting permissions for address(0) acts as a global switch for all addresses\n     *      If address(0) is set to false, no address can split regardless of individual permissions\n     *      If address(0) is set to true, individual permissions apply normally\n     * @param _account The address to modify split permissions for, or address(0) for global setting\n     * @param _bool True to grant permission, false to revoke permission\n     */\n    function toggleSplit(address _account, bool _bool) external;\n\n    /**\n     * @notice Permanently lock a veNFT to give it non-decaying voting power\n     * @dev Converts a standard time-locked veNFT to a permanent lock\n     *      Once permanent, the veNFT cannot be withdrawn normally (even after the original lock time)\n     *      Permanent locks have constant voting power equal to the locked token amount with no time decay\n     *      Note: time served prior to permanence is not preserved for penalty calculations  if the owner\n     *      later calls `earlyWithdraw`, the position is first unlocked and the penalty window resets to a\n     *      full MAXTIME from the current timestamp\n     *      Can only be called by the owner of the veNFT or an approved address\n     *      Cannot be called on a lock that is already permanent\n     * @param _tokenId The ID of the veNFT to permanently lock\n     */\n    function lockPermanent(uint256 _tokenId) external;\n\n    /**\n     * @notice Revert a veNFT from permanent lock status back to a standard time-lock\n     * @dev Converts a permanent lock back to a standard time-based lock\n     *      After unlocking, the veNFT's voting power will decay based on the remaining lock time\n     *      The lock time will be the original lock end time from before it was made permanent\n     *      If the original lock time has already passed, the lock will be immediately withdrawable\n     *      Can only be called by the owner or an approved operator\n     *      Only callable on veNFTs that are currently permanently locked\n     * @param _tokenId The ID of the veNFT to revert from permanent to standard lock\n     */\n    function unlockPermanent(uint256 _tokenId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                           VOTING POWER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the current voting power for a specific veNFT\n     * @dev Calculates voting power based on lock amount, remaining time, and permanent status\n     *      For standard locks: voting power = amount * (time_left / MAXTIME)\n     *      For permanent locks: voting power = amount (no time decay)\n     *      Returns 0 if called in the same block as a transfer due to checkpoint timing\n     *      This is the core function used for governance voting power determination\n     * @param _tokenId The ID of the veNFT to query voting power for\n     * @return The current voting power of the specified veNFT\n     */\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Get the historical voting power for a veNFT at a specific timestamp\n     * @dev Uses checkpoints to determine voting power at any point in the past\n     *      Crucial for governance systems that need to determine past voting power\n     *      For timestamps between checkpoints, calculates the interpolated value\n     *      Returns 0 for timestamps before the veNFT was created\n     * @param _tokenId The ID of the veNFT to query historical voting power for\n     * @param _t The timestamp at which to query the voting power\n     * @return The voting power of the specified veNFT at the requested timestamp\n     */\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    /**\n     * @notice Calculate the total voting power across all veNFTs at the current timestamp\n     * @dev Sums up all individual veNFT voting powers including both time-based and permanent locks\n     *      This represents the total governance voting power in the system right now\n     * @return The aggregate voting power of all veNFTs at the current timestamp\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Calculate the total historical voting power across all veNFTs at a specific timestamp\n     * @dev Uses global checkpoints to determine total voting power at any point in the past\n     *      Critical for governance votes that need to determine the total voting power at a past block\n     *      For timestamps between checkpoints, calculates the interpolated value\n     * @param _t The timestamp at which to query the total voting power\n     * @return The aggregate voting power of all veNFTs at the requested timestamp\n     */\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC6372\n    function clock() external view returns (uint48);\n\n    /// @inheritdoc IERC6372\n    function CLOCK_MODE() external view returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                          MIN LOCK AMOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the minimum amount of tokens required to create a veNFT lock\n     * @dev This value is used to validate lock creation and prevent spam attacks\n     * @return The minimum lock amount in token units (with 18 decimals)\n     */\n    function minLockAmount() external view returns (uint256);\n\n    /**\n     * @notice Sets the minimum amount of tokens required to create a veNFT lock\n     * @dev Can only be called by the team address. This helps prevent spam and ensures meaningful lock amounts\n     * @param newMinLockAmount The new minimum lock amount in token units (with 18 decimals)\n     */\n    function setMinLockAmount(uint256 newMinLockAmount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                      NOTIFY CONTRACTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the revenue reward contract\n     * @dev Returns address(0) if no revenue reward contract is set\n     * @return The revenue reward contract\n     */\n    function revenueReward() external view returns (IRevenueReward);\n\n    /**\n     * @notice Sets the revenue reward contract\n     * @dev Can only be called by the team address\n     * @param _revenueReward The new revenue reward contract\n     */\n    function setRevenueReward(IRevenueReward _revenueReward) external;\n}\n",
        "keccak256": "0x6b386b558166fbc71e1bf95bee2210f81afd960ab7129ac7503125c1ffb9bc5b",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IRevenueReward.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\n\nimport {IUserVaultFactory} from \"./IUserVaultFactory.sol\";\n\n/**\n * @title IRevenueReward Interface\n * @author Neverland\n * @notice Interface for the RevenueReward contract that manages token rewards distribution\n * @dev Handles reward epochs, claiming rewards, and self-repaying loan functionality\n */\ninterface IRevenueReward {\n    /// @notice Error thrown when a non-distributor address attempts to notify rewards\n    error NotRewardDistributor();\n\n    /// @notice Error thrown when a non-owner address attempts a restricted operation\n    error NotOwner();\n\n    /// @notice Error thrown when a non-DustLock address attempts a restricted operation\n    error NotDustLock();\n\n    /// @notice Error thrown when end timestamp used for calculating rewards is greater than the current time\n    error EndTimestampMoreThanCurrent();\n\n    /// @notice Error thrown when provided arrays are empty or exceed soft size limits\n    error InvalidArrayLengths();\n\n    /// @notice Error thrown when a provided reward token is not registered\n    error UnknownRewardToken();\n\n    /// @notice Error thrown when an array contains duplicate values or is not sorted in ascending order\n    error ArrayNotSortedOrContainsDuplicates();\n\n    /**\n     * @notice Emitted when rewards are claimed\n     * @param tokenId The veNFT id that produced the rewards\n     * @param user The address that received the rewards (owner or configured receiver)\n     * @param token Address of the reward token being claimed\n     * @param amount Amount of rewards claimed\n     */\n    event ClaimRewards(uint256 indexed tokenId, address indexed user, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when new rewards are notified to the contract\n     * @param from Address that notified the rewards (typically the reward distributor)\n     * @param token Address of the reward token being added\n     * @param epoch Reward epoch start timestamp (i.e., start of the week) the amount is credited to\n     * @param amount Amount of rewards added\n     */\n    event NotifyReward(address indexed from, address indexed token, uint256 epoch, uint256 amount);\n\n    /**\n     * @notice Emitted when tokens are recovered from the contract\n     * @param token Address of the token being recovered\n     * @param amount Amount of tokens recovered\n     */\n    event RecoverTokens(address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when self-repaying loan status is updated for a token\n     * @param token ID of the veNFT whose reward redirection is being configured\n     * @param rewardReceiver Address that will receive the rewards (or zero address if disabled)\n     * @param isEnabled Whether self-repaying loan is being enabled (true) or disabled (false)\n     */\n    event SelfRepayingLoanUpdate(uint256 indexed token, address rewardReceiver, bool isEnabled);\n\n    /**\n     * @notice Emitted when the reward distributor address is updated\n     * @param oldDistributor The previous reward distributor\n     * @param newDistributor The new reward distributor\n     */\n    event RewardDistributorUpdated(address indexed oldDistributor, address indexed newDistributor);\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice The address of the DustLock contract that manages veNFTs\n     * @return The IDustLock interface of the connected DustLock contract\n     */\n    function dustLock() external view returns (IDustLock);\n\n    /**\n     * @notice The address of the UserVaultFactory contract that manages user vaults\n     * @return The IUserVaultFactory interface of the connected UserVaultFactory contract\n     */\n    function userVaultFactory() external view returns (IUserVaultFactory);\n\n    /**\n     * @notice The duration of a reward epoch in seconds\n     * @dev This defines the time window for each reward distribution cycle\n     * @return Duration in seconds for each reward epoch\n     */\n    function DURATION() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of tokenIds allowed in a single batch claim.\n     * @return The maximum number of tokenIds accepted in batch calls\n     */\n    function MAX_TOKENIDS() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of reward tokens allowed in a single batch claim.\n     * @return The maximum number of reward tokens accepted in batch calls\n     */\n    function MAX_TOKENS() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                            STORAGE GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the timestamp of the last successfully processed reward claim for a token and veNFT\n     * @dev Used to calculate the amount of rewards earned since the last claim. Value is advanced to the\n     *      claim period end only when there were epochs to process; otherwise it remains unchanged.\n     * @param token The address of the reward token\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp (seconds) when rewards were last processed up to\n     */\n    function lastEarnTime(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the address authorized to add rewards to the contract\n     * @dev This address is the only one that can call notifyRewardAmount\n     *      Typically set to a protocol treasury or governance-controlled address\n     * @return The current reward distributor address\n     */\n    function rewardDistributor() external view returns (address);\n\n    /**\n     * @notice Checks if a token is registered as a valid reward token\n     * @dev Only registered reward tokens can be distributed through the contract\n     *      Tokens are registered automatically the first time they're used in notifyRewardAmount\n     * @param token The address of the token to check\n     * @return True if the token is registered as a reward token, false otherwise\n     */\n    function isRewardToken(address token) external view returns (bool);\n\n    /**\n     * @notice Returns the reward token at a specific index in the list of registered reward tokens\n     * @dev Used to enumerate all reward tokens available in the contract\n     *      Valid indices range from 0 to the number of registered reward tokens minus 1\n     * @param index The index in the reward tokens array\n     * @return The address of the reward token at the specified index\n     */\n    function rewardTokens(uint256 index) external view returns (address);\n\n    /**\n     * @notice Returns the accumulated sum of all reward distributions for a specific token\n     * @dev Used for internal reward accounting and distribution calculations\n     *      This value increases each time new rewards are notified\n     * @param token The address of the reward token\n     * @return The total amount of rewards ever distributed for this token\n     */\n    function totalRewardsPerToken(address token) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of rewards allocated for a specific token at a given epoch start\n     * @dev Rewards are tracked by epoch start timestamp (seconds), with each epoch lasting DURATION seconds.\n     * @param token The address of the reward token\n     * @param epoch The epoch start timestamp (i.e., start of the week)\n     * @return The amount of rewards allocated for the token at that epoch start\n     */\n    function tokenRewardsPerEpoch(address token, uint256 epoch) external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp when a veNFT was minted\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp when the veNFT was minted\n     */\n    function tokenMintTime(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the accumulated fractional remainder of rewards for a veNFT and token, scaled by 1e18.\n     * @dev During per-epoch reward calculations, integer division can leave a remainder that cannot be paid out.\n     *      This function exposes the running sum of those remainders for the given (token, tokenId) pair,\n     *      scaled by a factor of 1e18 to preserve precision (i.e., value is remainder * 1e18 / totalSupplyAt(epoch)).\n     *      This value is informational and not directly claimable; it helps off-chain analytics understand\n     *      the uncredited fractional rewards that have accumulated over time due to rounding.\n     * @param token The address of the reward token being tracked.\n     * @param tokenId The ID of the veNFT whose fractional remainder is queried.\n     * @return scaledRemainder The accumulated fractional rewards remainder, scaled by 1e18.\n     */\n    function tokenRewardsRemainingAccScaled(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the configured reward recipient address for a specific veNFT\n     * @dev When self-repaying loan functionality is enabled, rewards are sent to this address\n     *      Returns address(0) if no special recipient is configured (rewards go to veNFT owner)\n     * @param tokenId The ID of the veNFT to query\n     * @return The address that receives rewards for this veNFT, or address(0) if it's the owner\n     */\n    function tokenRewardReceiver(uint256 tokenId) external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the address authorized to add rewards to the contract\n     * @dev Can only be called by the current reward distributor\n     *      This is a critical permission that controls who can distribute rewards\n     * @param newRewardDistributor The address of the new reward distributor\n     */\n    function setRewardDistributor(address newRewardDistributor) external;\n\n    /**\n     * @notice Adds new rewards to the distribution pool for the next epoch\n     * @dev Can only be called by the authorized reward distributor address.\n     *      Automatically registers new tokens the first time they're used.\n     *      Rewards added during the current epoch become claimable starting the next epoch.\n     *      Emits a NotifyReward event with details about the distribution.\n     *      Reverts: NotRewardDistributor, zero address/amount checks enforced by implementation.\n     * @param token The address of the reward token to distribute\n     * @param amount The amount of rewards to add to the distribution pool\n     */\n    function notifyRewardAmount(address token, uint256 amount) external;\n\n    /**\n     * @notice Recovers unnotified balances of registered reward tokens\n     * @dev Can only be called by the reward distributor\n     *      For each registered reward token, if the contract's token balance exceeds the credited amount\n     *      tracked by totalRewardsPerToken[token], transfers the excess to the reward distributor and emits\n     *      a RecoverTokens event.\n     */\n    function recoverTokens() external;\n\n    /*//////////////////////////////////////////////////////////////\n                            NOTIFICATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Notifies the contract that a new token has been created\n     * @dev Intended to update internal state or trigger logic after a veNFT creation event\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the token (veNFT) that has been created\n     */\n    function notifyTokenMinted(uint256 tokenId) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is transferred\n     * @dev This function is called by the DustLock contract just after transferring a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being transferred\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was transferred\n     * @param from The address of the previous token owner (sender of the transfer)\n     */\n    function notifyAfterTokenTransferred(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is burned\n     * @dev This function is called by the DustLock contract just after burning a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being burned\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was burned\n     * @param from The address of the previous token owner\n     */\n    function notifyAfterTokenBurned(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles bookkeeping after two veNFTs are merged.\n     * @dev Callable only by the DustLock contract.\n     * @param fromToken The tokenId that was merged and is no longer active (source).\n     * @param toToken The tokenId that survives the merge and should receive consolidated accounting (destination).\n     * @param owner The tokens' owner.\n     */\n    function notifyAfterTokenMerged(uint256 fromToken, uint256 toToken, address owner) external;\n\n    /**\n     * @notice Handles bookkeeping after a veNFT is split into two new veNFTs.\n     * @dev Callable only by the DustLock contract.\n     *      - Initializes mint timestamps for the two new tokenIds.\n     *      - Proportionally splits the accumulated fractional rewards remainder (scaled by 1e18)\n     *        from `fromToken` between `tokenId1` and `tokenId2` using their provided amounts.\n     *      - Clears the remainder accumulator for `fromToken` and removes it from any self-repaying\n     *        loan tracking if applicable.\n     * @param fromToken The original tokenId that was split (source).\n     * @param tokenId1 The first resulting tokenId after the split.\n     * @param token1Amount The amount (voting power/shares) assigned to `tokenId1` in the split.\n     * @param tokenId2 The second resulting tokenId after the split.\n     * @param token2Amount The amount (voting power/shares) assigned to `tokenId2` in the split.\n     * @param owner The owner of the tokens involved in the split.\n     */\n    function notifyAfterTokenSplit(\n        uint256 fromToken,\n        uint256 tokenId1,\n        uint256 token1Amount,\n        uint256 tokenId2,\n        uint256 token2Amount,\n        address owner\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens\n     * @dev Calculates earned rewards for each specified token using epoch-based accounting and transfers them\n     *      to the appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured\n     *      via enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     */\n    function getReward(uint256 tokenId, address[] calldata tokens) external;\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp\n     * @dev Similar to getReward, but allows specifying a custom end timestamp for the reward calculation period.\n     *      Calculates earned rewards for each specified token using epoch-based accounting and transfers them to the\n     *      appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured via\n     *      enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to rewardPeriodEndTs to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, EndTimestampMoreThanCurrent, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     * @param rewardPeriodEndTs The end timestamp to calculate rewards up to (must not be in the future)\n     */\n    function getRewardUntilTs(uint256 tokenId, address[] calldata tokens, uint256 rewardPeriodEndTs) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays or unknown tokens.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     */\n    function getRewardBatch(uint256[] calldata tokenIds, address[] calldata tokens) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens up to a specific timestamp.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays, unknown tokens,\n     *      or if `rewardPeriodEndTs` is in the future.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     * @param rewardPeriodEndTs End timestamp for calculation (<= now).\n     */\n    function getRewardUntilTsBatch(uint256[] calldata tokenIds, address[] calldata tokens, uint256 rewardPeriodEndTs)\n        external;\n\n    /*//////////////////////////////////////////////////////////////\n                         SELF-REPAYING LOANS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Enables the self-repaying loan feature for a specific veNFT\n     * @dev Configures a custom reward receiver address (typically a loan contract).\n     *      This allows veNFT owners to use their rewards to automatically repay loans.\n     *      The getReward function must still be called to trigger the reward claim.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner, zero rewardReceiver.\n     * @param tokenId The ID of the veNFT to configure self-repaying loan for\n     */\n    function enableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Disables the self-repaying loan feature for a specific veNFT\n     * @dev Removes the custom reward receiver configuration, returning to default behavior.\n     *      After disabling, all future rewards will go directly to the veNFT owner.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner.\n     * @param tokenId The ID of the veNFT to restore default reward routing for\n     */\n    function disableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Batch enable self-repaying loan with a single receiver for many tokenIds.\n     * @dev Each tokenId must be owned by the caller. Reverts on zero rewardReceiver.\n     * @param tokenIds Array of veNFT ids to configure.\n     */\n    function enableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /**\n     * @notice Batch disable self-repaying loan for many tokenIds.\n     * @dev Each tokenId must be owned by the caller.\n     * @param tokenIds Array of veNFT ids to restore default reward routing.\n     */\n    function disableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Preview unclaimed rewards for a single reward token up to a specific timestamp.\n     * @dev Read-only mirror of claim math; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, UnknownRewardToken if not registered.\n     * @param token Reward token address to preview.\n     * @param tokenId veNFT id to preview for.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return amount Total rewards that would be claimable if claimed up to `endTs`.\n     */\n    function earnedRewards(address token, uint256 tokenId, uint256 endTs) external view returns (uint256 amount);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens at the current timestamp.\n     * @dev Convenience wrapper that uses block.timestamp internally. Returns a matrix of rewards per\n     *      tokenId (outer) per token (inner), and totals per token.\n     *      Reverts: InvalidArrayLengths on bad inputs, UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAll(address[] calldata tokens, uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens up to a specific timestamp.\n     * @dev Read-only; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, InvalidArrayLengths on bad inputs,\n     *      UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAllUntilTs(address[] calldata tokens, uint256[] calldata tokenIds, uint256 endTs)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Returns the number of registered reward tokens\n     * @return The count of reward tokens\n     */\n    function rewardTokensLength() external view returns (uint256);\n\n    /**\n     * @notice Returns the full list of registered reward tokens\n     * @return tokens An array containing all reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory tokens);\n\n    /**\n     * @notice Returns a list of user addresses with at least one active self-repaying loan within a given range.\n     * @dev Iterates over the internal set of users who have enabled self-repaying loans,\n     *      returning addresses from index `from` up to, but not including, index `to`.\n     *      If the specified range exceeds the number of users, the function adjusts accordingly.\n     * @param from The starting index (inclusive) in the user set.\n     * @param to The ending index (exclusive) in the user set.\n     * @return users An array of user addresses in the specified range who have self-repaying loans enabled.\n     */\n    function getUsersWithSelfRepayingLoan(uint256 from, uint256 to) external view returns (address[] memory);\n\n    /**\n     * @notice Returns the list of token IDs for which the given user has enabled a self-repaying loan.\n     * @dev Checks the user's internal set of token IDs with self-repaying loans and returns them as an array.\n     * @param user The address of the user to query.\n     * @return tokenIds An array of token IDs currently associated with self-repaying loans for the user.\n     */\n    function getUserTokensWithSelfRepayingLoan(address user) external view returns (uint256[] memory tokenIds);\n}\n",
        "keccak256": "0xb72598c4cb5b87b2421a6763d847267c173a884a1eeb283b3474a9a4e0066477",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IUserVault.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title IUserVault\n * @author Neverland\n * @notice Interface for UserVault: manage repayments, swaps, and recoveries\n */\ninterface IUserVault {\n    /// @notice Emitted when an aggregator is not supported.\n    error AggregatorNotSupported();\n    ///  @notice Emitted when the caller is not the executor\n    error NotExecutor();\n    /// @notice Emitted when swap is failed\n    error SwapFailed();\n    /// @notice Emitted the asset prices failed to be retrieved from oracle\n    error GettingAssetPriceFailed();\n    /// @notice Emitted when swapping slippage exceeded the max allowed\n    error SlippageExceeded();\n    /// @notice Emitted when tokenId belongs to a different user vault\n    error InvalidUserVaultForToken();\n    /// @notice Emitted max slippage set by execute is more than max allowed\n    error MaxSlippageTooHigh();\n    /// @notice Emitted user poolAddressesProvider is not registered in poolAddressesProviderRegistry\n    error InvalidPoolAddressesProvider();\n    /// @notice Emitted when native ETH send fails during recovery\n    error ETHSendFailed();\n\n    /**\n     * @notice Emitted when a user's loan is repaid through the vault\n     * @param user The loan owner's address\n     * @param userVault The UserVault that executed the repayment\n     * @param poolAddressesProvider The Aave pool addresses provider used\n     * @param debtToken The repaid debt token address\n     * @param amount The repaid amount\n     */\n    event LoanSelfRepaid(\n        address indexed user,\n        address indexed userVault,\n        address poolAddressesProvider,\n        address debtToken,\n        uint256 amount\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Parameters for repaying a user's debt on a lending pool.\n     * @dev\n     * - tokenIds must belong to this user vault, otherwise the call reverts.\n     * - Set aggregatorAddress and aggregatorData only if a swap is required (e.g., swapping rewards to the debt token).\n     * - maxSlippageBps is expressed in basis points (1 bps = 0.01%).\n     * @param debtToken The address of the debt token to be repaid.\n     * @param poolAddressesProvider The pool address provider of the pool, where the debt exists.\n     * @param tokenIds List of token IDs involved in the operation.\n     * @param rewardToken The reward token to claim and optionally swap before repayment.\n     * @param rewardTokenAmountToSwap Amount of rewardToken to swap into the debt token.\n     * @param aggregatorAddress Swap aggregator address to use for asset conversion, if needed.\n     * @param aggregatorData Calldata for the aggregator to perform the swap.\n     * @param maxSlippageBps Maximum acceptable swap slippage in basis points.\n     */\n    struct RepayUserDebtParams {\n        address debtToken;\n        address poolAddressesProvider;\n        uint256[] tokenIds;\n        address rewardToken;\n        uint256 rewardTokenAmountToSwap;\n        address aggregatorAddress;\n        bytes aggregatorData;\n        uint256 maxSlippageBps;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Repays a user's debt for a specified token on a lending pool\n     * @dev Optionally claims rewardToken and swaps it via the provided aggregator before repayment,\n     *      enforcing the specified maxSlippageBps. Reverts if tokenIds are not associated with this vault\n     * @param params Structured parameters. See RepayUserDebtParams for details\n     */\n    function repayUserDebt(RepayUserDebtParams calldata params) external;\n\n    /**\n     * @notice Claims rewards for the provided tokenIds and returns the total amount of rewardToken received.\n     * @dev\n     * - Reverts with InvalidUserVaultForToken if any tokenIds reward receiver is not this vault\n     * - Calls the external rewards distributor for each tokenId to pull rewards into this contract\n     * - Computes the claimed amount by measuring this contracts rewardToken balance delta\n     * - Callable only by the executor; otherwise reverts with NotExecutor\n     * @param tokenIds Array of token IDs whose rewards should be claimed\n     * @param rewardToken The ERC20 reward token to claim\n     * @return rewardTokenAmount The total amount of rewardToken claimed into this vault\n     */\n    function getTokenIdsReward(uint256[] memory tokenIds, address rewardToken) external returns (uint256);\n\n    /**\n     * @notice Swaps tokenIn for tokenOut via a supported aggregator and verifies slippage against oracle prices.\n     * @dev\n     * - Reverts with AggregatorNotSupported if the aggregator is not approved\n     * - Forwards aggregatorData to the aggregator using a low-level call; reverts with SwapFailed on failure\n     * - Computes USD-denominated slippage using oracle prices and reverts with SlippageExceeded\n     *   if it exceeds maxAllowedSlippageBps\n     * - Callable only by the executor; otherwise reverts with NotExecutor\n     * @param tokenIn The ERC20 token address to swap from\n     * @param tokenInAmount The exact amount of tokenIn to swap\n     * @param tokenOut The ERC20 token address to receive\n     * @param aggregator The swap aggregator contract to execute the swap\n     * @param aggregatorData Calldata to be sent to the aggregator for performing the swap\n     * @param poolAddressesProvider The pool addresses provider of the pool, where the debt exists\n     * @param maxAllowedSlippageBps Maximum acceptable slippage in basis points (1 bps = 0.01%)\n     * @return The amount of tokenOut received from the swap\n     */\n    function swapAndVerify(\n        address tokenIn,\n        uint256 tokenInAmount,\n        address tokenOut,\n        address aggregator,\n        bytes memory aggregatorData,\n        address poolAddressesProvider,\n        uint256 maxAllowedSlippageBps\n    ) external returns (uint256);\n\n    /**\n     * @notice Repays debt for a given pool with a specified token and amount\n     * @param poolAddressesProvider The pool addresses provider of the pool, where the debt exists\n     * @param debtToken The address of the token to repay\n     * @param amount The amount of the token to repay\n     */\n    function repayDebt(address poolAddressesProvider, address debtToken, uint256 amount) external;\n\n    /**\n     * @notice Deposits collateral for a user into a lending pool\n     * @param poolAddressesProvider The pool addresses provider of the pool\n     * @param debtToken The address of the collateral token\n     * @param amount The amount of collateral to deposit\n     */\n    function depositCollateral(address poolAddressesProvider, address debtToken, uint256 amount) external;\n\n    /**\n     * @notice Allows recovery of ERC20 tokens that may be stuck in the vault back to the user\n     * @param token The address of the ERC20 token to recover\n     * @param amount The amount of tokens to recover\n     */\n    function recoverERC20(address token, uint256 amount) external;\n\n    /**\n     * @notice Allows recovery of native ETH that may be stuck in the vault back to the user\n     * @param amount The amount of ETH to recover\n     */\n    function recoverETH(uint256 amount) external;\n}\n",
        "keccak256": "0x6300103f410d7cc2096e81ba412310e68e98d01f8621f4bcafb73d05e9d5673d",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IUserVaultFactory.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title IUserVaultFactory\n * @author Neverland\n * @notice Interface for the UserVaultFactory contract.\n *         Allows creation and retrieval of user-specific vaults.\n */\ninterface IUserVaultFactory {\n    /**\n     * @notice Emitted when a new user vault is created\n     * @param user The user for whom the vault was created\n     * @param vault The address of the created vault\n     */\n    event UserVaultCreated(address indexed user, address indexed vault);\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user. Creates a new vault if none exists\n     * @dev If the vault does not exist, a new BeaconProxy is deployed and initialized for the user\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getUserVault(address user) external view returns (address vault);\n\n    /*//////////////////////////////////////////////////////////////\n                               ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user if it exists\n     * @dev If the vault does not exist, returns address(0)\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getOrCreateUserVault(address user) external returns (address vault);\n}\n",
        "keccak256": "0x2c37e5bc81e701ab66b66aea87f6daedf1ec8adf2685d14a66afe77ea477735e",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IUserVaultRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\n/**\n * @title IUserVaultRegistry\n * @author Neverland\n * @notice Interface for the UserVaultRegistry contract.\n *         Manages executor and supported aggregators for user vaults.\n */\ninterface IUserVaultRegistry {\n    /**\n     * @notice Emitted when the executor is updated\n     * @param oldExecutor The previous executor address\n     * @param newExecutor The new executor address\n     */\n    event ExecutorUpdated(address indexed oldExecutor, address indexed newExecutor);\n\n    /**\n     * @notice Emitted when an aggregator's support status is updated\n     * @param aggregator The aggregator address that was updated\n     * @param isActive Whether the aggregator is now supported\n     */\n    event AggregatorSupportUpdated(address indexed aggregator, bool isActive);\n\n    /**\n     * @notice Emitted when the max swap slippage is updated\n     * @param oldValue The previous max slippage in bps\n     * @param newValue The new max slippage in bps\n     */\n    event MaxSwapSlippageUpdated(uint256 oldValue, uint256 newValue);\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the address of the current executor\n     * @return The executor address\n     */\n    function executor() external view returns (address);\n\n    /**\n     * @notice Returns the max slippage allowed to be set by executor when swap is made in user vault\n     * @return The maximum swap slippage in basis points\n     */\n    function maxSwapSlippageBps() external view returns (uint256);\n\n    /**\n     * @notice Checks if an aggregator is supported\n     * @param aggregator The aggregator address to query\n     * @return True if supported, false otherwise\n     */\n    function isSupportedAggregator(address aggregator) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Sets the executor address\n     * @param executor Address of the new executor\n     */\n    function setExecutor(address executor) external;\n\n    /**\n     * @notice Sets the aggregator as supported or not\n     * @param aggregator The aggregator address\n     * @param isActive True if the aggregator should be supported, false otherwise\n     */\n    function setSupportedAggregators(address aggregator, bool isActive) external;\n\n    /**\n     * @notice Sets the maximum allowed swap slippage, expressed in basis points.\n     * @param newMaxSwapSlippageBps The new maximum swap slippage in basis points.\n     */\n    function setMaxSwapSlippageBps(uint256 newMaxSwapSlippageBps) external;\n}\n",
        "keccak256": "0x661556d5aa66110ad9bd02af248c59cce1ec8b14962583fe74f728db33b567e0",
        "license": "MIT"
      },
      "src/libraries/CommonChecksLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonChecksLibrary\n * @author Neverland\n * @notice Shared require/revert helpers for zero/invalid values used across contracts\n */\nlibrary CommonChecksLibrary {\n    /// @notice Used when a zero address is provided where not allowed.\n    error AddressZero();\n    /// @notice Used when a zero amount is provided where not allowed.\n    error ZeroAmount();\n    /// @notice Used when a range is invalid.\n    error InvalidRange();\n    /// @notice Used when two addresses are the same but must differ.\n    error SameAddress();\n    /// @notice Used when a balance is zero.\n    error ZeroBalance();\n    /// @notice Used when a tokenId is invalid.\n    error InvalidTokenId();\n    /// @notice Used when a from address is invalid.\n    error InvalidFromAddress();\n    /// @notice Used when a to address is invalid.\n    error InvalidToAddress();\n    /// @notice Used when a user address is invalid.\n    error InvalidUserAddress();\n    /// @notice Used a function is called by an account that is not permitted.\n    error UnauthorizedAccess();\n\n    /**\n     * @notice Reverts if the provided address is zero\n     * @param addressToCheck The address to check\n     */\n    function revertIfZeroAddress(address addressToCheck) internal pure {\n        if (addressToCheck == address(0)) revert AddressZero();\n    }\n\n    /**\n     * @notice Reverts if the provided amount is zero\n     * @param amount The amount to check\n     */\n    function revertIfZeroAmount(uint256 amount) internal pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n\n    /**\n     * @notice Reverts if the [from, to] range is invalid (from > to)\n     * @param from The start of the range\n     * @param to The end of the range\n     */\n    function revertIfInvalidRange(uint256 from, uint256 to) internal pure {\n        if (from > to) revert InvalidRange();\n    }\n\n    /**\n     * @notice Reverts if the two addresses are the same\n     * @param first The first address to check\n     * @param second The second address to check\n     */\n    function revertIfSameAddress(address first, address second) internal pure {\n        if (first == second) revert SameAddress();\n    }\n\n    /**\n     * @notice Reverts if the balance is zero\n     * @param balance The balance to check\n     */\n    function revertIfZeroBalance(uint256 balance) internal pure {\n        if (balance == 0) revert ZeroBalance();\n    }\n\n    /**\n     * @notice Reverts if the tokenId owner is the zero address\n     * @param owner The owner of the tokenId\n     */\n    function revertIfInvalidTokenId(address owner) internal pure {\n        if (owner == address(0)) revert InvalidTokenId();\n    }\n\n    /**\n     * @notice Reverts if the from address is zero\n     * @param from The from address to check\n     */\n    function revertIfInvalidFromAddress(address from) internal pure {\n        if (from == address(0)) revert InvalidFromAddress();\n    }\n\n    /**\n     * @notice Reverts if the to address is zero\n     * @param to The to address to check\n     */\n    function revertIfInvalidToAddress(address to) internal pure {\n        if (to == address(0)) revert InvalidToAddress();\n    }\n\n    /**\n     * @notice Reverts if the user address is zero\n     * @param user The user address to check\n     */\n    function revertIfInvalidUserAddress(address user) internal pure {\n        if (user == address(0)) revert InvalidUserAddress();\n    }\n}\n",
        "keccak256": "0xa8e23a48af12c93a809845953069be6f296d8d2e93e7cd89e5250b15b5d9f805",
        "license": "BUSL-1.1"
      },
      "src/self-repaying-loans/UserVault.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IAaveOracle} from \"@aave/core-v3/contracts/interfaces/IAaveOracle.sol\";\nimport {IPoolAddressesProviderRegistry} from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProviderRegistry.sol\";\nimport {IPoolAddressesProvider} from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport {IPool} from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\nimport {IRevenueReward} from \"../interfaces/IRevenueReward.sol\";\nimport {IUserVaultRegistry} from \"../interfaces/IUserVaultRegistry.sol\";\nimport {IUserVault} from \"../interfaces/IUserVault.sol\";\n\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\n\n/**\n * @title UserVault\n * @author Neverland\n * @notice User vault contract for self-repaying loans\n */\ncontract UserVault is IUserVault, Initializable {\n    using SafeERC20 for IERC20;\n\n    /// @notice UserVaultRegistry contract\n    IUserVaultRegistry public userVaultRegistry;\n    /// @notice RevenueReward contract\n    IRevenueReward public revenueReward;\n    /// @notice AAVE PoolAddressesProviderRegistry contract\n    IPoolAddressesProviderRegistry public poolAddressesProviderRegistry;\n\n    /// @notice User address\n    address public user;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param _user User address\n     * @param _revenueReward RevenueReward address\n     * @param _userVaultRegistry UserVaultRegistry address\n     * @param _poolAddressesProviderRegistry PoolAddressesProviderRegistry address\n     */\n    function initialize(\n        address _user,\n        IRevenueReward _revenueReward,\n        IUserVaultRegistry _userVaultRegistry,\n        IPoolAddressesProviderRegistry _poolAddressesProviderRegistry\n    ) external initializer {\n        CommonChecksLibrary.revertIfZeroAddress(address(_userVaultRegistry));\n        CommonChecksLibrary.revertIfZeroAddress(address(_poolAddressesProviderRegistry));\n        CommonChecksLibrary.revertIfZeroAddress(address(_revenueReward));\n        CommonChecksLibrary.revertIfZeroAddress(_user);\n\n        user = _user;\n        revenueReward = _revenueReward;\n        userVaultRegistry = _userVaultRegistry;\n        poolAddressesProviderRegistry = _poolAddressesProviderRegistry;\n    }\n\n    /// @inheritdoc IUserVault\n    function repayUserDebt(RepayUserDebtParams calldata params) external onlyExecutor {\n        getTokenIdsReward(params.tokenIds, params.rewardToken);\n\n        uint256 debtTokenSwapAmount = swapAndVerify(\n            params.rewardToken,\n            params.rewardTokenAmountToSwap,\n            params.debtToken,\n            params.aggregatorAddress,\n            params.aggregatorData,\n            params.poolAddressesProvider,\n            params.maxSlippageBps\n        );\n\n        repayDebt(params.poolAddressesProvider, params.debtToken, debtTokenSwapAmount);\n\n        emit LoanSelfRepaid(user, address(this), params.poolAddressesProvider, params.debtToken, debtTokenSwapAmount);\n    }\n\n    /// @inheritdoc IUserVault\n    function getTokenIdsReward(uint256[] memory tokenIds, address rewardToken) public onlyExecutor returns (uint256) {\n        CommonChecksLibrary.revertIfZeroAddress(rewardToken);\n\n        uint256 rewardTokenTokenBalanceBefore = _getErc20TokenBalance(rewardToken, address(this));\n\n        address[] memory rewardTokens = new address[](1);\n        rewardTokens[0] = address(rewardToken);\n        uint256 tokenIdsLength = tokenIds.length;\n        for (uint256 i = 0; i < tokenIdsLength; ++i) {\n            if (revenueReward.tokenRewardReceiver(tokenIds[i]) != address(this)) {\n                revert InvalidUserVaultForToken();\n            }\n            revenueReward.getReward(tokenIds[i], rewardTokens);\n        }\n\n        uint256 rewardTokenTokenBalanceAfter = _getErc20TokenBalance(rewardToken, address(this));\n        uint256 rewardTokenAmount = rewardTokenTokenBalanceAfter - rewardTokenTokenBalanceBefore;\n        return rewardTokenAmount;\n    }\n\n    /// @inheritdoc IUserVault\n    function swapAndVerify(\n        address tokenIn,\n        uint256 tokenInAmount,\n        address tokenOut,\n        address aggregator,\n        bytes memory aggregatorData,\n        address poolAddressesProvider,\n        uint256 maxAllowedSlippageBps\n    ) public onlyExecutor poolAddressesProviderShouldBeValid(poolAddressesProvider) returns (uint256) {\n        CommonChecksLibrary.revertIfZeroAddress(tokenIn);\n        CommonChecksLibrary.revertIfZeroAddress(tokenOut);\n        CommonChecksLibrary.revertIfZeroAmount(tokenInAmount);\n        CommonChecksLibrary.revertIfZeroAddress(aggregator);\n        if (maxAllowedSlippageBps > userVaultRegistry.maxSwapSlippageBps()) revert MaxSlippageTooHigh();\n\n        uint256 debtTokenSwapAmount = _swap(tokenIn, tokenInAmount, tokenOut, aggregator, aggregatorData);\n\n        uint256[] memory tokenPricesInUSD_8dec =\n            _getTokenPricesInUsd_8dec(tokenIn, tokenOut, IPoolAddressesProvider(poolAddressesProvider));\n\n        // Ensure oracle returned valid non-zero prices for both tokens\n        if (tokenPricesInUSD_8dec.length < 2 || tokenPricesInUSD_8dec[0] == 0 || tokenPricesInUSD_8dec[1] == 0) {\n            revert GettingAssetPriceFailed();\n        }\n\n        _verifySlippage(\n            tokenIn,\n            tokenInAmount,\n            tokenPricesInUSD_8dec[0],\n            tokenOut,\n            debtTokenSwapAmount,\n            tokenPricesInUSD_8dec[1],\n            maxAllowedSlippageBps\n        );\n\n        return debtTokenSwapAmount;\n    }\n\n    /// @inheritdoc IUserVault\n    function repayDebt(address poolAddressesProvider, address debtToken, uint256 amount)\n        public\n        onlyExecutor\n        poolAddressesProviderShouldBeValid(poolAddressesProvider)\n    {\n        address poolAddress = IPoolAddressesProvider(poolAddressesProvider).getPool();\n        IERC20(debtToken).safeApprove(poolAddress, amount);\n        IPool(poolAddress).repay(debtToken, amount, 2, user);\n        IERC20(debtToken).safeApprove(poolAddress, 0);\n    }\n\n    /// @inheritdoc IUserVault\n    function depositCollateral(address poolAddressesProvider, address debtToken, uint256 amount)\n        external\n        onlyExecutor\n        poolAddressesProviderShouldBeValid(poolAddressesProvider)\n    {\n        address poolAddress = IPoolAddressesProvider(poolAddressesProvider).getPool();\n        IERC20(debtToken).safeApprove(poolAddress, amount);\n        IPool(poolAddress).supply(debtToken, amount, user, 0);\n        IERC20(debtToken).safeApprove(poolAddress, 0);\n    }\n\n    /// @inheritdoc IUserVault\n    function recoverERC20(address token, uint256 amount) external onlyExecutorOrUser {\n        IERC20(token).safeTransfer(user, amount);\n    }\n\n    /// @inheritdoc IUserVault\n    function recoverETH(uint256 amount) external onlyExecutorOrUser {\n        (bool ok,) = payable(user).call{value: amount}(\"\");\n        if (!ok) revert IUserVault.ETHSendFailed();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Swaps a specified token using a given aggregator contract.\n     * @param tokenIn The address of the token swapped in.\n     * @param tokenInAmount Amount needed to swap tokens.\n     * @param tokenOut The address of the token swapped out.\n     * @param aggregator The address of the swap aggregator contract to use for performing the swap.\n     * @param aggregatorData The calldata required by the aggregator contract for the swap execution.\n     * @return Amount of tokens swapped out\n     */\n    function _swap(\n        address tokenIn,\n        uint256 tokenInAmount,\n        address tokenOut,\n        address aggregator,\n        bytes memory aggregatorData\n    ) internal returns (uint256) {\n        uint256 debtTokenBalanceBefore = _getErc20TokenBalance(tokenOut, address(this));\n\n        if (!userVaultRegistry.isSupportedAggregator(aggregator)) {\n            revert AggregatorNotSupported();\n        }\n        IERC20(tokenIn).safeApprove(aggregator, tokenInAmount);\n\n        (bool success,) = aggregator.call(aggregatorData);\n        if (!success) revert SwapFailed();\n\n        uint256 debtTokenBalanceAfter = _getErc20TokenBalance(tokenOut, address(this));\n        uint256 debtTokenSwapAmount = debtTokenBalanceAfter - debtTokenBalanceBefore;\n\n        IERC20(tokenIn).safeApprove(aggregator, 0);\n\n        return debtTokenSwapAmount;\n    }\n\n    /**\n     * @notice Returns a list of prices from a list of assets addresses\n     * @param token1 token1 address\n     * @param token2 token2 address\n     * @return The prices of the given assets\n     */\n    function _getTokenPricesInUsd_8dec(address token1, address token2, IPoolAddressesProvider poolAddressesProvider)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        address[] memory tokens = new address[](2);\n        tokens[0] = token1;\n        tokens[1] = token2;\n\n        return IAaveOracle(poolAddressesProvider.getPriceOracle()).getAssetsPrices(tokens);\n    }\n\n    /**\n     * @notice Gets the balance of an ERC20 token for a specified account\n     * @param erc20Token The address of the ERC20 token\n     * @param account The address of the account to check balance for\n     * @return The balance of the ERC20 token for the specified account\n     */\n    function _getErc20TokenBalance(address erc20Token, address account) internal view returns (uint256) {\n        return IERC20(erc20Token).balanceOf(account);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CALCULATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Verifies that the slippage between the desired swap amount and the actual swapped amount is within the allowed slippage\n     * @dev Normalizes token amounts to 18 decimals before comparison to handle tokens with different decimals\n     * @param tokenA The address of token A (token being swapped from)\n     * @param desiredSwapAmountInTokenA The desired amount of token A to swap\n     * @param tokenAUnitPriceInUSD_8dec The price of token A in USD with 8 decimals\n     * @param tokenB The address of token B (token being swapped to)\n     * @param actualSwappedAmountInTokenB The actual amount of token B that was swapped\n     * @param tokenBUnitPriceInUSD_8dec The price of token B in USD with 8 decimals\n     * @param maxAllowedSlippageBps The maximum allowed slippage in basis points\n     */\n    function _verifySlippage(\n        address tokenA,\n        uint256 desiredSwapAmountInTokenA,\n        uint256 tokenAUnitPriceInUSD_8dec,\n        address tokenB,\n        uint256 actualSwappedAmountInTokenB,\n        uint256 tokenBUnitPriceInUSD_8dec,\n        uint256 maxAllowedSlippageBps\n    ) internal view {\n        // Get token decimals\n        uint8 tokenADecimals = IERC20Metadata(tokenA).decimals();\n        uint8 tokenBDecimals = IERC20Metadata(tokenB).decimals();\n\n        uint256 desiredSwapAmountInUsd = desiredSwapAmountInTokenA * tokenAUnitPriceInUSD_8dec / 10 ** tokenADecimals;\n        uint256 actualSwapAmountInUsd = actualSwappedAmountInTokenB * tokenBUnitPriceInUSD_8dec / 10 ** tokenBDecimals;\n\n        if (actualSwapAmountInUsd < desiredSwapAmountInUsd) {\n            uint256 actualSlippageBps =\n                (desiredSwapAmountInUsd - actualSwapAmountInUsd) * 10_000 / desiredSwapAmountInUsd;\n\n            if (actualSlippageBps > maxAllowedSlippageBps) revert SlippageExceeded();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MODIFIERS\n     //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier to check if the caller is the executor\n    modifier onlyExecutor() {\n        if (userVaultRegistry.executor() != msg.sender) {\n            revert NotExecutor();\n        }\n        _;\n    }\n\n    /// @notice Modifier to check if the caller is the executor or the user\n    modifier onlyExecutorOrUser() {\n        if (!(userVaultRegistry.executor() == msg.sender || user == msg.sender)) {\n            revert CommonChecksLibrary.UnauthorizedAccess();\n        }\n        _;\n    }\n\n    /// @notice Modifier to check if the pool addresses provider is valid\n    modifier poolAddressesProviderShouldBeValid(address poolAddressesProvider) {\n        uint256 poolAddressesProviderId =\n            poolAddressesProviderRegistry.getAddressesProviderIdByAddress(poolAddressesProvider);\n        if (poolAddressesProviderId == 0) revert InvalidPoolAddressesProvider();\n        _;\n    }\n}\n",
        "keccak256": "0x9fca481ededf266023be11cf556acaadfeff057aad3318ae16540d7eb3fef08f",
        "license": "BUSL-1.1"
      },
      "src/self-repaying-loans/UserVaultFactory.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IPoolAddressesProviderRegistry} from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProviderRegistry.sol\";\n\nimport {IUserVaultFactory} from \"../interfaces/IUserVaultFactory.sol\";\nimport {IUserVaultRegistry} from \"../interfaces/IUserVaultRegistry.sol\";\nimport {IRevenueReward} from \"../interfaces/IRevenueReward.sol\";\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\n\nimport {UserVault} from \"./UserVault.sol\";\n\n/**\n * @title UserVaultFactory\n * @author Neverland\n * @notice Factory contract for creating UserVault instances\n */\ncontract UserVaultFactory is IUserVaultFactory, Initializable, ReentrancyGuardUpgradeable {\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address of the UserVault beacon\n    address private userVaultBeacon;\n    /// @notice UserVaultRegistry contract\n    IUserVaultRegistry public userVaultRegistry;\n    /// @notice AAVE PoolAddressesProviderRegistry contract\n    IPoolAddressesProviderRegistry public poolAddressesProviderRegistry;\n    /// @notice RevenueReward contract\n    IRevenueReward public revenueReward;\n\n    /// @notice Mapping of user to their UserVault\n    mapping(address => address) private userVaults;\n\n    /*//////////////////////////////////////////////////////////////\n                              INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes the contract\n     * @param _userVaultBeacon Address of the UserVault beacon\n     * @param _userVaultRegistry UserVaultRegistry contract\n     * @param _poolAddressesProviderRegistry AAVE PoolAddressesProviderRegistry contract\n     * @param _revenueReward RevenueReward contract\n     */\n    function initialize(\n        address _userVaultBeacon,\n        IUserVaultRegistry _userVaultRegistry,\n        IPoolAddressesProviderRegistry _poolAddressesProviderRegistry,\n        IRevenueReward _revenueReward\n    ) external initializer {\n        __ReentrancyGuard_init();\n        CommonChecksLibrary.revertIfZeroAddress(_userVaultBeacon);\n        CommonChecksLibrary.revertIfZeroAddress(address(_userVaultRegistry));\n        CommonChecksLibrary.revertIfZeroAddress(address(_poolAddressesProviderRegistry));\n        CommonChecksLibrary.revertIfZeroAddress(address(_revenueReward));\n\n        userVaultBeacon = _userVaultBeacon;\n        userVaultRegistry = _userVaultRegistry;\n        poolAddressesProviderRegistry = _poolAddressesProviderRegistry;\n        revenueReward = _revenueReward;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUserVaultFactory\n    function getUserVault(address user) external view override returns (address) {\n        return userVaults[user];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUserVaultFactory\n    function getOrCreateUserVault(address user) external override nonReentrant returns (address) {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n\n        address existingUserVault = userVaults[user];\n        if (existingUserVault != address(0)) return existingUserVault;\n\n        address deployedUserVaultAddress = _createUserVault(user);\n        userVaults[user] = deployedUserVaultAddress;\n\n        emit UserVaultCreated(user, deployedUserVaultAddress);\n\n        return deployedUserVaultAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Creates a new UserVault\n     * @param user User address\n     * @return Address of the deployed UserVault\n     */\n    function _createUserVault(address user) internal returns (address) {\n        BeaconProxy userVaultBeaconProxy = new BeaconProxy(userVaultBeacon, \"\");\n        UserVault deployedUserVault = UserVault(address(userVaultBeaconProxy));\n        deployedUserVault.initialize(user, revenueReward, userVaultRegistry, poolAddressesProviderRegistry);\n\n        return address(deployedUserVault);\n    }\n}\n",
        "keccak256": "0x3c4dd2e54d872bf6d6b0a331c6d2d1d6a22ce2bcaec8b49755e4250df63a8a1c",
        "license": "BUSL-1.1"
      }
    },
    "version": 1
  },
  "proxy": "0xe82f2fa836BC5DB42a36C66027c0113BcAA28143",
  "implementation": "0x95AF995C9dcB1b6cFFEe6d81631dab5527884370",
  "proxyAdmin": "0x6400650cED1eD7179143D40b4431c3cC8c068D90"
}