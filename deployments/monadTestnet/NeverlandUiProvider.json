{
  "networkName": "monadTestnet",
  "chainId": 10143,
  "contract": "NeverlandUiProvider",
  "metadata": {
    "compiler": {
      "version": "0.8.30+commit.73712a01"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_dustLock",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_revenueReward",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_dustRewardsController",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_dustOracle",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_aaveLendingPoolAddressProvider",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "name": "AddressZero",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            }
          ],
          "name": "AssetPriceUnavailable",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "PriceOracleUnavailable",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "aaveLendingPoolAddressProvider",
          "outputs": [
            {
              "internalType": "contract IPoolAddressesProvider",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "dustLock",
          "outputs": [
            {
              "internalType": "contract IDustLock",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "dustOracle",
          "outputs": [
            {
              "internalType": "contract INeverlandDustHelper",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "dustRewardsController",
          "outputs": [
            {
              "internalType": "contract IDustRewardsController",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getAllPrices",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "address[]",
                  "name": "tokens",
                  "type": "address[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "prices",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "lastUpdated",
                  "type": "uint256[]"
                },
                {
                  "internalType": "bool[]",
                  "name": "isStale",
                  "type": "bool[]"
                }
              ],
              "internalType": "struct INeverlandUiProvider.PriceData",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            }
          ],
          "name": "getBatchTokenDetails",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "tokenId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "end",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "effectiveStart",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isPermanent",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "votingPower",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rewardReceiver",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "owner",
                  "type": "address"
                }
              ],
              "internalType": "struct INeverlandUiProvider.LockInfo[]",
              "name": "locks",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "tokenId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[]",
                  "name": "revenueRewards",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "emissionRewards",
                  "type": "uint256[]"
                },
                {
                  "internalType": "address[]",
                  "name": "rewardTokens",
                  "type": "address[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "totalEarned",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct INeverlandUiProvider.RewardSummary[]",
              "name": "rewards",
              "type": "tuple[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "limit",
              "type": "uint256"
            }
          ],
          "name": "getEssentialUserView",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "user",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "tokenIds",
                      "type": "uint256[]"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "tokenId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "amount",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "end",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "effectiveStart",
                          "type": "uint256"
                        },
                        {
                          "internalType": "bool",
                          "name": "isPermanent",
                          "type": "bool"
                        },
                        {
                          "internalType": "uint256",
                          "name": "votingPower",
                          "type": "uint256"
                        },
                        {
                          "internalType": "address",
                          "name": "rewardReceiver",
                          "type": "address"
                        },
                        {
                          "internalType": "address",
                          "name": "owner",
                          "type": "address"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.LockInfo[]",
                      "name": "locks",
                      "type": "tuple[]"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "tokenId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "revenueRewards",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "emissionRewards",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "address[]",
                          "name": "rewardTokens",
                          "type": "address[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "totalEarned",
                          "type": "uint256[]"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.RewardSummary[]",
                      "name": "rewardSummaries",
                      "type": "tuple[]"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalVotingPower",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalLockedAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.UserDashboardData",
                  "name": "user",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalVotingPower",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "permanentLockBalance",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address[]",
                      "name": "rewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "totalRewardsPerToken",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256",
                      "name": "epoch",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "activeTokenCount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.GlobalStats",
                  "name": "globalStats",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address[]",
                      "name": "rewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "totalRewards",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.EmissionData",
                  "name": "emissions",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address[]",
                      "name": "rewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "rewardTokenBalances",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "distributionRates",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nextEpochTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "currentEpoch",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "epochRewards",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "nextEpochRewards",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalValueLockedUSD",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.MarketData",
                  "name": "marketData",
                  "type": "tuple"
                }
              ],
              "internalType": "struct INeverlandUiProvider.EssentialUserView",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "limit",
              "type": "uint256"
            }
          ],
          "name": "getExtendedUserView",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "uint256[]",
                      "name": "unlockTimes",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "amounts",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "tokenIds",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.UnlockSchedule",
                  "name": "unlockSchedule",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256[]",
                      "name": "totalRevenue",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "totalEmissions",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "totalHistorical",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.UserRewardsSummary",
                  "name": "rewardsSummary",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address[]",
                      "name": "tokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "prices",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "lastUpdated",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "bool[]",
                      "name": "isStale",
                      "type": "bool[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.PriceData",
                  "name": "allPrices",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "rewardToken",
                      "type": "address"
                    },
                    {
                      "internalType": "address[]",
                      "name": "assets",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "amounts",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.EmissionAssetBreakdown[]",
                  "name": "emissionBreakdowns",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct INeverlandUiProvider.ExtendedUserView",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getGlobalStats",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalVotingPower",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "permanentLockBalance",
                  "type": "uint256"
                },
                {
                  "internalType": "address[]",
                  "name": "rewardTokens",
                  "type": "address[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "totalRewardsPerToken",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256",
                  "name": "epoch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "activeTokenCount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct INeverlandUiProvider.GlobalStats",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getMarketData",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "address[]",
                  "name": "rewardTokens",
                  "type": "address[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "rewardTokenBalances",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "distributionRates",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256",
                  "name": "nextEpochTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentEpoch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[]",
                  "name": "epochRewards",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "nextEpochRewards",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256",
                  "name": "totalValueLockedUSD",
                  "type": "uint256"
                }
              ],
              "internalType": "struct INeverlandUiProvider.MarketData",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getNetworkData",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "currentBlock",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "gasPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct INeverlandUiProvider.NetworkData",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getProtocolMeta",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "dustLock",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "revenueReward",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "dustRewardsController",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "dustOracle",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "earlyWithdrawPenalty",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "minLockAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rewardDistributor",
                  "type": "address"
                },
                {
                  "internalType": "address[]",
                  "name": "revenueRewardTokens",
                  "type": "address[]"
                },
                {
                  "internalType": "address[]",
                  "name": "emissionRewardTokens",
                  "type": "address[]"
                },
                {
                  "internalType": "address[]",
                  "name": "emissionStrategies",
                  "type": "address[]"
                }
              ],
              "internalType": "struct INeverlandUiProvider.ProtocolMeta",
              "name": "meta",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "getTokenDetails",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "tokenId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "end",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "effectiveStart",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isPermanent",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "votingPower",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rewardReceiver",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "owner",
                  "type": "address"
                }
              ],
              "internalType": "struct INeverlandUiProvider.LockInfo",
              "name": "",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "tokenId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[]",
                  "name": "revenueRewards",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "emissionRewards",
                  "type": "uint256[]"
                },
                {
                  "internalType": "address[]",
                  "name": "rewardTokens",
                  "type": "address[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "totalEarned",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct INeverlandUiProvider.RewardSummary",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getUiBootstrap",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "dustLock",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "revenueReward",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "dustRewardsController",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "dustOracle",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "earlyWithdrawPenalty",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "minLockAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address",
                      "name": "rewardDistributor",
                      "type": "address"
                    },
                    {
                      "internalType": "address[]",
                      "name": "revenueRewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "address[]",
                      "name": "emissionRewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "address[]",
                      "name": "emissionStrategies",
                      "type": "address[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.ProtocolMeta",
                  "name": "meta",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalVotingPower",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "permanentLockBalance",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address[]",
                      "name": "rewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "totalRewardsPerToken",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256",
                      "name": "epoch",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "activeTokenCount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.GlobalStats",
                  "name": "globalStats",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address[]",
                      "name": "rewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "rewardTokenBalances",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "distributionRates",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nextEpochTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "currentEpoch",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "epochRewards",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "nextEpochRewards",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalValueLockedUSD",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.MarketData",
                  "name": "marketData",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address[]",
                      "name": "tokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "prices",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "lastUpdated",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "bool[]",
                      "name": "isStale",
                      "type": "bool[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.PriceData",
                  "name": "allPrices",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "currentBlock",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "currentTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "gasPrice",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.NetworkData",
                  "name": "network",
                  "type": "tuple"
                }
              ],
              "internalType": "struct INeverlandUiProvider.UiBootstrap",
              "name": "boot",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "limit",
              "type": "uint256"
            }
          ],
          "name": "getUiFullBundle",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "dustLock",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "revenueReward",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "dustRewardsController",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "dustOracle",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "earlyWithdrawPenalty",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "minLockAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address",
                      "name": "rewardDistributor",
                      "type": "address"
                    },
                    {
                      "internalType": "address[]",
                      "name": "revenueRewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "address[]",
                      "name": "emissionRewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "address[]",
                      "name": "emissionStrategies",
                      "type": "address[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.ProtocolMeta",
                  "name": "meta",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "address",
                          "name": "user",
                          "type": "address"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "tokenIds",
                          "type": "uint256[]"
                        },
                        {
                          "components": [
                            {
                              "internalType": "uint256",
                              "name": "tokenId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "amount",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "end",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "effectiveStart",
                              "type": "uint256"
                            },
                            {
                              "internalType": "bool",
                              "name": "isPermanent",
                              "type": "bool"
                            },
                            {
                              "internalType": "uint256",
                              "name": "votingPower",
                              "type": "uint256"
                            },
                            {
                              "internalType": "address",
                              "name": "rewardReceiver",
                              "type": "address"
                            },
                            {
                              "internalType": "address",
                              "name": "owner",
                              "type": "address"
                            }
                          ],
                          "internalType": "struct INeverlandUiProvider.LockInfo[]",
                          "name": "locks",
                          "type": "tuple[]"
                        },
                        {
                          "components": [
                            {
                              "internalType": "uint256",
                              "name": "tokenId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "revenueRewards",
                              "type": "uint256[]"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "emissionRewards",
                              "type": "uint256[]"
                            },
                            {
                              "internalType": "address[]",
                              "name": "rewardTokens",
                              "type": "address[]"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "totalEarned",
                              "type": "uint256[]"
                            }
                          ],
                          "internalType": "struct INeverlandUiProvider.RewardSummary[]",
                          "name": "rewardSummaries",
                          "type": "tuple[]"
                        },
                        {
                          "internalType": "uint256",
                          "name": "totalVotingPower",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "totalLockedAmount",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.UserDashboardData",
                      "name": "user",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "totalSupply",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "totalVotingPower",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "permanentLockBalance",
                          "type": "uint256"
                        },
                        {
                          "internalType": "address[]",
                          "name": "rewardTokens",
                          "type": "address[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "totalRewardsPerToken",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256",
                          "name": "epoch",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "activeTokenCount",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.GlobalStats",
                      "name": "globalStats",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "address[]",
                          "name": "rewardTokens",
                          "type": "address[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "totalRewards",
                          "type": "uint256[]"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.EmissionData",
                      "name": "emissions",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "address[]",
                          "name": "rewardTokens",
                          "type": "address[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "rewardTokenBalances",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "distributionRates",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256",
                          "name": "nextEpochTimestamp",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "currentEpoch",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "epochRewards",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "nextEpochRewards",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256",
                          "name": "totalValueLockedUSD",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.MarketData",
                      "name": "marketData",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.EssentialUserView",
                  "name": "essential",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "uint256[]",
                          "name": "unlockTimes",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "amounts",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "tokenIds",
                          "type": "uint256[]"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.UnlockSchedule",
                      "name": "unlockSchedule",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256[]",
                          "name": "totalRevenue",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "totalEmissions",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "totalHistorical",
                          "type": "uint256[]"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.UserRewardsSummary",
                      "name": "rewardsSummary",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "address[]",
                          "name": "tokens",
                          "type": "address[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "prices",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "lastUpdated",
                          "type": "uint256[]"
                        },
                        {
                          "internalType": "bool[]",
                          "name": "isStale",
                          "type": "bool[]"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.PriceData",
                      "name": "allPrices",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "address",
                          "name": "rewardToken",
                          "type": "address"
                        },
                        {
                          "internalType": "address[]",
                          "name": "assets",
                          "type": "address[]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "amounts",
                          "type": "uint256[]"
                        }
                      ],
                      "internalType": "struct INeverlandUiProvider.EmissionAssetBreakdown[]",
                      "name": "emissionBreakdowns",
                      "type": "tuple[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.ExtendedUserView",
                  "name": "extended",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "currentBlock",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "currentTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "gasPrice",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.NetworkData",
                  "name": "network",
                  "type": "tuple"
                }
              ],
              "internalType": "struct INeverlandUiProvider.UiFullBundle",
              "name": "bundle",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getUnlockSchedule",
          "outputs": [
            {
              "internalType": "uint256[]",
              "name": "unlockTimes",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "tokenIds",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "limit",
              "type": "uint256"
            }
          ],
          "name": "getUserDashboard",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "user",
                  "type": "address"
                },
                {
                  "internalType": "uint256[]",
                  "name": "tokenIds",
                  "type": "uint256[]"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "tokenId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "end",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "effectiveStart",
                      "type": "uint256"
                    },
                    {
                      "internalType": "bool",
                      "name": "isPermanent",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint256",
                      "name": "votingPower",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address",
                      "name": "rewardReceiver",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "owner",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.LockInfo[]",
                  "name": "locks",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "tokenId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "revenueRewards",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "emissionRewards",
                      "type": "uint256[]"
                    },
                    {
                      "internalType": "address[]",
                      "name": "rewardTokens",
                      "type": "address[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "totalEarned",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct INeverlandUiProvider.RewardSummary[]",
                  "name": "rewardSummaries",
                  "type": "tuple[]"
                },
                {
                  "internalType": "uint256",
                  "name": "totalVotingPower",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalLockedAmount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct INeverlandUiProvider.UserDashboardData",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "rewardToken",
              "type": "address"
            }
          ],
          "name": "getUserEmissionBreakdown",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "rewardTokens",
              "type": "address[]"
            }
          ],
          "name": "getUserEmissionRewards",
          "outputs": [
            {
              "internalType": "uint256[]",
              "name": "emissionRewards",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getUserEmissions",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "rewardTokens",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "totalRewards",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "rewardTokens",
              "type": "address[]"
            }
          ],
          "name": "getUserRevenueRewards",
          "outputs": [
            {
              "internalType": "uint256[]",
              "name": "revenueRewards",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "rewardTokens",
              "type": "address[]"
            }
          ],
          "name": "getUserRewardsSummary",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "uint256[]",
                  "name": "totalRevenue",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "totalEmissions",
                  "type": "uint256[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "totalHistorical",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct INeverlandUiProvider.UserRewardsSummary",
              "name": "summary",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getUserTokenCount",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "count",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "revenueReward",
          "outputs": [
            {
              "internalType": "contract IRevenueReward",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "devdoc": {
        "author": "Neverland",
        "details": "This contract is purely for data aggregation and contains no state-changing functions",
        "kind": "dev",
        "methods": {
          "constructor": {
            "params": {
              "_aaveLendingPoolAddressProvider": "Address of the Aave Lending Pool Address Provider",
              "_dustLock": "Address of the DustLock contract",
              "_dustOracle": "Address of the DUST price oracle",
              "_dustRewardsController": "Address of the DustRewardsController contract",
              "_revenueReward": "Address of the RevenueReward contract"
            }
          },
          "getAllPrices()": {
            "returns": {
              "_0": "PriceData Price information for all tokens"
            }
          },
          "getBatchTokenDetails(uint256[])": {
            "params": {
              "tokenIds": "Array of veNFT token IDs"
            },
            "returns": {
              "locks": "Array of lock information",
              "rewards": "Array of reward summaries"
            }
          },
          "getEssentialUserView(address,uint256,uint256)": {
            "params": {
              "limit": "Maximum number of tokens to include",
              "offset": "Start index for paginated token list",
              "user": "The user address"
            },
            "returns": {
              "_0": "Essential user data bundle"
            }
          },
          "getExtendedUserView(address,uint256,uint256)": {
            "params": {
              "limit": "Maximum number of tokens to include",
              "offset": "Start index for paginated token list",
              "user": "The user address"
            },
            "returns": {
              "_0": "Extended user data bundle"
            }
          },
          "getGlobalStats()": {
            "returns": {
              "_0": "GlobalStats Protocol statistics"
            }
          },
          "getMarketData()": {
            "returns": {
              "_0": "MarketData Market data including prices and TVL"
            }
          },
          "getNetworkData()": {
            "returns": {
              "_0": "NetworkData Network status and system information"
            }
          },
          "getProtocolMeta()": {
            "returns": {
              "meta": "ProtocolMeta containing core addresses, settings, and token lists"
            }
          },
          "getTokenDetails(uint256)": {
            "params": {
              "tokenId": "The veNFT token ID"
            },
            "returns": {
              "_0": "LockInfo Detailed lock information",
              "_1": "RewardSummary Reward summary for the token"
            }
          },
          "getUiBootstrap()": {
            "returns": {
              "boot": "UiBootstrap containing protocol + market + prices + network"
            }
          },
          "getUiFullBundle(address,uint256,uint256)": {
            "params": {
              "limit": "Maximum number of tokens to include",
              "offset": "Start index for paginated token list",
              "user": "The user address"
            },
            "returns": {
              "bundle": "UiFullBundle containing meta, essential, extended, and network"
            }
          },
          "getUnlockSchedule(address)": {
            "params": {
              "user": "The user address"
            },
            "returns": {
              "amounts": "Array of amounts unlocking at each timestamp",
              "tokenIds": "Array of token IDs for each unlock",
              "unlockTimes": "Array of unlock timestamps"
            }
          },
          "getUserDashboard(address,uint256,uint256)": {
            "params": {
              "limit": "Maximum number of tokens to include",
              "offset": "Start index for paginated token list",
              "user": "The user address to get data for"
            },
            "returns": {
              "_0": "Complete user dashboard information"
            }
          },
          "getUserEmissionBreakdown(address,address)": {
            "details": "Lists Aave assets (aTokens and variable debt tokens) that contribute to the user's emissions      and the corresponding reward amounts per asset for the given reward token",
            "params": {
              "rewardToken": "The reward token address to break down",
              "user": "The address to query rewards for"
            },
            "returns": {
              "amounts": "Array of rewards per asset (parallel to `assets`)",
              "assets": "Array of asset addresses contributing to emissions"
            }
          },
          "getUserEmissionRewards(address,address[])": {
            "params": {
              "rewardTokens": "Array of reward token addresses to check",
              "user": "The address to query rewards for"
            },
            "returns": {
              "emissionRewards": "Array of total emission rewards per token"
            }
          },
          "getUserEmissions(address)": {
            "params": {
              "user": "The user address"
            },
            "returns": {
              "rewardTokens": "Array of emission reward token addresses",
              "totalRewards": "Array of total rewards per token"
            }
          },
          "getUserRevenueRewards(address,address[])": {
            "params": {
              "rewardTokens": "Array of reward token addresses to check",
              "user": "The address to query rewards for"
            },
            "returns": {
              "revenueRewards": "Array of total revenue rewards per token"
            }
          },
          "getUserRewardsSummary(address,address[])": {
            "details": "Aggregates all rewards earned by user's veNFTs for the given tokens      Provides separate totals for revenue rewards, emission rewards, and historical rewards",
            "params": {
              "rewardTokens": "Array of reward token addresses to check",
              "user": "The address to query rewards for"
            },
            "returns": {
              "summary": "User rewards summary containing all reward arrays"
            }
          },
          "getUserTokenCount(address)": {
            "params": {
              "user": "The user address"
            },
            "returns": {
              "count": "Number of owned veDUST tokens"
            }
          }
        },
        "title": "NeverlandUiProvider",
        "version": 1
      },
      "userdoc": {
        "errors": {
          "AddressZero()": [
            {
              "notice": "Used when a zero address is provided where not allowed."
            }
          ],
          "AssetPriceUnavailable(address)": [
            {
              "notice": "Thrown when a non-DUST asset price cannot be retrieved or is zero"
            }
          ],
          "PriceOracleUnavailable()": [
            {
              "notice": "Thrown when the price oracle for non-DUST assets is not configured or inaccessible"
            }
          ]
        },
        "kind": "user",
        "methods": {
          "aaveLendingPoolAddressProvider()": {
            "notice": "Aave Lending Pool Address Provider for protocol integration"
          },
          "constructor": {
            "notice": "Initialize the NeverlandUiProvider with core contract addresses"
          },
          "dustLock()": {
            "notice": "DustLock contract for veNFT and voting power data"
          },
          "dustOracle()": {
            "notice": "DustOracle contract for DUST price data"
          },
          "dustRewardsController()": {
            "notice": "DustRewardsController contract for emission rewards data"
          },
          "getAllPrices()": {
            "notice": "Get all token prices"
          },
          "getBatchTokenDetails(uint256[])": {
            "notice": "Get detailed information for multiple tokens efficiently"
          },
          "getEssentialUserView(address,uint256,uint256)": {
            "notice": "Get essential user view with core data"
          },
          "getExtendedUserView(address,uint256,uint256)": {
            "notice": "Get extended user view with detailed analysis data"
          },
          "getGlobalStats()": {
            "notice": "Get protocol-wide statistics"
          },
          "getMarketData()": {
            "notice": "Get market and economic data"
          },
          "getNetworkData()": {
            "notice": "Get network and system data"
          },
          "getProtocolMeta()": {
            "notice": "Get protocol metadata for UI bootstrapping in one call"
          },
          "getTokenDetails(uint256)": {
            "notice": "Get detailed information for a specific token"
          },
          "getUiBootstrap()": {
            "notice": "Get protocol bootstrap data in one call"
          },
          "getUiFullBundle(address,uint256,uint256)": {
            "notice": "Get complete user bundle in one call (protocol + user views)"
          },
          "getUnlockSchedule(address)": {
            "notice": "Get unlock schedule for user's tokens"
          },
          "getUserDashboard(address,uint256,uint256)": {
            "notice": "Get user dashboard with all veNFT positions and rewards"
          },
          "getUserEmissionBreakdown(address,address)": {
            "notice": "Returns per-asset emission rewards for a specific reward token"
          },
          "getUserEmissionRewards(address,address[])": {
            "notice": "Returns user emission rewards for specified reward tokens (simpler array return)"
          },
          "getUserEmissions(address)": {
            "notice": "Get user emission rewards data"
          },
          "getUserRevenueRewards(address,address[])": {
            "notice": "Returns user revenue rewards for specified reward tokens (simpler array return)"
          },
          "getUserRewardsSummary(address,address[])": {
            "notice": "Returns comprehensive reward summary for a user across specified reward tokens"
          },
          "getUserTokenCount(address)": {
            "notice": "Returns the total number of veDUST tokens owned by a user"
          },
          "revenueReward()": {
            "notice": "RevenueReward contract for revenue distribution data"
          }
        },
        "notice": "Aggregates data from DustLock, RevenueReward, and DustRewardsController for efficient UI queries",
        "version": 1
      }
    },
    "settings": {
      "compilationTarget": {
        "src/utils/NeverlandUiProvider.sol": "NeverlandUiProvider"
      },
      "evmVersion": "paris",
      "libraries": {},
      "metadata": {
        "bytecodeHash": "none",
        "useLiteralContent": true
      },
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "remappings": []
    },
    "sources": {
      "@aave-v3-periphery/contracts/misc/interfaces/IEACAggregatorProxy.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\ninterface IEACAggregatorProxy {\n  function decimals() external view returns (uint8);\n\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\n}\n",
        "keccak256": "0x75bb34641419925730f87eeb122521b34cfd953b800212c362770ed1c7c5d719",
        "license": "AGPL-3.0"
      },
      "@aave-v3-periphery/contracts/rewards/interfaces/IRewardsDistributor.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\n/**\n * @title IRewardsDistributor\n * @author Aave\n * @notice Defines the basic interface for a Rewards Distributor.\n */\ninterface IRewardsDistributor {\n  /**\n   * @dev Emitted when the configuration of the rewards of an asset is updated.\n   * @param asset The address of the incentivized asset\n   * @param reward The address of the reward token\n   * @param oldEmission The old emissions per second value of the reward distribution\n   * @param newEmission The new emissions per second value of the reward distribution\n   * @param oldDistributionEnd The old end timestamp of the reward distribution\n   * @param newDistributionEnd The new end timestamp of the reward distribution\n   * @param assetIndex The index of the asset distribution\n   */\n  event AssetConfigUpdated(\n    address indexed asset,\n    address indexed reward,\n    uint256 oldEmission,\n    uint256 newEmission,\n    uint256 oldDistributionEnd,\n    uint256 newDistributionEnd,\n    uint256 assetIndex\n  );\n\n  /**\n   * @dev Emitted when rewards of an asset are accrued on behalf of a user.\n   * @param asset The address of the incentivized asset\n   * @param reward The address of the reward token\n   * @param user The address of the user that rewards are accrued on behalf of\n   * @param assetIndex The index of the asset distribution\n   * @param userIndex The index of the asset distribution on behalf of the user\n   * @param rewardsAccrued The amount of rewards accrued\n   */\n  event Accrued(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    uint256 assetIndex,\n    uint256 userIndex,\n    uint256 rewardsAccrued\n  );\n\n  /**\n   * @dev Sets the end date for the distribution\n   * @param asset The asset to incentivize\n   * @param reward The reward token that incentives the asset\n   * @param newDistributionEnd The end date of the incentivization, in unix time format\n   **/\n  function setDistributionEnd(address asset, address reward, uint32 newDistributionEnd) external;\n\n  /**\n   * @dev Sets the emission per second of a set of reward distributions\n   * @param asset The asset is being incentivized\n   * @param rewards List of reward addresses are being distributed\n   * @param newEmissionsPerSecond List of new reward emissions per second\n   */\n  function setEmissionPerSecond(\n    address asset,\n    address[] calldata rewards,\n    uint88[] calldata newEmissionsPerSecond\n  ) external;\n\n  /**\n   * @dev Gets the end date for the distribution\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The timestamp with the end of the distribution, in unix time format\n   **/\n  function getDistributionEnd(address asset, address reward) external view returns (uint256);\n\n  /**\n   * @dev Returns the index of a user on a reward distribution\n   * @param user Address of the user\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The current user asset index, not including new distributions\n   **/\n  function getUserAssetIndex(\n    address user,\n    address asset,\n    address reward\n  ) external view returns (uint256);\n\n  /**\n   * @dev Returns the configuration of the distribution reward for a certain asset\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The index of the asset distribution\n   * @return The emission per second of the reward distribution\n   * @return The timestamp of the last update of the index\n   * @return The timestamp of the distribution end\n   **/\n  function getRewardsData(\n    address asset,\n    address reward\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  /**\n   * @dev Calculates the next value of an specific distribution index, with validations.\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The old index of the asset distribution\n   * @return The new index of the asset distribution\n   **/\n  function getAssetIndex(address asset, address reward) external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the list of available reward token addresses of an incentivized asset\n   * @param asset The incentivized asset\n   * @return List of rewards addresses of the input asset\n   **/\n  function getRewardsByAsset(address asset) external view returns (address[] memory);\n\n  /**\n   * @dev Returns the list of available reward addresses\n   * @return List of rewards supported in this contract\n   **/\n  function getRewardsList() external view returns (address[] memory);\n\n  /**\n   * @dev Returns the accrued rewards balance of a user, not including virtually accrued rewards since last distribution.\n   * @param user The address of the user\n   * @param reward The address of the reward token\n   * @return Unclaimed rewards, not including new distributions\n   **/\n  function getUserAccruedRewards(address user, address reward) external view returns (uint256);\n\n  /**\n   * @dev Returns a single rewards balance of a user, including virtually accrued and unrealized claimable rewards.\n   * @param assets List of incentivized assets to check eligible distributions\n   * @param user The address of the user\n   * @param reward The address of the reward token\n   * @return The rewards amount\n   **/\n  function getUserRewards(\n    address[] calldata assets,\n    address user,\n    address reward\n  ) external view returns (uint256);\n\n  /**\n   * @dev Returns a list all rewards of a user, including already accrued and unrealized claimable rewards\n   * @param assets List of incentivized assets to check eligible distributions\n   * @param user The address of the user\n   * @return The list of reward addresses\n   * @return The list of unclaimed amount of rewards\n   **/\n  function getAllUserRewards(\n    address[] calldata assets,\n    address user\n  ) external view returns (address[] memory, uint256[] memory);\n\n  /**\n   * @dev Returns the decimals of an asset to calculate the distribution delta\n   * @param asset The address to retrieve decimals\n   * @return The decimals of an underlying asset\n   */\n  function getAssetDecimals(address asset) external view returns (uint8);\n\n  /**\n   * @dev Returns the address of the emission manager\n   * @return The address of the EmissionManager\n   */\n  function EMISSION_MANAGER() external view returns (address);\n\n  /**\n   * @dev Returns the address of the emission manager.\n   * Deprecated: This getter is maintained for compatibility purposes. Use the `EMISSION_MANAGER()` function instead.\n   * @return The address of the EmissionManager\n   */\n  function getEmissionManager() external view returns (address);\n}\n",
        "keccak256": "0xd393efd85f696114f9ab69e6bfdcbf3a2bcf16ef5002516d56a0f0359e3d9bba",
        "license": "AGPL-3.0"
      },
      "@aave-v3-periphery/contracts/rewards/interfaces/ITransferStrategyBase.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\ninterface ITransferStrategyBase {\n  event EmergencyWithdrawal(\n    address indexed caller,\n    address indexed token,\n    address indexed to,\n    uint256 amount\n  );\n\n  /**\n   * @dev Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n   * @param to Account to transfer rewards\n   * @param reward Address of the reward token\n   * @param amount Amount to transfer to the \"to\" address parameter\n   * @return Returns true bool if transfer logic succeeds\n   */\n  function performTransfer(address to, address reward, uint256 amount) external returns (bool);\n\n  /**\n   * @return Returns the address of the Incentives Controller\n   */\n  function getIncentivesController() external view returns (address);\n\n  /**\n   * @return Returns the address of the Rewards admin\n   */\n  function getRewardsAdmin() external view returns (address);\n\n  /**\n   * @dev Perform an emergency token withdrawal only callable by the Rewards admin\n   * @param token Address of the token to withdraw funds from this contract\n   * @param to Address of the recipient of the withdrawal\n   * @param amount Amount of the withdrawal\n   */\n  function emergencyWithdrawal(address token, address to, uint256 amount) external;\n}\n",
        "keccak256": "0xa52a6dc237879acbed7325787ce58238a3afd626fa2ed827d4e321d2e4ef51ad",
        "license": "AGPL-3.0"
      },
      "@aave-v3-periphery/contracts/rewards/libraries/RewardsDataTypes.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport {ITransferStrategyBase} from '../interfaces/ITransferStrategyBase.sol';\nimport {IEACAggregatorProxy} from '../../misc/interfaces/IEACAggregatorProxy.sol';\n\nlibrary RewardsDataTypes {\n  struct RewardsConfigInput {\n    uint88 emissionPerSecond;\n    uint256 totalSupply;\n    uint32 distributionEnd;\n    address asset;\n    address reward;\n    ITransferStrategyBase transferStrategy;\n    IEACAggregatorProxy rewardOracle;\n  }\n\n  struct UserAssetBalance {\n    address asset;\n    uint256 userBalance;\n    uint256 totalSupply;\n  }\n\n  struct UserData {\n    // Liquidity index of the reward distribution for the user\n    uint104 index;\n    // Amount of accrued rewards for the user since last user index update\n    uint128 accrued;\n  }\n\n  struct RewardData {\n    // Liquidity index of the reward distribution\n    uint104 index;\n    // Amount of reward tokens distributed per second\n    uint88 emissionPerSecond;\n    // Timestamp of the last reward index update\n    uint32 lastUpdateTimestamp;\n    // The end of the distribution of rewards (in seconds)\n    uint32 distributionEnd;\n    // Map of user addresses and their rewards data (userAddress => userData)\n    mapping(address => UserData) usersData;\n  }\n\n  struct AssetData {\n    // Map of reward token addresses and their data (rewardTokenAddress => rewardData)\n    mapping(address => RewardData) rewards;\n    // List of reward token addresses for the asset\n    mapping(uint128 => address) availableRewards;\n    // Count of reward tokens for the asset\n    uint128 availableRewardsCount;\n    // Number of decimals of the asset\n    uint8 decimals;\n  }\n}\n",
        "keccak256": "0xaaa314b4e9f40878f4fd20e99075fe60309c9e223a5b8c244aaaeb7229d8c318",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n",
        "keccak256": "0x33d4308d9407b4ee2297fc4ba5acce1a96a6c658189e2778a4f6b90e032fb3b5",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/interfaces/IPoolDataProvider.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IPoolDataProvider\n * @author Aave\n * @notice Defines the basic interface of a PoolDataProvider\n */\ninterface IPoolDataProvider {\n  struct TokenData {\n    string symbol;\n    address tokenAddress;\n  }\n\n  /**\n   * @notice Returns the address for the PoolAddressesProvider contract.\n   * @return The address for the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the list of the existing reserves in the pool.\n   * @dev Handling MKR and ETH in a different way since they do not have standard `symbol` functions.\n   * @return The list of reserves, pairs of symbols and addresses\n   */\n  function getAllReservesTokens() external view returns (TokenData[] memory);\n\n  /**\n   * @notice Returns the list of the existing ATokens in the pool.\n   * @return The list of ATokens, pairs of symbols and addresses\n   */\n  function getAllATokens() external view returns (TokenData[] memory);\n\n  /**\n   * @notice Returns the configuration data of the reserve\n   * @dev Not returning borrow and supply caps for compatibility, nor pause flag\n   * @param asset The address of the underlying asset of the reserve\n   * @return decimals The number of decimals of the reserve\n   * @return ltv The ltv of the reserve\n   * @return liquidationThreshold The liquidationThreshold of the reserve\n   * @return liquidationBonus The liquidationBonus of the reserve\n   * @return reserveFactor The reserveFactor of the reserve\n   * @return usageAsCollateralEnabled True if the usage as collateral is enabled, false otherwise\n   * @return borrowingEnabled True if borrowing is enabled, false otherwise\n   * @return stableBorrowRateEnabled True if stable rate borrowing is enabled, false otherwise\n   * @return isActive True if it is active, false otherwise\n   * @return isFrozen True if it is frozen, false otherwise\n   */\n  function getReserveConfigurationData(\n    address asset\n  )\n    external\n    view\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFrozen\n    );\n\n  /**\n   * @notice Returns the efficiency mode category of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The eMode id of the reserve\n   */\n  function getReserveEModeCategory(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the caps parameters of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return borrowCap The borrow cap of the reserve\n   * @return supplyCap The supply cap of the reserve\n   */\n  function getReserveCaps(\n    address asset\n  ) external view returns (uint256 borrowCap, uint256 supplyCap);\n\n  /**\n   * @notice Returns if the pool is paused\n   * @param asset The address of the underlying asset of the reserve\n   * @return isPaused True if the pool is paused, false otherwise\n   */\n  function getPaused(address asset) external view returns (bool isPaused);\n\n  /**\n   * @notice Returns the siloed borrowing flag\n   * @param asset The address of the underlying asset of the reserve\n   * @return True if the asset is siloed for borrowing\n   */\n  function getSiloedBorrowing(address asset) external view returns (bool);\n\n  /**\n   * @notice Returns the protocol fee on the liquidation bonus\n   * @param asset The address of the underlying asset of the reserve\n   * @return The protocol fee on liquidation\n   */\n  function getLiquidationProtocolFee(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the unbacked mint cap of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The unbacked mint cap of the reserve\n   */\n  function getUnbackedMintCap(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the debt ceiling of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The debt ceiling of the reserve\n   */\n  function getDebtCeiling(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the debt ceiling decimals\n   * @return The debt ceiling decimals\n   */\n  function getDebtCeilingDecimals() external pure returns (uint256);\n\n  /**\n   * @notice Returns the reserve data\n   * @param asset The address of the underlying asset of the reserve\n   * @return unbacked The amount of unbacked tokens\n   * @return accruedToTreasuryScaled The scaled amount of tokens accrued to treasury that is to be minted\n   * @return totalAToken The total supply of the aToken\n   * @return totalStableDebt The total stable debt of the reserve\n   * @return totalVariableDebt The total variable debt of the reserve\n   * @return liquidityRate The liquidity rate of the reserve\n   * @return variableBorrowRate The variable borrow rate of the reserve\n   * @return stableBorrowRate The stable borrow rate of the reserve\n   * @return averageStableBorrowRate The average stable borrow rate of the reserve\n   * @return liquidityIndex The liquidity index of the reserve\n   * @return variableBorrowIndex The variable borrow index of the reserve\n   * @return lastUpdateTimestamp The timestamp of the last update of the reserve\n   */\n  function getReserveData(\n    address asset\n  )\n    external\n    view\n    returns (\n      uint256 unbacked,\n      uint256 accruedToTreasuryScaled,\n      uint256 totalAToken,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      uint256 liquidityRate,\n      uint256 variableBorrowRate,\n      uint256 stableBorrowRate,\n      uint256 averageStableBorrowRate,\n      uint256 liquidityIndex,\n      uint256 variableBorrowIndex,\n      uint40 lastUpdateTimestamp\n    );\n\n  /**\n   * @notice Returns the total supply of aTokens for a given asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The total supply of the aToken\n   */\n  function getATokenTotalSupply(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the total debt for a given asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The total debt for asset\n   */\n  function getTotalDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the user data in a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param user The address of the user\n   * @return currentATokenBalance The current AToken balance of the user\n   * @return currentStableDebt The current stable debt of the user\n   * @return currentVariableDebt The current variable debt of the user\n   * @return principalStableDebt The principal stable debt of the user\n   * @return scaledVariableDebt The scaled variable debt of the user\n   * @return stableBorrowRate The stable borrow rate of the user\n   * @return liquidityRate The liquidity rate of the reserve\n   * @return stableRateLastUpdated The timestamp of the last update of the user stable rate\n   * @return usageAsCollateralEnabled True if the user is using the asset as collateral, false\n   *         otherwise\n   */\n  function getUserReserveData(\n    address asset,\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 currentATokenBalance,\n      uint256 currentStableDebt,\n      uint256 currentVariableDebt,\n      uint256 principalStableDebt,\n      uint256 scaledVariableDebt,\n      uint256 stableBorrowRate,\n      uint256 liquidityRate,\n      uint40 stableRateLastUpdated,\n      bool usageAsCollateralEnabled\n    );\n\n  /**\n   * @notice Returns the token addresses of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return aTokenAddress The AToken address of the reserve\n   * @return stableDebtTokenAddress The StableDebtToken address of the reserve\n   * @return variableDebtTokenAddress The VariableDebtToken address of the reserve\n   */\n  function getReserveTokensAddresses(\n    address asset\n  )\n    external\n    view\n    returns (\n      address aTokenAddress,\n      address stableDebtTokenAddress,\n      address variableDebtTokenAddress\n    );\n\n  /**\n   * @notice Returns the address of the Interest Rate strategy\n   * @param asset The address of the underlying asset of the reserve\n   * @return irStrategyAddress The address of the Interest Rate strategy\n   */\n  function getInterestRateStrategyAddress(\n    address asset\n  ) external view returns (address irStrategyAddress);\n\n  /**\n   * @notice Returns whether the reserve has FlashLoans enabled or disabled\n   * @param asset The address of the underlying asset of the reserve\n   * @return True if FlashLoans are enabled, false otherwise\n   */\n  function getFlashLoanEnabled(address asset) external view returns (bool);\n}\n",
        "keccak256": "0xeb42959448d545d6ee49985e4212f54d01fe3c653f6f65cfc4061983df39bf1e",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/interfaces/IPriceOracleGetter.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n",
        "keccak256": "0xfe72e94869ca91465a7f57282b8d367b2c9ba798fdc13ac8546304db8d971df6",
        "license": "AGPL-3.0"
      },
      "@openzeppelin/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n",
        "keccak256": "0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC4906.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n",
        "keccak256": "0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC6372.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n",
        "keccak256": "0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n",
        "keccak256": "0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n",
        "keccak256": "0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n",
        "keccak256": "0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
        "keccak256": "0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
        "keccak256": "0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1",
        "license": "MIT"
      },
      "src/interfaces/IDustLock.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {IRevenueReward} from \"./IRevenueReward.sol\";\n\n/**\n * @title IDustLock Interface\n * @notice Interface for the DustLock contract that manages voting escrow NFTs (veNFTs)\n * @dev Combines ERC721 with vote-escrow functionality for governance and reward distribution\n */\ninterface IDustLock is IERC4906, IERC6372, IERC721Metadata {\n    /**\n     * @notice Structure representing a locked token position\n     * @dev Used to track the amount of tokens locked, when they unlock, and if they're permanently locked\n     * @param amount Amount of tokens locked in int256 format for consistency with precision calculations\n     * @param effectiveStart Effective start time for penalty calculations (weighted average on lock operations)\n     * @param end Timestamp when tokens unlock (0 for permanent locks)\n     * @param isPermanent Whether this is a permanent lock that cannot be withdrawn normally\n     */\n    struct LockedBalance {\n        int256 amount;\n        uint256 effectiveStart;\n        uint256 end;\n        bool isPermanent;\n    }\n\n    /**\n     * @notice Checkpoint for tracking user voting power at a specific point in time\n     * @dev Used in the vote-escrow system to track decay of voting power over time\n     * @param bias Voting power at time ts\n     * @param slope Rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanent Amount of permanent (non-decaying) voting power\n     */\n    struct UserPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanent;\n    }\n\n    /**\n     * @notice Global checkpoint for tracking total voting power at a specific point in time\n     * @dev Similar to UserPoint but tracks system-wide totals\n     * @param bias Total voting power at time ts\n     * @param slope Total rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanentLockBalance Total amount of permanently locked tokens\n     */\n    struct GlobalPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanentLockBalance;\n    }\n\n    /**\n     * @notice Types of deposit operations supported by the veNFT system\n     * @param DEPOSIT_FOR_TYPE Adding tokens to an existing lock owned by someone else\n     * @param CREATE_LOCK_TYPE Creating a new lock position\n     * @param INCREASE_LOCK_AMOUNT Adding more tokens to an existing lock\n     * @param INCREASE_UNLOCK_TIME Extending the lock duration of an existing lock\n     */\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /// @notice Error thrown when the locked amount is less than minLockAmount\n    error AmountTooSmall();\n\n    /// @notice Error thrown when the requested amount exceeds available balance\n    error AmountTooBig();\n\n    /// @notice Error thrown when an ERC721 receiver contract rejects the tokens\n    error ERC721ReceiverRejectedTokens();\n\n    /// @notice Error thrown when transferring to an address that doesn't implement ERC721Receiver\n    error ERC721TransferToNonERC721ReceiverImplementer();\n\n    /// @notice Error thrown when an early withdraw penalty value is invalid (>=10000)\n    error InvalidWithdrawPenalty();\n\n    /// @notice Error thrown when the lock duration doesn't extend beyond the current time\n    error LockDurationNotInFuture();\n\n    /// @notice Error thrown when the lock duration exceeds the maximum allowed time\n    error LockDurationTooLong();\n\n    /// @notice Error thrown when the lock duration is less than the minimum required time\n    error LockDurationTooShort();\n\n    /// @notice Error thrown when trying to depositFor to a lock expiring within MINTIME\n    error DepositForLockDurationTooShort();\n\n    /// @notice Error thrown when trying to perform an operation on an expired lock\n    error LockExpired();\n\n    /// @notice Error thrown when trying to withdraw from a lock that hasn't expired yet\n    error LockNotExpired();\n\n    /// @notice Error thrown when no lock is found for the specified token ID\n    error NoLockFound();\n\n    /// @notice Error thrown when the caller is neither the owner nor approved for the token\n    error NotApprovedOrOwner();\n\n    /// @notice Error thrown when trying to unlock a non-permanent lock using unlockPermanent\n    error NotPermanentLock();\n\n    /// @notice Error thrown when the caller is not the owner of the token\n    error NotOwner();\n\n    /// @notice Error thrown when a team-only function is called by a non-team address\n    error NotTeam();\n\n    /// @notice Error thrown when a pending team function is called by a non-pending team address\n    error NotPendingTeam();\n\n    /// @notice Error thrown when trying to withdraw or modify a permanent lock\n    error PermanentLock();\n\n    /// @notice Error thrown when attempting to merge a veNFT with itself\n    error SameNFT();\n\n    /// @notice Error thrown when splitting is not allowed for the user\n    error SplitNotAllowed();\n\n    /// @notice Error thrown when trying to add a token that already has an owner\n    error AlreadyOwned();\n\n    /// @notice Error thrown when setting a revenue reward contract that is not a deployed contract\n    error InvalidRevenueRewardContract();\n\n    /**\n     * @notice Emitted when tokens are deposited into the veNFT system\n     * @param provider Address depositing the tokens\n     * @param tokenId ID of the veNFT being created or modified\n     * @param depositType Type of deposit operation (create, increase amount, etc.)\n     * @param value Amount of tokens deposited\n     * @param locktime Timestamp when the lock expires\n     * @param ts Timestamp when the deposit occurred\n     */\n    event Deposit(\n        address indexed provider,\n        uint256 indexed tokenId,\n        DepositType indexed depositType,\n        uint256 value,\n        uint256 locktime,\n        uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn before the lock expiry with a penalty\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Original locked amount\n     * @param amountReturned Amount returned to the user after penalty\n     * @param ts Timestamp when the early withdrawal occurred\n     */\n    event EarlyWithdraw(\n        address indexed provider, uint256 indexed tokenId, uint256 value, uint256 amountReturned, uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn after the lock expiry\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Amount of tokens withdrawn\n     * @param ts Timestamp when the withdrawal occurred\n     */\n    event Withdraw(address indexed provider, uint256 indexed tokenId, uint256 value, uint256 ts);\n\n    /**\n     * @notice Emitted when a lock is converted to a permanent lock\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being locked permanently\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was created\n     */\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when a permanent lock is unlocked by governance\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being unlocked\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was unlocked\n     */\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when the total supply of locked tokens changes\n     * @param prevSupply Previous total locked supply\n     * @param supply New total locked supply\n     */\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    /**\n     * @notice Emitted when two veNFTs are merged\n     * @param _sender Address initiating the merge\n     * @param _from Source veNFT ID (burned in the process)\n     * @param _to Destination veNFT ID (receives combined balance)\n     * @param _amountFrom Amount of tokens in the source veNFT\n     * @param _amountTo Amount of tokens in the destination veNFT before merge\n     * @param _amountFinal Final amount of tokens in the destination veNFT after merge\n     * @param _locktime New lock expiry time for the merged veNFT\n     * @param _ts Timestamp when the merge occurred\n     */\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a veNFT is split into two separate veNFTs\n     * @param _from Original veNFT ID being split (burned in the process)\n     * @param _tokenId1 First new veNFT ID created from the split\n     * @param _tokenId2 Second new veNFT ID created from the split\n     * @param _sender Address initiating the split\n     * @param _splitAmount1 Amount of tokens allocated to the first veNFT\n     * @param _splitAmount2 Amount of tokens allocated to the second veNFT\n     * @param _locktime Lock expiry time for both new veNFTs\n     * @param _ts Timestamp when the split occurred\n     */\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a new team address is proposed\n     * @param currentTeam The current team address that proposed the change\n     * @param proposedTeam The newly proposed team address\n     */\n    event TeamProposed(address indexed currentTeam, address indexed proposedTeam);\n\n    /**\n     * @notice Emitted when a proposed team address accepts ownership\n     * @param oldTeam The previous team address\n     * @param newTeam The new team address that accepted ownership\n     */\n    event TeamAccepted(address indexed oldTeam, address indexed newTeam);\n\n    /**\n     * @notice Emitted when a team proposal is cancelled\n     * @param currentTeam The current team address that cancelled the proposal\n     * @param cancelledTeam The proposed team address that was cancelled\n     */\n    event TeamProposalCancelled(address indexed currentTeam, address indexed cancelledTeam);\n\n    /**\n     * @notice Emitted when the early withdraw penalty is updated\n     * @param oldPenalty Previous penalty in basis points\n     * @param newPenalty New penalty in basis points\n     */\n    event EarlyWithdrawPenaltyUpdated(uint256 oldPenalty, uint256 newPenalty);\n\n    /**\n     * @notice Emitted when the early withdraw treasury address is updated\n     * @param oldTreasury Previous treasury address\n     * @param newTreasury New treasury address\n     */\n    event EarlyWithdrawTreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Emitted when the minimum lock amount is updated\n     * @param oldAmount Previous minimum lock amount\n     * @param newAmount New minimum lock amount\n     */\n    event MinLockAmountUpdated(uint256 oldAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted when the revenue reward contract is updated\n     * @param oldReward Previous revenue reward contract address\n     * @param newReward New revenue reward contract address\n     */\n    event RevenueRewardUpdated(address indexed oldReward, address indexed newReward);\n\n    /**\n     * @notice Emitted when the split permission is toggled for an account\n     * @param account Address whose permission is updated\n     * @param allowed Whether splitting is now allowed for the account\n     */\n    event SplitPermissionUpdated(address indexed account, bool allowed);\n\n    /**\n     * @notice Emitted when the base URI is updated\n     * @param oldBaseURI Previous base URI\n     * @param newBaseURI New base URI\n     */\n    event BaseURIUpdated(string oldBaseURI, string newBaseURI);\n\n    /*//////////////////////////////////////////////////////////////\n                                STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Address of Meta-tx Forwarder\n     * @return The trusted forwarder address used for meta-transactions\n     */\n    function forwarder() external view returns (address);\n\n    /**\n     * @notice Address of token (DUST) used to create a veNFT\n     * @return The ERC20 token address used to lock and mint veNFTs\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Address of Neverland Team multisig\n     * @return The address of the current team multisig with administrative privileges\n     */\n    function team() external view returns (address);\n\n    /**\n     * @notice Address of pending team for two-step ownership transfer\n     * @return The address of the pending team, or address(0) if no proposal exists\n     */\n    function pendingTeam() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Proposes a new team address for two-step ownership transfer\n     * @dev This is the first step of a two-step ownership transfer process.\n     *      Only the current team can propose a new team address.\n     *      The proposed address must accept ownership to complete the transfer.\n     *      This prevents accidental loss of admin control due to typos or wrong addresses.\n     * @param _newTeam The address of the proposed new team multisig\n     */\n    function proposeTeam(address _newTeam) external;\n\n    /**\n     * @notice Accepts the proposed team address to complete the ownership transfer\n     * @dev This is the second step of the two-step ownership transfer process.\n     *      Only the pending team address can call this function.\n     *      Once called, the caller becomes the new team and the pending team is cleared.\n     *      This ensures that the new team controls the proposed address.\n     */\n    function acceptTeam() external;\n\n    /**\n     * @notice Cancels the pending team proposal\n     * @dev Allows the current team to cancel a pending ownership transfer.\n     *      Only the current team can call this function.\n     *      This is useful if the team made an error in the proposed address.\n     *      After cancellation, a new proposal can be made.\n     */\n    function cancelTeamProposal() external;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the name of the token\n     * @return The name of the veNFT token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token\n     * @return The symbol of the veNFT token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns the version of the contract\n     * @return The current version string of the contract\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice Updates the base URI for computing tokenURI\n     * @dev Can only be called by the team address\n     * @param newBaseURI The new base URI to set for all tokens\n     */\n    function setBaseURI(string memory newBaseURI) external;\n\n    /**\n     * @notice Current total count of veNFT tokens\n     * @dev Used as a counter for minting new tokens and assigning IDs\n     * @return The current highest token ID value\n     */\n    function tokenId() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the tokenId owned by `_owner` at position `_index`\n     * @param _owner Owner address to query\n     * @param _index Index of the token within the owner's list\n     * @return _tokenId The tokenId at the given index for the owner\n     */\n    function ownerToNFTokenIdList(address _owner, uint256 _index) external view returns (uint256 _tokenId);\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @notice Check whether spender is owner or an approved user for a given veNFT\n     * @param _spender The address to approve for the tokenId\n     * @param _tokenId The ID of the veNFT to be approved\n     * @return True if `_spender` is owner or approved for `_tokenId`, false otherwise\n     */\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Total count of epochs witnessed since contract creation\n     * @return The current epoch number\n     */\n    function epoch() external view returns (uint256);\n\n    /**\n     * @notice Total amount of tokens currently locked in the contract\n     * @return The total supply of locked tokens\n     */\n    function supply() external view returns (uint256);\n\n    /**\n     * @notice Aggregate balance of permanently locked tokens\n     * @dev These tokens cannot be withdrawn through normal means\n     * @return The total amount of permanently locked tokens\n     */\n    function permanentLockBalance() external view returns (uint256);\n\n    /**\n     * @notice Percentage of penalty applied to early withdrawals (in basis points)\n     * @dev Value is between 0 and 10000 (0% to 100%)\n     * @return The current penalty percentage in basis points\n     */\n    function earlyWithdrawPenalty() external view returns (uint256);\n\n    /**\n     * @notice Address that receives penalty fees from early withdrawals\n     * @return The address of the treasury that collects early withdrawal penalties\n     */\n    function earlyWithdrawTreasury() external view returns (address);\n\n    /**\n     * @notice Get the current epoch number for a specific veNFT\n     * @param _tokenId The ID of the veNFT to check\n     * @return _epoch The current epoch number for the specified veNFT\n     */\n    function userPointEpoch(uint256 _tokenId) external view returns (uint256 _epoch);\n\n    /**\n     * @notice Retrieve the scheduled slope change at a given timestamp\n     * @dev Used to calculate future voting power changes due to lock expirations\n     * @param _timestamp The timestamp to check for slope changes\n     * @return The net change in slope (negative value means decrease in voting power)\n     */\n    function slopeChanges(uint256 _timestamp) external view returns (int256);\n\n    /**\n     * @notice Check if an account has permission to split veNFTs\n     * @dev Used to control which addresses can perform veNFT splitting operations\n     * @param _account The address to check for split permission\n     * @return True if the account can split veNFTs, false otherwise\n     */\n    function canSplit(address _account) external view returns (bool);\n\n    /**\n     * @notice Retrieve a global checkpoint at a specific index\n     * @dev Used to track historical voting power across all tokens at different points in time\n     * @param _loc The index of the checkpoint to retrieve\n     * @return The GlobalPoint data at the specified index\n     */\n    function pointHistory(uint256 _loc) external view returns (GlobalPoint memory);\n\n    /**\n     * @notice Get the lock details for a specific veNFT\n     * @dev Returns information about lock amount, end time, and permanent status\n     * @param _tokenId The ID of the veNFT to query\n     * @return The LockedBalance struct containing lock information\n     */\n    function locked(uint256 _tokenId) external view returns (LockedBalance memory);\n\n    /**\n     * @notice Retrieve a user checkpoint for a specific veNFT at a given index\n     * @dev Used to track historical voting power for individual tokens\n     * @param _tokenId The ID of the veNFT to query\n     * @param _loc The index of the user checkpoint to retrieve\n     * @return The UserPoint data at the specified index for the given token\n     */\n    function userPointHistory(uint256 _tokenId, uint256 _loc) external view returns (UserPoint memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Create a global checkpoint to record the current state of voting power\n     * @dev Updates the global point history with current voting power data\n     *      This is called automatically by most state-changing functions\n     *      but can be called manually to ensure up-to-date on-chain data\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT lock\n     * @dev Anyone (even a smart contract) can deposit tokens for someone else's lock\n     *      The deposit increases the lock amount but does not extend the lock time\n     *      Cannot be used for locks that have already expired\n     * @param _tokenId The ID of the veNFT to deposit for\n     * @param _value Amount of tokens to add to the existing lock\n     */\n    function depositFor(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Create a new lock by depositing tokens for the caller\n     * @dev Creates a new veNFT representing the locked tokens\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return The ID of the newly created veNFT\n     */\n    function createLock(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock by depositing tokens for another address\n     * @dev Creates a new veNFT representing the locked tokens and assigns it to the specified recipient\n     *      This is useful for protocols that want to create locks on behalf of their users\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return The ID of the newly created veNFT\n     */\n    function createLockFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for the caller and immediately make it permanent\n     * @dev UX convenience to perform \"create lock\" and \"make permanent\" in a single transaction\n     *      Follows the same validation as `createLock` (min amount, duration bounds, week rounding)\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanent(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for `to` and immediately make it permanent\n     * @dev UX convenience to mint the veNFT to `to` and set permanence in one transaction\n     *      Uses `to` as the owner for auth semantics; validation mirrors `createLock`\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanentFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT without modifying the unlock time\n     * @dev Increases the amount of tokens in a lock while keeping the same unlock date\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to increase the amount for\n     * @param _value Additional amount of tokens to add to the lock\n     */\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Extend the unlock time for an existing veNFT lock\n     * @dev Increases the lock duration without changing the token amount\n     *      Cannot extend lock time of permanent locks\n     *      New lock time is rounded down to the nearest week\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to extend the lock duration for\n     * @param _lockDuration New number of seconds until tokens unlock (from current time)\n     */\n    function increaseUnlockTime(uint256 _tokenId, uint256 _lockDuration) external;\n\n    /**\n     * @notice Withdraw all tokens from an expired lock for `_tokenId`\n     * @dev Only possible if the lock has expired and is not a permanent lock\n     *      This function burns the veNFT and returns the locked tokens to the owner\n     *      IMPORTANT: Any unclaimed rebases or rewards will no longer be claimable after calling this\n     *      Users should claim all rebases and rewards prior to withdrawing\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw tokens from\n     */\n    function withdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Withdraw tokens from a lock before it expires, with a time-proportional penalty\n     * @dev Allows users to exit a lock early but with a penalty fee applied\n     *      The penalty is proportional to both `earlyWithdrawPenalty` and remaining time until unlock\n     *      If the lock is permanent, it is internally converted back to a standard time-lock first and\n     *      the early withdraw penalty is computed using the restored lock window. Penalty fees are sent\n     *      to the `earlyWithdrawTreasury` address. Burns the veNFT and returns the nonpenalized portion\n     *      of tokens to the owner. Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw early from\n     */\n    function earlyWithdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Sets the early withdrawal penalty percentage\n     * @dev Can only be called by the team address\n     *      Value is in basis points (0-10000), where 10000 = 100%\n     * @param _earlyWithdrawPenalty The new penalty percentage in basis points\n     */\n    function setEarlyWithdrawPenalty(uint256 _earlyWithdrawPenalty) external;\n\n    /**\n     * @notice Sets the treasury address that will receive penalty fees from early withdrawals\n     * @dev Can only be called by the team address\n     *      The treasury address receives the penalty portion of tokens from early withdrawals\n     * @param _account The address of the new treasury that will receive penalty fees\n     */\n    function setEarlyWithdrawTreasury(address _account) external;\n\n    /**\n     * @notice Merges two veNFTs by combining their locked tokens into a single veNFT\n     * @dev The source veNFT is burned and its tokens are added to the destination veNFT\n     *      The lock duration/semantics of the destination veNFT are preserved\n     *      Rules:\n     *      - permanent + permanent: allowed (destination stays permanent)\n     *      - nonpermanent + permanent: allowed (permanent principal increases)\n     *      - permanent + nonpermanent: reverts\n     *      - expired source or destination: reverts\n     *      Can only be called by an address that owns or is approved for both veNFTs\n     * @param _from The ID of the source veNFT to merge from (will be burned)\n     * @param _to The ID of the destination veNFT to merge into (will receive the combined tokens)\n     */\n    function merge(uint256 _from, uint256 _to) external;\n\n    /**\n     * @notice Splits a veNFT into two new veNFTs with divided token balances\n     * @dev This operation burns the original veNFT and creates two new ones\n     *      Both new veNFTs maintain the same lock end time as the original\n     *      Can only be called by an address that has split permission, and owns or is approved for the veNFT\n     *      If called by an approved address, that address will NOT have approval on the new veNFTs\n     *      (approvals on the parent do not carry over to children)\n     *      Requires that the caller is either the owner or specifically has been granted split permission\n     *      Cannot split permanent locks\n     * @param _from The ID of the veNFT to split (will be burned)\n     * @param _amount The precise token amount to allocate to the second new veNFT\n     * @return _tokenId1 ID of the first new veNFT with (original amount - _amount) tokens\n     * @return _tokenId2 ID of the second new veNFT with exactly _amount tokens\n     */\n    function split(uint256 _from, uint256 _amount) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n    /**\n     * @notice Grant or revoke permission for an address to split veNFTs\n     * @dev Can only be called by the team address\n     *      Setting permissions for address(0) acts as a global switch for all addresses\n     *      If address(0) is set to false, no address can split regardless of individual permissions\n     *      If address(0) is set to true, individual permissions apply normally\n     * @param _account The address to modify split permissions for, or address(0) for global setting\n     * @param _bool True to grant permission, false to revoke permission\n     */\n    function toggleSplit(address _account, bool _bool) external;\n\n    /**\n     * @notice Permanently lock a veNFT to give it non-decaying voting power\n     * @dev Converts a standard time-locked veNFT to a permanent lock\n     *      Once permanent, the veNFT cannot be withdrawn normally (even after the original lock time)\n     *      Permanent locks have constant voting power equal to the locked token amount with no time decay\n     *      Note: time served prior to permanence is not preserved for penalty calculations  if the owner\n     *      later calls `earlyWithdraw`, the position is first unlocked and the penalty window resets to a\n     *      full MAXTIME from the current timestamp\n     *      Can only be called by the owner of the veNFT or an approved address\n     *      Cannot be called on a lock that is already permanent\n     * @param _tokenId The ID of the veNFT to permanently lock\n     */\n    function lockPermanent(uint256 _tokenId) external;\n\n    /**\n     * @notice Revert a veNFT from permanent lock status back to a standard time-lock\n     * @dev Converts a permanent lock back to a standard time-based lock\n     *      After unlocking, the veNFT's voting power will decay based on the remaining lock time\n     *      The lock time will be the original lock end time from before it was made permanent\n     *      If the original lock time has already passed, the lock will be immediately withdrawable\n     *      Can only be called by the owner or an approved operator\n     *      Only callable on veNFTs that are currently permanently locked\n     * @param _tokenId The ID of the veNFT to revert from permanent to standard lock\n     */\n    function unlockPermanent(uint256 _tokenId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                           VOTING POWER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the current voting power for a specific veNFT\n     * @dev Calculates voting power based on lock amount, remaining time, and permanent status\n     *      For standard locks: voting power = amount * (time_left / MAXTIME)\n     *      For permanent locks: voting power = amount (no time decay)\n     *      Returns 0 if called in the same block as a transfer due to checkpoint timing\n     *      This is the core function used for governance voting power determination\n     * @param _tokenId The ID of the veNFT to query voting power for\n     * @return The current voting power of the specified veNFT\n     */\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Get the historical voting power for a veNFT at a specific timestamp\n     * @dev Uses checkpoints to determine voting power at any point in the past\n     *      Crucial for governance systems that need to determine past voting power\n     *      For timestamps between checkpoints, calculates the interpolated value\n     *      Returns 0 for timestamps before the veNFT was created\n     * @param _tokenId The ID of the veNFT to query historical voting power for\n     * @param _t The timestamp at which to query the voting power\n     * @return The voting power of the specified veNFT at the requested timestamp\n     */\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    /**\n     * @notice Calculate the total voting power across all veNFTs at the current timestamp\n     * @dev Sums up all individual veNFT voting powers including both time-based and permanent locks\n     *      This represents the total governance voting power in the system right now\n     * @return The aggregate voting power of all veNFTs at the current timestamp\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Calculate the total historical voting power across all veNFTs at a specific timestamp\n     * @dev Uses global checkpoints to determine total voting power at any point in the past\n     *      Critical for governance votes that need to determine the total voting power at a past block\n     *      For timestamps between checkpoints, calculates the interpolated value\n     * @param _t The timestamp at which to query the total voting power\n     * @return The aggregate voting power of all veNFTs at the requested timestamp\n     */\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC6372\n    function clock() external view returns (uint48);\n\n    /// @inheritdoc IERC6372\n    function CLOCK_MODE() external view returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                          MIN LOCK AMOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the minimum amount of tokens required to create a veNFT lock\n     * @dev This value is used to validate lock creation and prevent spam attacks\n     * @return The minimum lock amount in token units (with 18 decimals)\n     */\n    function minLockAmount() external view returns (uint256);\n\n    /**\n     * @notice Sets the minimum amount of tokens required to create a veNFT lock\n     * @dev Can only be called by the team address. This helps prevent spam and ensures meaningful lock amounts\n     * @param newMinLockAmount The new minimum lock amount in token units (with 18 decimals)\n     */\n    function setMinLockAmount(uint256 newMinLockAmount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                      NOTIFY CONTRACTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the revenue reward contract\n     * @dev Returns address(0) if no revenue reward contract is set\n     * @return The revenue reward contract\n     */\n    function revenueReward() external view returns (IRevenueReward);\n\n    /**\n     * @notice Sets the revenue reward contract\n     * @dev Can only be called by the team address\n     * @param _revenueReward The new revenue reward contract\n     */\n    function setRevenueReward(IRevenueReward _revenueReward) external;\n}\n",
        "keccak256": "0x6b386b558166fbc71e1bf95bee2210f81afd960ab7129ac7503125c1ffb9bc5b",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IDustRewardsController.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.30;\n\nimport {IRewardsDistributor} from \"@aave-v3-periphery/contracts/rewards/interfaces/IRewardsDistributor.sol\";\nimport {RewardsDataTypes} from \"@aave-v3-periphery/contracts/rewards/libraries/RewardsDataTypes.sol\";\n\nimport {IDustTransferStrategy} from \"../interfaces/IDustTransferStrategy.sol\";\n\n/**\n * @title IDustRewardsController\n * @author Original implementation by Aave\n * @author Extended by Neverland\n * @notice Defines the interface for the DustRewardsController that manages token rewards distribution\n * @dev Extends Aave's IRewardsDistributor with additional functionality for Neverland's veNFT system\n *      This controller manages the distribution of rewards to veNFT holders with options for\n *      time-locks and specific NFT targeting\n *      Modified from Aave's `IRewardsController` to pass lockTime and tokenId to transfer strategies,\n *      enabling integration with Neverland's veNFT locking ecosystem\n */\ninterface IDustRewardsController is IRewardsDistributor {\n    /// @notice Error thrown when a user is not authorized to claim rewards on behalf of another user\n    error ClaimerUnauthorized();\n\n    /// @notice Error thrown when the user address is invalid\n    error InvalidUserAddress();\n\n    /// @notice Error thrown when the caller is not the emission manager or self\n    error OnlyEmissionManagerOrSelf();\n\n    /// @notice Error thrown when a transfer error occurs\n    error TransferError();\n\n    /// @notice Error thrown when the strategy address is zero\n    error StrategyZeroAddress();\n\n    /// @notice Error thrown when the strategy is not a contract\n    error StrategyNotContract();\n\n    /// @notice Error thrown when a reward token address is invalid (zero)\n    error InvalidRewardAddress();\n\n    /**\n     * @notice Emitted when a new address is whitelisted as claimer of rewards on behalf of a user\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /**\n     * @notice Emitted when rewards are claimed\n     * @param user The address of the user rewards has been claimed on behalf of\n     * @param reward The address of the token reward is claimed\n     * @param to The address of the receiver of the rewards\n     * @param claimer The address of the claimer\n     * @param amount The amount of rewards claimed\n     */\n    event RewardsClaimed(\n        address indexed user, address indexed reward, address indexed to, address claimer, uint256 amount\n    );\n\n    /**\n     * @notice Emitted when a transfer strategy is installed for the reward distribution\n     * @param reward The address of the token reward\n     * @param transferStrategy The address of TransferStrategy contract\n     */\n    event TransferStrategyInstalled(address indexed reward, address indexed transferStrategy);\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the address authorized to claim rewards on behalf of a specific user\n     * @dev Used to verify permission when claimRewardsOnBehalf is called\n     *      Returns the zero address if no claimer has been set\n     * @param user The address of the user whose authorized claimer is being queried\n     * @return The address authorized to claim on behalf of the user, or address(0) if none\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @notice Returns the transfer strategy implementation for a specific reward token\n     * @dev Each reward token can have its own dedicated transfer strategy implementation\n     *      The returned address implements the IDustTransferStrategy interface\n     * @param reward The address of the reward token\n     * @return The address of the transfer strategy contract for the specified reward token\n     */\n    function getTransferStrategy(address reward) external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Authorizes an address to claim rewards on behalf of another user\n     * @dev Establishes a delegation relationship for reward claiming\n     *      This is useful for integrating with other protocols or allowing\n     *      trusted services to manage reward claims for users\n     *      Only callable by users for their own accounts or by admin\n     * @param user The address of the user granting claim permission\n     * @param claimer The address being authorized to claim on behalf of the user\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @notice Sets the transfer strategy implementation for a specific reward token\n     * @dev Each reward token can have its own unique transfer logic\n     *      For veNFT integration, typically set to a DustLockTransferStrategy\n     *      which handles locking tokens into veNFTs during claiming\n     *      Only callable by contract admin\n     * @param reward The address of the reward token to configure\n     * @param transferStrategy The implementation of IDustTransferStrategy that will handle reward transfers\n     */\n    function setTransferStrategy(address reward, IDustTransferStrategy transferStrategy) external;\n\n    /**\n     * @notice Configures incentivized assets with emission schedules and reward rates\n     * @dev Sets up reward distributions for assets with specified emission rates\n     *      Each asset can be configured with its own reward token, distribution schedule, and transfer strategy\n     *      Only callable by the contract admin\n     * @param config Array of configuration inputs with the following fields for each asset:\n     *   - emissionPerSecond: Rate of reward distribution per second (in reward token units)\n     *   - totalSupply: Current total supply of the incentivized asset\n     *   - distributionEnd: Timestamp when reward distribution ends\n     *   - asset: Address of the asset being incentivized\n     *   - reward: Address of the reward token to distribute\n     *   - transferStrategy: Implementation of IDustTransferStrategy for reward transfers\n     *   - rewardOracle: Not used in Neverland implementation, can be set to address(0)\n     */\n    function configureAssets(RewardsDataTypes.RewardsConfigInput[] memory config) external;\n\n    /*//////////////////////////////////////////////////////////////\n                            REWARDS ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates reward accrual when a user's balance or asset state changes\n     * @dev Called by incentivized assets as a hook during transfers or other balance-changing operations\n     *      Records snapshots of user and global state to ensure accurate reward calculation\n     *      Must be called by the incentivized asset contract before making any changes to balances\n     * @param user The address of the user whose balance is changing\n     * @param totalSupply The total supply of the asset before the balance change\n     * @param userBalance The user's balance before the change is applied\n     */\n    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\n\n    /*//////////////////////////////////////////////////////////////\n                           REWARDS CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims specified amount of rewards for a user across multiple assets\n     * @dev Calculates and transfers accumulated rewards to the specified recipient\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param amount The amount of rewards to claim (use type(uint256).max for all available rewards)\n     * @param to The address that will receive the rewards\n     * @param reward The address of the reward token to claim\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return The actual amount of rewards claimed\n     */\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (uint256);\n\n    /**\n     * @notice Claims rewards on behalf of another user (requires authorization)\n     * @dev Allows a whitelisted claimer to claim rewards for another user\n     *      The claimer must be previously authorized via setClaimer function\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param amount The amount of rewards to claim (use type(uint256).max for all available rewards)\n     * @param user The address of the user whose rewards are being claimed\n     * @param to The address that will receive the rewards\n     * @param reward The address of the reward token to claim\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return The actual amount of rewards claimed\n     */\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (uint256);\n\n    /**\n     * @notice Claims rewards for the caller (msg.sender) across multiple assets\n     * @dev Convenience function that claims rewards and sends them to the caller\n     *      Equivalent to calling claimRewards with 'to' set to msg.sender\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param amount The amount of rewards to claim (use type(uint256).max for all available rewards)\n     * @param reward The address of the reward token to claim\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return The actual amount of rewards claimed\n     */\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (uint256);\n\n    /**\n     * @notice Claims all available rewards across all reward tokens for a user\n     * @dev Processes all reward types in a single transaction for efficiency\n     *      Returns two parallel arrays with reward tokens and their claimed amounts\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param to The address that will receive the rewards\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return rewardsList Array of addresses of all claimed reward tokens\n     * @return claimedAmounts Array of claimed amounts, with indices matching the rewardsList array\n     */\n    function claimAllRewards(address[] calldata assets, address to, uint256 lockTime, uint256 tokenId)\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @notice Claims all available rewards across all reward tokens for a user on behalf of someone else\n     * @dev Similar to claimAllRewards but allows a whitelisted claimer to claim on behalf of another user\n     *      The claimer must be previously authorized by the user with setClaimer via \"allowClaimOnBehalf\" function\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param user The address of the user whose rewards are being claimed\n     * @param to The address that will receive the rewards\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return rewardsList Array of addresses of all claimed reward tokens\n     * @return claimedAmounts Array of claimed amounts, with indices matching the rewardsList array\n     */\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @notice Claims all rewards for msg.sender across all configured reward tokens\n     * @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param lockTime Optional lock time for supported rewards\n     * @param tokenId Optional tokenId for supported rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     */\n    function claimAllRewardsToSelf(address[] calldata assets, uint256 lockTime, uint256 tokenId)\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n}\n",
        "keccak256": "0xc1f739427297526680bbe4e507eb48ba513b6cb487fa1d0f0ca9cb849e516ae0",
        "license": "AGPL-3.0"
      },
      "src/interfaces/IDustTransferStrategy.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.30;\n\n/**\n * @title IDustTransferStrategy\n * @author Original implementation by Aave\n * @author Extended by Neverland\n * @notice Extended Aave's `ITransferStrategyBase` interface to add lockTime\n *         and tokenId parameters to the `performTransfer()` function.\n *         Added emergency withdrawal functionality.\n */\ninterface IDustTransferStrategy {\n    /// @notice Error thrown when the caller is not the incentives controller\n    error CallerNotIncentivesController();\n\n    /// @notice Error thrown when the caller is not the rewards admin\n    error OnlyRewardsAdmin();\n\n    /**\n     * @notice Emitted when an emergency withdrawal is performed\n     * @param caller The rewards admin that performed the withdrawal\n     * @param token The token address withdrawn from this strategy\n     * @param to The recipient of the withdrawn tokens\n     * @param amount The amount of tokens withdrawn\n     */\n    event EmergencyWithdrawal(address indexed caller, address indexed token, address indexed to, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the address of the Incentives Controller\n     * @return The Incentives Controller address\n     */\n    function getIncentivesController() external view returns (address);\n\n    /**\n     * @notice Returns the address of the Rewards admin\n     * @return The rewards admin address\n     */\n    function getRewardsAdmin() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                         TRANSFER STRATEGY\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n     * @dev If `tokenId` is specified it's owner has to be `to`\n     *      DUST_VAULT pre-approves infinite amount of `reward` to this contract\n     * @param to Account to transfer rewards to\n     * @param reward Address of the reward token\n     * @param amount Amount of the reward token to transfer\n     * @param lockTime Lock duration, or 0 for early exit\n     * @param tokenId Token ID to merge the emissions with, or 0 for no merge\n     * @return Returns true if transfer logic succeeds\n     */\n    function performTransfer(address to, address reward, uint256 amount, uint256 lockTime, uint256 tokenId)\n        external\n        returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Perform an emergency token withdrawal (admin only)\n     * @dev Only callable by the rewards admin to recover tokens from this strategy contract\n     * @param token Address of the token to withdraw funds from this contract\n     * @param to Address of the recipient of the withdrawal\n     * @param amount Amount of the withdrawal\n     */\n    function emergencyWithdrawal(address token, address to, uint256 amount) external;\n}\n",
        "keccak256": "0xaf2ae409f386ba131b0af0e85424d2e991c2ba1e434fb42639336e3759dd486f",
        "license": "AGPL-3.0"
      },
      "src/interfaces/INeverlandDustHelper.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title INeverlandDustHelper\n * @author Neverland\n * @notice Interface for the DUST oracle/helper used by UI and integrations\n */\ninterface INeverlandDustHelper {\n    /*//////////////////////////////////////////////////////////////\n                               STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct MarketData {\n        uint256 circulatingSupply; // 18 decimals\n        uint256 totalSupply; // 18 decimals\n        uint256 usdPrice; // 8 decimals\n        uint256 marketCap; // 8 decimals\n        uint256 fullyDilutedMarketCap; // 8 decimals\n        uint256 timestamp;\n        bool isPriceFromUniswap;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Emitted when the cached price is updated\n     * @param oldPrice Previous price (8 decimals)\n     * @param newPrice New price (8 decimals)\n     * @param timestamp Block timestamp when the price was updated\n     * @param fromUniswap True if the price came from Uniswap, false if hardcoded\n     */\n    event PriceUpdated(uint256 oldPrice, uint256 newPrice, uint256 timestamp, bool fromUniswap);\n\n    /**\n     * @notice Emitted when the Uniswap pair used for price discovery changes\n     * @param oldPair Previous pair address\n     * @param newPair New pair address (zero to disable)\n     */\n    event UniswapPairUpdated(address oldPair, address newPair);\n\n    /**\n     * @notice Emitted when a team address is added to the exclusion list\n     * @param teamAddress The added team address\n     */\n    event TeamAddressAdded(address teamAddress);\n\n    /**\n     * @notice Emitted when a team address is removed from the exclusion list\n     * @param teamAddress The removed team address\n     */\n    event TeamAddressRemoved(address teamAddress);\n\n    /**\n     * @notice Emitted when multiple team addresses are added\n     * @param teamAddresses Array of added team addresses\n     */\n    event TeamAddressesBatchAdded(address[] teamAddresses);\n\n    /**\n     * @notice Emitted when multiple team addresses are removed\n     * @param teamAddresses Array of removed team addresses\n     */\n    event TeamAddressesBatchRemoved(address[] teamAddresses);\n\n    /**\n     * @notice Emitted when the cache invalidation interval changes\n     * @param oldInterval Previous interval in seconds\n     * @param newInterval New interval in seconds\n     */\n    event PriceUpdateIntervalChanged(uint256 oldInterval, uint256 newInterval);\n\n    /**\n     * @notice Emitted when the reasonable price limits are updated\n     * @param minPrice New minimum price (8 decimals)\n     * @param maxPrice New maximum price (8 decimals)\n     */\n    event PriceLimitsUpdated(uint256 minPrice, uint256 maxPrice);\n\n    /**\n     * @notice Emitted for Chainlink-compatibility when the answer changes\n     * @param current Current price (8 decimals)\n     * @param roundId Round identifier\n     * @param updatedAt Timestamp when the answer was updated\n     */\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n    /*//////////////////////////////////////////////////////////////\n                               ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Invalid price provided\n     * @param price Invalid price (8 decimals)\n     */\n    error InvalidPrice(uint256 price);\n\n    /**\n     * @notice Team address already exists\n     * @param teamAddress Team address\n     */\n    error TeamAddressAlreadyExists(address teamAddress);\n\n    /**\n     * @notice Team address not found\n     * @param teamAddress Team address\n     */\n    error TeamAddressNotFound(address teamAddress);\n\n    /**\n     * @notice Invalid price update interval\n     * @param interval Invalid interval\n     */\n    error InvalidPriceUpdateInterval(uint256 interval);\n\n    /**\n     * @notice Invalid price limits\n     * @param minPrice Minimum price (8 decimals)\n     * @param maxPrice Maximum price (8 decimals)\n     */\n    error InvalidPriceLimits(uint256 minPrice, uint256 maxPrice);\n\n    /// @notice Empty array provided\n    error EmptyArray();\n\n    /**\n     * @notice Invalid round ID\n     * @param roundId Invalid round ID\n     */\n    error InvalidRoundId(uint256 roundId);\n\n    /*//////////////////////////////////////////////////////////////\n                           TEAM MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add a team address\n     * @param teamAddress Team address to add\n     */\n    function addTeamAddress(address teamAddress) external;\n\n    /**\n     * @notice Remove a team address\n     * @param teamAddress Team address to remove\n     */\n    function removeTeamAddress(address teamAddress) external;\n\n    /**\n     * @notice Add multiple team addresses\n     * @param teamAddresses Array of team addresses to add\n     */\n    function addTeamAddresses(address[] calldata teamAddresses) external;\n\n    /**\n     * @notice Remove multiple team addresses\n     * @param teamAddresses Array of team addresses to remove\n     */\n    function removeTeamAddresses(address[] calldata teamAddresses) external;\n\n    /**\n     * @notice Get all team addresses\n     * @return addresses Array of team addresses\n     */\n    function getTeamAddresses() external view returns (address[] memory addresses);\n\n    /**\n     * @notice Get the number of team addresses\n     * @return count Number of team addresses\n     */\n    function getTeamAddressCount() external view returns (uint256 count);\n\n    /**\n     * @notice Check if an address is a team address\n     * @param account Address to check\n     * @return isTeam Whether the address is a team address\n     */\n    function isTeamAddress(address account) external view returns (bool isTeam);\n\n    /*//////////////////////////////////////////////////////////////\n                         UNISWAP INTEGRATION\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Set the Uniswap pair address\n     * @param pairAddress Uniswap pair address\n     */\n    function setUniswapPair(address pairAddress) external;\n\n    /**\n     * @notice Remove the Uniswap pair address\n     */\n    function removeUniswapPair() external;\n\n    /**\n     * @notice Get the Uniswap pair address\n     * @return pairAddress Uniswap pair address\n     */\n    function uniswapPair() external view returns (address pairAddress);\n\n    /*//////////////////////////////////////////////////////////////\n                           PRICE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Update the hardcoded price\n     * @param newPrice New price (8 decimals)\n     */\n    function updateHardcodedPrice(uint256 newPrice) external;\n\n    /**\n     * @notice Set the price update interval\n     * @param interval Price update interval in seconds\n     */\n    function setPriceUpdateInterval(uint256 interval) external;\n\n    /**\n     * @notice Set the price limits\n     * @param minPrice Minimum price (8 decimals)\n     * @param maxPrice Maximum price (8 decimals)\n     */\n    function setPriceLimits(uint256 minPrice, uint256 maxPrice) external;\n\n    /**\n     * @notice Update the price cache\n     */\n    function updatePriceCache() external;\n\n    /**\n     * @notice Get the current price\n     * @return price Current price (8 decimals)\n     * @return fromUniswap Whether the price came from Uniswap\n     */\n    function getPrice() external view returns (uint256 price, bool fromUniswap);\n\n    /*//////////////////////////////////////////////////////////////\n                         SUPPLY CALCULATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get total token supply (18 decimals)\n     * @return supply Total supply\n     */\n    function getTotalSupply() external view returns (uint256 supply);\n    /**\n     * @notice Get circulating supply (excludes team balances)\n     * @return supply Circulating supply (18 decimals)\n     */\n    function getCirculatingSupply() external view returns (uint256 supply);\n    /**\n     * @notice Sum of balances held by all team addresses\n     * @return balance Total balance (18 decimals)\n     */\n    function getTeamTotalBalance() external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         MARKET DATA (MAIN FUNCTION)\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Return full market data snapshot\n     * @return data MarketData struct with supplies, price and caps\n     */\n    function getMarketData() external view returns (MarketData memory data);\n\n    /**\n     * @notice Return basic market metrics\n     * @return circulatingSupply Circulating supply (18 decimals)\n     * @return totalSupply Total supply (18 decimals)\n     * @return usdPrice Price (8 decimals)\n     * @return marketCap Market cap (8 decimals)\n     */\n    function getMarketMetrics()\n        external\n        view\n        returns (uint256 circulatingSupply, uint256 totalSupply, uint256 usdPrice, uint256 marketCap);\n\n    /*//////////////////////////////////////////////////////////////\n                           UTILITY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Convert DUST (18 decimals) to USD value (8 decimals)\n     * @param dustAmount DUST amount (18 decimals)\n     * @return usdValue USD value (8 decimals)\n     */\n    function getDustValueInUSD(uint256 dustAmount) external view returns (uint256 usdValue);\n\n    /**\n     * @notice Convert USD value (8 decimals) to DUST (18 decimals)\n     * @param usdValue USD value (8 decimals)\n     * @return dustAmount DUST amount (18 decimals)\n     */\n    function getUSDValueInDust(uint256 usdValue) external view returns (uint256 dustAmount);\n\n    /**\n     * @notice Check if price cache is stale\n     * @return isStale True if stale, false otherwise\n     */\n    function isPriceCacheStale() external view returns (bool isStale);\n\n    /**\n     * @notice Detailed price info and cache state\n     * @return price USD price (8 decimals)\n     * @return isFromUniswap True if the price comes from Uniswap\n     * @return lastUpdate Cache timestamp of last price update\n     * @return isStale True if the cached price is stale\n     */\n    function getPriceInfo()\n        external\n        view\n        returns (uint256 price, bool isFromUniswap, uint256 lastUpdate, bool isStale);\n\n    /*//////////////////////////////////////////////////////////////\n                         CHAINLINK COMPATIBILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get latest round data\n     * @return roundId Round ID\n     * @return answer Price (8 decimals)\n     * @return startedAt Round start timestamp\n     * @return updatedAt Round update timestamp\n     * @return answeredInRound Round answered in\n     */\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * @notice Get round data by round ID\n     * @param _roundId Round ID\n     * @return roundId Round ID\n     * @return answer Price (8 decimals)\n     * @return startedAt Round start timestamp\n     * @return updatedAt Round update timestamp\n     * @return answeredInRound Round answered in\n     */\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * @notice Get latest answer\n     * @return price Price (8 decimals)\n     */\n    function latestAnswer() external view returns (int256 price);\n\n    /**\n     * @notice Get latest timestamp\n     * @return timestamp Timestamp\n     */\n    function latestTimestamp() external view returns (uint256 timestamp);\n\n    /**\n     * @notice Get latest round ID\n     * @return roundId Round ID\n     */\n    function latestRound() external view returns (uint256 roundId);\n\n    /**\n     * @notice Get answer by round ID\n     * @param roundId Round ID\n     * @return answer Price (8 decimals)\n     */\n    function getAnswer(uint256 roundId) external view returns (int256 answer);\n\n    /**\n     * @notice Get timestamp by round ID\n     * @param roundId Round ID\n     * @return timestamp Timestamp\n     */\n    function getTimestamp(uint256 roundId) external view returns (uint256 timestamp);\n\n    /**\n     * @notice Get number of decimals used by price (8)\n     * @return decimals Number of decimals\n     */\n    function decimals() external pure returns (uint8 decimals);\n\n    /**\n     * @notice Get description of price feed\n     * @return description Description\n     */\n    function description() external pure returns (string memory description);\n\n    /**\n     * @notice Get version of price feed\n     * @return version Version\n     */\n    function version() external pure returns (uint256 version);\n\n    /*//////////////////////////////////////////////////////////////\n                           VIEW VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get DUST token\n     * @return dustToken DUST token (IERC20)\n     */\n    function dustToken() external view returns (IERC20 dustToken);\n\n    /**\n     * @notice Get hardcoded price\n     * @return price Hardcoded price (8 decimals)\n     */\n    function hardcodedPrice() external view returns (uint256 price);\n\n    /**\n     * @notice Get last price update timestamp\n     * @return timestamp Last price update timestamp\n     */\n    function lastPriceUpdate() external view returns (uint256 timestamp);\n\n    /**\n     * @notice Get price update interval\n     * @return interval Price update interval\n     */\n    function priceUpdateInterval() external view returns (uint256 interval);\n\n    /**\n     * @notice Get minimum reasonable price\n     * @return price Minimum reasonable price (8 decimals)\n     */\n    function minReasonablePrice() external view returns (uint256 price);\n\n    /**\n     * @notice Get maximum reasonable price\n     * @return price Maximum reasonable price (8 decimals)\n     */\n    function maxReasonablePrice() external view returns (uint256 price);\n\n    /**\n     * @notice Number of decimals used by USD price (8)\n     * @return decimals Price decimals\n     */\n    function PRICE_DECIMALS() external view returns (uint8 decimals);\n\n    /**\n     * @notice Default hardcoded price used when Uniswap is disabled\n     * @return price Default price (8 decimals)\n     */\n    function DEFAULT_DUST_PRICE() external view returns (uint256 price);\n}\n",
        "keccak256": "0x669741e52f7f65b4b448bdab83253351521f1f66e39ad7e8b73af303f21b4b53",
        "license": "BUSL-1.1"
      },
      "src/interfaces/INeverlandUiProvider.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title INeverlandUiProvider\n * @author Neverland\n * @notice Interface for the Neverland UI data provider contract\n * @dev Aggregates data from multiple contracts for efficient frontend queries\n */\ninterface INeverlandUiProvider {\n    /// @notice Thrown when the price oracle for non-DUST assets is not configured or inaccessible\n    error PriceOracleUnavailable();\n\n    /// @notice Thrown when a non-DUST asset price cannot be retrieved or is zero\n    error AssetPriceUnavailable(address token);\n\n    /*//////////////////////////////////////////////////////////////\n                               STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Complete dashboard data for a user\n     * @param user The user address\n     * @param tokenIds Array of all veNFT token IDs owned by the user\n     * @param locks Array of lock information for each token\n     * @param rewardSummaries Array of reward summaries for each token\n     * @param totalVotingPower User's total current voting power across all tokens\n     * @param totalLockedAmount Total DUST locked across all user's tokens\n     */\n    struct UserDashboardData {\n        address user;\n        uint256[] tokenIds;\n        LockInfo[] locks;\n        RewardSummary[] rewardSummaries;\n        uint256 totalVotingPower;\n        uint256 totalLockedAmount;\n    }\n\n    /**\n     * @notice Detailed information about a specific lock\n     * @param tokenId The veNFT token ID\n     * @param amount Amount of DUST locked\n     * @param end Unlock timestamp (0 for permanent locks)\n     * @param effectiveStart Effective start time for weighted calculations\n     * @param isPermanent Whether this is a permanent lock\n     * @param votingPower Current voting power of this token\n     * @param rewardReceiver Address that receives rewards (for self-repaying loans)\n     * @param owner Current owner of the token\n     */\n    struct LockInfo {\n        uint256 tokenId;\n        uint256 amount;\n        uint256 end;\n        uint256 effectiveStart;\n        bool isPermanent;\n        uint256 votingPower;\n        address rewardReceiver;\n        address owner;\n    }\n\n    /**\n     * @notice Summary of rewards for a specific token\n     * @param tokenId The veNFT token ID\n     * @param revenueRewards Array of pending revenue rewards per reward token\n     * @param emissionRewards Array of pending emission rewards per reward token\n     * @param rewardTokens Array of reward token addresses\n     * @param totalEarned Array of total rewards earned historically per token\n     */\n    struct RewardSummary {\n        uint256 tokenId;\n        uint256[] revenueRewards;\n        uint256[] emissionRewards;\n        address[] rewardTokens;\n        uint256[] totalEarned;\n    }\n\n    /**\n     * @notice Protocol-wide statistics\n     * @param totalSupply Total DUST locked in the protocol\n     * @param totalVotingPower Total voting power across all tokens\n     * @param permanentLockBalance Total DUST in permanent locks\n     * @param rewardTokens Array of all reward tokens\n     * @param totalRewardsPerToken Total rewards distributed per token\n     * @param epoch Current global epoch\n     * @param activeTokenCount Number of active veNFT tokens\n     */\n    struct GlobalStats {\n        uint256 totalSupply;\n        uint256 totalVotingPower;\n        uint256 permanentLockBalance;\n        address[] rewardTokens;\n        uint256[] totalRewardsPerToken;\n        uint256 epoch;\n        uint256 activeTokenCount;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get user dashboard with all veNFT positions and rewards\n     * @param user The user address to get data for\n     * @param offset Start index for paginated token list\n     * @param limit Maximum number of tokens to include\n     * @return Complete user dashboard information\n     */\n    function getUserDashboard(address user, uint256 offset, uint256 limit)\n        external\n        view\n        returns (UserDashboardData memory);\n\n    /**\n     * @notice Returns the total number of veDUST tokens owned by a user\n     * @param user The user address\n     * @return count Number of owned veDUST tokens\n     */\n    function getUserTokenCount(address user) external view returns (uint256 count);\n\n    /**\n     * @notice Get detailed information for a specific token\n     * @param tokenId The veNFT token ID\n     * @return LockInfo Detailed lock information\n     * @return RewardSummary Reward summary for the token\n     */\n    function getTokenDetails(uint256 tokenId) external view returns (LockInfo memory, RewardSummary memory);\n\n    /**\n     * @notice Get detailed information for multiple tokens efficiently\n     * @param tokenIds Array of veNFT token IDs\n     * @return locks Array of lock information\n     * @return rewards Array of reward summaries\n     */\n    function getBatchTokenDetails(uint256[] calldata tokenIds)\n        external\n        view\n        returns (LockInfo[] memory locks, RewardSummary[] memory rewards);\n\n    /**\n     * @notice Get protocol-wide statistics\n     * @return GlobalStats Protocol statistics\n     */\n    function getGlobalStats() external view returns (GlobalStats memory);\n\n    /**\n     * @notice User reward summary data structure\n     * @param totalRevenue Total pending revenue rewards per reward token\n     * @param totalEmissions Total pending emission rewards per reward token\n     * @param totalHistorical Total historical rewards earned per reward token\n     */\n    struct UserRewardsSummary {\n        uint256[] totalRevenue;\n        uint256[] totalEmissions;\n        uint256[] totalHistorical;\n    }\n\n    /**\n     * @notice Returns comprehensive reward summary for a user across specified reward tokens\n     * @dev Aggregates all rewards earned by user's veNFTs for the given tokens\n     *      Provides separate totals for revenue rewards, emission rewards, and historical rewards\n     * @param user The address to query rewards for\n     * @param rewardTokens Array of reward token addresses to check\n     * @return summary User rewards summary containing all reward arrays\n     */\n    function getUserRewardsSummary(address user, address[] calldata rewardTokens)\n        external\n        view\n        returns (UserRewardsSummary memory summary);\n\n    /**\n     * @notice Returns user revenue rewards for specified reward tokens (simpler array return)\n     * @param user The address to query rewards for\n     * @param rewardTokens Array of reward token addresses to check\n     * @return revenueRewards Array of total revenue rewards per token\n     */\n    function getUserRevenueRewards(address user, address[] calldata rewardTokens)\n        external\n        view\n        returns (uint256[] memory revenueRewards);\n\n    /**\n     * @notice Returns user emission rewards for specified reward tokens (simpler array return)\n     * @param user The address to query rewards for\n     * @param rewardTokens Array of reward token addresses to check\n     * @return emissionRewards Array of total emission rewards per token\n     */\n    function getUserEmissionRewards(address user, address[] calldata rewardTokens)\n        external\n        view\n        returns (uint256[] memory emissionRewards);\n\n    /**\n     * @notice Returns per-asset emission rewards for a specific reward token\n     * @dev Lists Aave assets (aTokens and variable debt tokens) that contribute to the user's emissions\n     *      and the corresponding reward amounts per asset for the given reward token\n     * @param user The address to query rewards for\n     * @param rewardToken The reward token address to break down\n     * @return assets Array of asset addresses contributing to emissions\n     * @return amounts Array of rewards per asset (parallel to `assets`)\n     */\n    function getUserEmissionBreakdown(address user, address rewardToken)\n        external\n        view\n        returns (address[] memory assets, uint256[] memory amounts);\n\n    /**\n     * @notice Get unlock schedule for user's tokens\n     * @param user The user address\n     * @return unlockTimes Array of unlock timestamps\n     * @return amounts Array of amounts unlocking at each timestamp\n     * @return tokenIds Array of token IDs for each unlock\n     */\n    function getUnlockSchedule(address user)\n        external\n        view\n        returns (uint256[] memory unlockTimes, uint256[] memory amounts, uint256[] memory tokenIds);\n\n    /*//////////////////////////////////////////////////////////////\n                         COMPREHENSIVE DATA STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Market and economic data\n     * @param rewardTokens Array of reward token addresses\n     * @param rewardTokenBalances Available reward balances in contracts\n     * @param distributionRates Rewards distributed per epoch (current epoch)\n     * @param nextEpochTimestamp When next reward epoch starts\n     * @param currentEpoch Current epoch number\n     * @param epochRewards Total rewards for current epoch per token\n     * @param nextEpochRewards Total rewards already scheduled for the next epoch per token\n     * @param totalValueLockedUSD Total protocol TVL in USD (8 decimals)\n     */\n    struct MarketData {\n        address[] rewardTokens;\n        uint256[] rewardTokenBalances;\n        uint256[] distributionRates;\n        uint256 nextEpochTimestamp;\n        uint256 currentEpoch;\n        uint256[] epochRewards;\n        uint256[] nextEpochRewards;\n        uint256 totalValueLockedUSD;\n    }\n\n    /**\n     * @notice Static and semi-static protocol metadata for bootstrapping the UI\n     * @param dustLock Address of DustLock contract\n     * @param revenueReward Address of RevenueReward contract\n     * @param dustRewardsController Address of DustRewardsController\n     * @param dustOracle Address of NeverlandDustHelper\n     * @param earlyWithdrawPenalty Early withdraw penalty in basis points\n     * @param minLockAmount Minimum DUST required to create a lock\n     * @param rewardDistributor Current revenue reward distributor address\n     * @param revenueRewardTokens List of revenue reward tokens\n     * @param emissionRewardTokens List of emission reward tokens\n     * @param emissionStrategies List of transfer strategies (parallel to emissionRewardTokens)\n     */\n    struct ProtocolMeta {\n        address dustLock;\n        address revenueReward;\n        address dustRewardsController;\n        address dustOracle;\n        uint256 earlyWithdrawPenalty;\n        uint256 minLockAmount;\n        address rewardDistributor;\n        address[] revenueRewardTokens;\n        address[] emissionRewardTokens;\n        address[] emissionStrategies;\n    }\n\n    /**\n     * @notice Price data for all tokens\n     * @param tokens Array of token addresses\n     * @param prices USD prices (18 decimals)\n     * @param lastUpdated Price update timestamps\n     * @param isStale Price staleness flags\n     */\n    struct PriceData {\n        address[] tokens;\n        uint256[] prices;\n        uint256[] lastUpdated;\n        bool[] isStale;\n    }\n\n    /**\n     * @notice Network and system status information\n     * @param currentBlock Current block number\n     * @param currentTimestamp Current timestamp\n     * @param gasPrice Current gas price estimate\n     */\n    struct NetworkData {\n        uint256 currentBlock;\n        uint256 currentTimestamp;\n        uint256 gasPrice;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         BUNDLED VIEW STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice User emission rewards data\n     * @param rewardTokens Array of emission reward token addresses\n     * @param totalRewards Array of total rewards per token\n     */\n    struct EmissionData {\n        address[] rewardTokens;\n        uint256[] totalRewards;\n    }\n\n    /**\n     * @notice Unlock schedule for a user\n     * @param unlockTimes Array of unlock timestamps\n     * @param amounts Array of amounts unlocking\n     * @param tokenIds Array of token IDs unlocking\n     */\n    struct UnlockSchedule {\n        uint256[] unlockTimes;\n        uint256[] amounts;\n        uint256[] tokenIds;\n    }\n\n    /**\n     * @notice Essential user data combining core dashboard elements\n     * @param user Core user dashboard data\n     * @param globalStats Global protocol statistics\n     * @param emissions User emission rewards data\n     * @param marketData Market and economic data\n     */\n    struct EssentialUserView {\n        UserDashboardData user;\n        GlobalStats globalStats;\n        EmissionData emissions;\n        MarketData marketData;\n    }\n\n    /**\n     * @notice Extended user data with additional detailed information\n     * @param unlockSchedule Scheduled unlock times and amounts\n     * @param rewardsSummary Comprehensive rewards breakdown\n     * @param allPrices Token price information\n     */\n    struct ExtendedUserView {\n        UnlockSchedule unlockSchedule;\n        UserRewardsSummary rewardsSummary;\n        PriceData allPrices;\n        EmissionAssetBreakdown[] emissionBreakdowns;\n    }\n\n    /**\n     * @notice Complete protocol bootstrap data for UI in a single call\n     * @param meta Protocol metadata and core addresses\n     * @param globalStats Protocol-wide statistics\n     * @param marketData Market and economic data\n     * @param allPrices Price information for relevant tokens\n     * @param network Network status and system information\n     */\n    struct UiBootstrap {\n        ProtocolMeta meta;\n        GlobalStats globalStats;\n        MarketData marketData;\n        PriceData allPrices;\n        NetworkData network;\n    }\n\n    /**\n     * @notice Complete user-focused UI data in a single call\n     * @param meta Protocol metadata and core addresses\n     * @param essential Essential user view (dashboard + emissions + global + market)\n     * @param extended Extended user view (unlock schedule + rewards summary + prices)\n     * @param network Network status and system information\n     */\n    struct UiFullBundle {\n        ProtocolMeta meta;\n        EssentialUserView essential;\n        ExtendedUserView extended;\n        NetworkData network;\n    }\n\n    /**\n     * @notice Per-asset emission breakdown for a given reward token\n     * @param rewardToken Emission reward token address\n     * @param assets List of contributing assets (aTokens and variable debt tokens)\n     * @param amounts Parallel list of rewards per asset\n     */\n    struct EmissionAssetBreakdown {\n        address rewardToken;\n        address[] assets;\n        uint256[] amounts;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         BUNDLED VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get essential user view with core data\n     * @param user The user address\n     * @param offset Start index for paginated token list\n     * @param limit Maximum number of tokens to include\n     * @return Essential user data bundle\n     */\n    function getEssentialUserView(address user, uint256 offset, uint256 limit)\n        external\n        view\n        returns (EssentialUserView memory);\n\n    /**\n     * @notice Get extended user view with detailed analysis data\n     * @param user The user address\n     * @param offset Start index for paginated token list\n     * @param limit Maximum number of tokens to include\n     * @return Extended user data bundle\n     */\n    function getExtendedUserView(address user, uint256 offset, uint256 limit)\n        external\n        view\n        returns (ExtendedUserView memory);\n\n    /**\n     * @notice Get user emission rewards data\n     * @param user The user address\n     * @return rewardTokens Array of emission reward token addresses\n     * @return totalRewards Array of total rewards per token\n     */\n    function getUserEmissions(address user)\n        external\n        view\n        returns (address[] memory rewardTokens, uint256[] memory totalRewards);\n\n    /**\n     * @notice Get market and economic data\n     * @return MarketData Market data including prices and TVL\n     */\n    function getMarketData() external view returns (MarketData memory);\n\n    /**\n     * @notice Get all token prices\n     * @return PriceData Price information for all tokens\n     */\n    function getAllPrices() external view returns (PriceData memory);\n\n    /**\n     * @notice Get protocol metadata for UI bootstrapping in one call\n     * @return meta ProtocolMeta containing core addresses, settings, and token lists\n     */\n    function getProtocolMeta() external view returns (ProtocolMeta memory meta);\n\n    /**\n     * @notice Get network and system data\n     * @return NetworkData Network status and system information\n     */\n    function getNetworkData() external view returns (NetworkData memory);\n\n    /**\n     * @notice Get protocol bootstrap data in one call\n     * @return boot UiBootstrap containing protocol + market + prices + network\n     */\n    function getUiBootstrap() external view returns (UiBootstrap memory boot);\n\n    /**\n     * @notice Get complete user bundle in one call (protocol + user views)\n     * @param user The user address\n     * @param offset Start index for paginated token list\n     * @param limit Maximum number of tokens to include\n     * @return bundle UiFullBundle containing meta, essential, extended, and network\n     */\n    function getUiFullBundle(address user, uint256 offset, uint256 limit)\n        external\n        view\n        returns (UiFullBundle memory bundle);\n}\n",
        "keccak256": "0x46f3fa849e395d27b8ca27e146994475628444355a90c0e19facd21e62726b7f",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IRevenueReward.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\n\nimport {IUserVaultFactory} from \"./IUserVaultFactory.sol\";\n\n/**\n * @title IRevenueReward Interface\n * @author Neverland\n * @notice Interface for the RevenueReward contract that manages token rewards distribution\n * @dev Handles reward epochs, claiming rewards, and self-repaying loan functionality\n */\ninterface IRevenueReward {\n    /// @notice Error thrown when a non-distributor address attempts to notify rewards\n    error NotRewardDistributor();\n\n    /// @notice Error thrown when a non-owner address attempts a restricted operation\n    error NotOwner();\n\n    /// @notice Error thrown when a non-DustLock address attempts a restricted operation\n    error NotDustLock();\n\n    /// @notice Error thrown when end timestamp used for calculating rewards is greater than the current time\n    error EndTimestampMoreThanCurrent();\n\n    /// @notice Error thrown when provided arrays are empty or exceed soft size limits\n    error InvalidArrayLengths();\n\n    /// @notice Error thrown when a provided reward token is not registered\n    error UnknownRewardToken();\n\n    /**\n     * @notice Emitted when rewards are claimed\n     * @param tokenId The veNFT id that produced the rewards\n     * @param user The address that received the rewards (owner or configured receiver)\n     * @param token Address of the reward token being claimed\n     * @param amount Amount of rewards claimed\n     */\n    event ClaimRewards(uint256 indexed tokenId, address indexed user, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when new rewards are notified to the contract\n     * @param from Address that notified the rewards (typically the reward distributor)\n     * @param token Address of the reward token being added\n     * @param epoch Reward epoch start timestamp (i.e., start of the week) the amount is credited to\n     * @param amount Amount of rewards added\n     */\n    event NotifyReward(address indexed from, address indexed token, uint256 epoch, uint256 amount);\n\n    /**\n     * @notice Emitted when tokens are recovered from the contract\n     * @param token Address of the token being recovered\n     * @param amount Amount of tokens recovered\n     */\n    event RecoverTokens(address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when self-repaying loan status is updated for a token\n     * @param token ID of the veNFT whose reward redirection is being configured\n     * @param rewardReceiver Address that will receive the rewards (or zero address if disabled)\n     * @param isEnabled Whether self-repaying loan is being enabled (true) or disabled (false)\n     */\n    event SelfRepayingLoanUpdate(uint256 indexed token, address rewardReceiver, bool isEnabled);\n\n    /**\n     * @notice Emitted when the reward distributor address is updated\n     * @param oldDistributor The previous reward distributor\n     * @param newDistributor The new reward distributor\n     */\n    event RewardDistributorUpdated(address indexed oldDistributor, address indexed newDistributor);\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice The address of the DustLock contract that manages veNFTs\n     * @return The IDustLock interface of the connected DustLock contract\n     */\n    function dustLock() external view returns (IDustLock);\n\n    /**\n     * @notice The address of the UserVaultFactory contract that manages user vaults\n     * @return The IUserVaultFactory interface of the connected UserVaultFactory contract\n     */\n    function userVaultFactory() external view returns (IUserVaultFactory);\n\n    /**\n     * @notice The duration of a reward epoch in seconds\n     * @dev This defines the time window for each reward distribution cycle\n     * @return Duration in seconds for each reward epoch\n     */\n    function DURATION() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of tokenIds allowed in a single batch claim.\n     * @return The maximum number of tokenIds accepted in batch calls\n     */\n    function MAX_TOKENIDS() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of reward tokens allowed in a single batch claim.\n     * @return The maximum number of reward tokens accepted in batch calls\n     */\n    function MAX_TOKENS() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                            STORAGE GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the timestamp of the last successfully processed reward claim for a token and veNFT\n     * @dev Used to calculate the amount of rewards earned since the last claim. Value is advanced to the\n     *      claim period end only when there were epochs to process; otherwise it remains unchanged.\n     * @param token The address of the reward token\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp (seconds) when rewards were last processed up to\n     */\n    function lastEarnTime(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the address authorized to add rewards to the contract\n     * @dev This address is the only one that can call notifyRewardAmount\n     *      Typically set to a protocol treasury or governance-controlled address\n     * @return The current reward distributor address\n     */\n    function rewardDistributor() external view returns (address);\n\n    /**\n     * @notice Checks if a token is registered as a valid reward token\n     * @dev Only registered reward tokens can be distributed through the contract\n     *      Tokens are registered automatically the first time they're used in notifyRewardAmount\n     * @param token The address of the token to check\n     * @return True if the token is registered as a reward token, false otherwise\n     */\n    function isRewardToken(address token) external view returns (bool);\n\n    /**\n     * @notice Returns the reward token at a specific index in the list of registered reward tokens\n     * @dev Used to enumerate all reward tokens available in the contract\n     *      Valid indices range from 0 to the number of registered reward tokens minus 1\n     * @param index The index in the reward tokens array\n     * @return The address of the reward token at the specified index\n     */\n    function rewardTokens(uint256 index) external view returns (address);\n\n    /**\n     * @notice Returns the accumulated sum of all reward distributions for a specific token\n     * @dev Used for internal reward accounting and distribution calculations\n     *      This value increases each time new rewards are notified\n     * @param token The address of the reward token\n     * @return The total amount of rewards ever distributed for this token\n     */\n    function totalRewardsPerToken(address token) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of rewards allocated for a specific token at a given epoch start\n     * @dev Rewards are tracked by epoch start timestamp (seconds), with each epoch lasting DURATION seconds.\n     * @param token The address of the reward token\n     * @param epoch The epoch start timestamp (i.e., start of the week)\n     * @return The amount of rewards allocated for the token at that epoch start\n     */\n    function tokenRewardsPerEpoch(address token, uint256 epoch) external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp when a veNFT was minted\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp when the veNFT was minted\n     */\n    function tokenMintTime(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the accumulated fractional remainder of rewards for a veNFT and token, scaled by 1e18.\n     * @dev During per-epoch reward calculations, integer division can leave a remainder that cannot be paid out.\n     *      This function exposes the running sum of those remainders for the given (token, tokenId) pair,\n     *      scaled by a factor of 1e18 to preserve precision (i.e., value is remainder * 1e18 / totalSupplyAt(epoch)).\n     *      This value is informational and not directly claimable; it helps off-chain analytics understand\n     *      the uncredited fractional rewards that have accumulated over time due to rounding.\n     * @param token The address of the reward token being tracked.\n     * @param tokenId The ID of the veNFT whose fractional remainder is queried.\n     * @return scaledRemainder The accumulated fractional rewards remainder, scaled by 1e18.\n     */\n    function tokenRewardsRemainingAccScaled(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the configured reward recipient address for a specific veNFT\n     * @dev When self-repaying loan functionality is enabled, rewards are sent to this address\n     *      Returns address(0) if no special recipient is configured (rewards go to veNFT owner)\n     * @param tokenId The ID of the veNFT to query\n     * @return The address that receives rewards for this veNFT, or address(0) if it's the owner\n     */\n    function tokenRewardReceiver(uint256 tokenId) external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the address authorized to add rewards to the contract\n     * @dev Can only be called by the current reward distributor\n     *      This is a critical permission that controls who can distribute rewards\n     * @param newRewardDistributor The address of the new reward distributor\n     */\n    function setRewardDistributor(address newRewardDistributor) external;\n\n    /**\n     * @notice Adds new rewards to the distribution pool for the next epoch\n     * @dev Can only be called by the authorized reward distributor address.\n     *      Automatically registers new tokens the first time they're used.\n     *      Rewards added during the current epoch become claimable starting the next epoch.\n     *      Emits a NotifyReward event with details about the distribution.\n     *      Reverts: NotRewardDistributor, zero address/amount checks enforced by implementation.\n     * @param token The address of the reward token to distribute\n     * @param amount The amount of rewards to add to the distribution pool\n     */\n    function notifyRewardAmount(address token, uint256 amount) external;\n\n    /**\n     * @notice Recovers unnotified balances of registered reward tokens\n     * @dev Can only be called by the reward distributor\n     *      For each registered reward token, if the contract's token balance exceeds the credited amount\n     *      tracked by totalRewardsPerToken[token], transfers the excess to the reward distributor and emits\n     *      a RecoverTokens event.\n     */\n    function recoverTokens() external;\n\n    /*//////////////////////////////////////////////////////////////\n                            NOTIFICATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Notifies the contract that a new token has been created\n     * @dev Intended to update internal state or trigger logic after a veNFT creation event\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the token (veNFT) that has been created\n     */\n    function notifyTokenMinted(uint256 tokenId) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is transferred\n     * @dev This function is called by the DustLock contract just after transferring a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being transferred\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was transferred\n     * @param from The address of the previous token owner (sender of the transfer)\n     */\n    function notifyAfterTokenTransferred(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is burned\n     * @dev This function is called by the DustLock contract just after burning a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being burned\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was burned\n     * @param from The address of the previous token owner\n     */\n    function notifyAfterTokenBurned(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles bookkeeping after two veNFTs are merged.\n     * @dev Callable only by the DustLock contract.\n     * @param fromToken The tokenId that was merged and is no longer active (source).\n     * @param toToken The tokenId that survives the merge and should receive consolidated accounting (destination).\n     * @param owner The tokens' owner.\n     */\n    function notifyAfterTokenMerged(uint256 fromToken, uint256 toToken, address owner) external;\n\n    /**\n     * @notice Handles bookkeeping after a veNFT is split into two new veNFTs.\n     * @dev Callable only by the DustLock contract.\n     *      - Initializes mint timestamps for the two new tokenIds.\n     *      - Proportionally splits the accumulated fractional rewards remainder (scaled by 1e18)\n     *        from `fromToken` between `tokenId1` and `tokenId2` using their provided amounts.\n     *      - Clears the remainder accumulator for `fromToken` and removes it from any self-repaying\n     *        loan tracking if applicable.\n     * @param fromToken The original tokenId that was split (source).\n     * @param tokenId1 The first resulting tokenId after the split.\n     * @param token1Amount The amount (voting power/shares) assigned to `tokenId1` in the split.\n     * @param tokenId2 The second resulting tokenId after the split.\n     * @param token2Amount The amount (voting power/shares) assigned to `tokenId2` in the split.\n     * @param owner The owner of the tokens involved in the split.\n     */\n    function notifyAfterTokenSplit(\n        uint256 fromToken,\n        uint256 tokenId1,\n        uint256 token1Amount,\n        uint256 tokenId2,\n        uint256 token2Amount,\n        address owner\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens\n     * @dev Calculates earned rewards for each specified token using epoch-based accounting and transfers them\n     *      to the appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured\n     *      via enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     */\n    function getReward(uint256 tokenId, address[] calldata tokens) external;\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp\n     * @dev Similar to getReward, but allows specifying a custom end timestamp for the reward calculation period.\n     *      Calculates earned rewards for each specified token using epoch-based accounting and transfers them to the\n     *      appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured via\n     *      enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to rewardPeriodEndTs to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, EndTimestampMoreThanCurrent, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     * @param rewardPeriodEndTs The end timestamp to calculate rewards up to (must not be in the future)\n     */\n    function getRewardUntilTs(uint256 tokenId, address[] calldata tokens, uint256 rewardPeriodEndTs) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays or unknown tokens.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     */\n    function getRewardBatch(uint256[] calldata tokenIds, address[] calldata tokens) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens up to a specific timestamp.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays, unknown tokens,\n     *      or if `rewardPeriodEndTs` is in the future.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     * @param rewardPeriodEndTs End timestamp for calculation (<= now).\n     */\n    function getRewardUntilTsBatch(uint256[] calldata tokenIds, address[] calldata tokens, uint256 rewardPeriodEndTs)\n        external;\n\n    /*//////////////////////////////////////////////////////////////\n                         SELF-REPAYING LOANS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Enables the self-repaying loan feature for a specific veNFT\n     * @dev Configures a custom reward receiver address (typically a loan contract).\n     *      This allows veNFT owners to use their rewards to automatically repay loans.\n     *      The getReward function must still be called to trigger the reward claim.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner, zero rewardReceiver.\n     * @param tokenId The ID of the veNFT to configure self-repaying loan for\n     */\n    function enableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Disables the self-repaying loan feature for a specific veNFT\n     * @dev Removes the custom reward receiver configuration, returning to default behavior.\n     *      After disabling, all future rewards will go directly to the veNFT owner.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner.\n     * @param tokenId The ID of the veNFT to restore default reward routing for\n     */\n    function disableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Batch enable self-repaying loan with a single receiver for many tokenIds.\n     * @dev Each tokenId must be owned by the caller. Reverts on zero rewardReceiver.\n     * @param tokenIds Array of veNFT ids to configure.\n     */\n    function enableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /**\n     * @notice Batch disable self-repaying loan for many tokenIds.\n     * @dev Each tokenId must be owned by the caller.\n     * @param tokenIds Array of veNFT ids to restore default reward routing.\n     */\n    function disableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Preview unclaimed rewards for a single reward token up to a specific timestamp.\n     * @dev Read-only mirror of claim math; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, UnknownRewardToken if not registered.\n     * @param token Reward token address to preview.\n     * @param tokenId veNFT id to preview for.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return amount Total rewards that would be claimable if claimed up to `endTs`.\n     */\n    function earnedRewards(address token, uint256 tokenId, uint256 endTs) external view returns (uint256 amount);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens at the current timestamp.\n     * @dev Convenience wrapper that uses block.timestamp internally. Returns a matrix of rewards per\n     *      tokenId (outer) per token (inner), and totals per token.\n     *      Reverts: InvalidArrayLengths on bad inputs, UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAll(address[] calldata tokens, uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens up to a specific timestamp.\n     * @dev Read-only; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, InvalidArrayLengths on bad inputs,\n     *      UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAllUntilTs(address[] calldata tokens, uint256[] calldata tokenIds, uint256 endTs)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Returns the number of registered reward tokens\n     * @return The count of reward tokens\n     */\n    function rewardTokensLength() external view returns (uint256);\n\n    /**\n     * @notice Returns the full list of registered reward tokens\n     * @return tokens An array containing all reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory tokens);\n\n    /**\n     * @notice Returns a list of user addresses with at least one active self-repaying loan within a given range.\n     * @dev Iterates over the internal set of users who have enabled self-repaying loans,\n     *      returning addresses from index `from` up to, but not including, index `to`.\n     *      If the specified range exceeds the number of users, the function adjusts accordingly.\n     * @param from The starting index (inclusive) in the user set.\n     * @param to The ending index (exclusive) in the user set.\n     * @return users An array of user addresses in the specified range who have self-repaying loans enabled.\n     */\n    function getUsersWithSelfRepayingLoan(uint256 from, uint256 to) external view returns (address[] memory);\n\n    /**\n     * @notice Returns the list of token IDs for which the given user has enabled a self-repaying loan.\n     * @dev Checks the user's internal set of token IDs with self-repaying loans and returns them as an array.\n     * @param user The address of the user to query.\n     * @return tokenIds An array of token IDs currently associated with self-repaying loans for the user.\n     */\n    function getUserTokensWithSelfRepayingLoan(address user) external view returns (uint256[] memory tokenIds);\n}\n",
        "keccak256": "0x428b509667becb91cd75d1253139e7765f11f580f5f47e70998f7bb2d4fcc5b6",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IUserVaultFactory.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title IUserVaultFactory\n * @author Neverland\n * @notice Interface for the UserVaultFactory contract.\n *         Allows creation and retrieval of user-specific vaults.\n */\ninterface IUserVaultFactory {\n    /**\n     * @notice Emitted when a new user vault is created\n     * @param user The user for whom the vault was created\n     * @param vault The address of the created vault\n     */\n    event UserVaultCreated(address indexed user, address indexed vault);\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user. Creates a new vault if none exists\n     * @dev If the vault does not exist, a new BeaconProxy is deployed and initialized for the user\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getUserVault(address user) external view returns (address vault);\n\n    /*//////////////////////////////////////////////////////////////\n                               ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user if it exists\n     * @dev If the vault does not exist, returns address(0)\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getOrCreateUserVault(address user) external returns (address vault);\n}\n",
        "keccak256": "0x2c37e5bc81e701ab66b66aea87f6daedf1ec8adf2685d14a66afe77ea477735e",
        "license": "BUSL-1.1"
      },
      "src/libraries/CommonChecksLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonChecksLibrary\n * @author Neverland\n * @notice Shared require/revert helpers for zero/invalid values used across contracts\n */\nlibrary CommonChecksLibrary {\n    /// @notice Used when a zero address is provided where not allowed.\n    error AddressZero();\n    /// @notice Used when a zero amount is provided where not allowed.\n    error ZeroAmount();\n    /// @notice Used when a range is invalid.\n    error InvalidRange();\n    /// @notice Used when two addresses are the same but must differ.\n    error SameAddress();\n    /// @notice Used when a balance is zero.\n    error ZeroBalance();\n    /// @notice Used when a tokenId is invalid.\n    error InvalidTokenId();\n    /// @notice Used when a from address is invalid.\n    error InvalidFromAddress();\n    /// @notice Used when a to address is invalid.\n    error InvalidToAddress();\n    /// @notice Used when a user address is invalid.\n    error InvalidUserAddress();\n    /// @notice Used a function is called by an account that is not permitted.\n    error UnauthorizedAccess();\n\n    /**\n     * @notice Reverts if the provided address is zero\n     * @param addressToCheck The address to check\n     */\n    function revertIfZeroAddress(address addressToCheck) internal pure {\n        if (addressToCheck == address(0)) revert AddressZero();\n    }\n\n    /**\n     * @notice Reverts if the provided amount is zero\n     * @param amount The amount to check\n     */\n    function revertIfZeroAmount(uint256 amount) internal pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n\n    /**\n     * @notice Reverts if the [from, to] range is invalid (from > to)\n     * @param from The start of the range\n     * @param to The end of the range\n     */\n    function revertIfInvalidRange(uint256 from, uint256 to) internal pure {\n        if (from > to) revert InvalidRange();\n    }\n\n    /**\n     * @notice Reverts if the two addresses are the same\n     * @param first The first address to check\n     * @param second The second address to check\n     */\n    function revertIfSameAddress(address first, address second) internal pure {\n        if (first == second) revert SameAddress();\n    }\n\n    /**\n     * @notice Reverts if the balance is zero\n     * @param balance The balance to check\n     */\n    function revertIfZeroBalance(uint256 balance) internal pure {\n        if (balance == 0) revert ZeroBalance();\n    }\n\n    /**\n     * @notice Reverts if the tokenId owner is the zero address\n     * @param owner The owner of the tokenId\n     */\n    function revertIfInvalidTokenId(address owner) internal pure {\n        if (owner == address(0)) revert InvalidTokenId();\n    }\n\n    /**\n     * @notice Reverts if the from address is zero\n     * @param from The from address to check\n     */\n    function revertIfInvalidFromAddress(address from) internal pure {\n        if (from == address(0)) revert InvalidFromAddress();\n    }\n\n    /**\n     * @notice Reverts if the to address is zero\n     * @param to The to address to check\n     */\n    function revertIfInvalidToAddress(address to) internal pure {\n        if (to == address(0)) revert InvalidToAddress();\n    }\n\n    /**\n     * @notice Reverts if the user address is zero\n     * @param user The user address to check\n     */\n    function revertIfInvalidUserAddress(address user) internal pure {\n        if (user == address(0)) revert InvalidUserAddress();\n    }\n}\n",
        "keccak256": "0xa8e23a48af12c93a809845953069be6f296d8d2e93e7cd89e5250b15b5d9f805",
        "license": "BUSL-1.1"
      },
      "src/libraries/EpochTimeLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title EpochTimeLibrary\n * @author Extended by Neverland\n * @notice Shared helpers for epoch time calculations\n */\nlibrary EpochTimeLibrary {\n    uint256 internal constant WEEK = 7 days;\n\n    /**\n     * @notice Returns the start time of the current epoch containing the given timestamp\n     * @dev Calculates the beginning of a week period by removing the remainder when dividing by WEEK\n     * @param timestamp The timestamp to calculate the epoch start for\n     * @return The timestamp for the start of the current epoch\n     */\n    function epochStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK);\n        }\n    }\n\n    /**\n     * @notice Returns the start time of the next epoch after the given timestamp\n     * @dev Calculates the beginning of the next week period by removing the remainder when dividing by WEEK and adding one WEEK\n     * @param timestamp The timestamp to calculate the next epoch from\n     * @return The timestamp for the start of the next epoch\n     */\n    function epochNext(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK;\n        }\n    }\n\n    /**\n     * @notice Returns the start time of the voting window within the current epoch\n     * @dev Voting begins 1 hour after the start of the epoch\n     * @param timestamp The timestamp within the current epoch\n     * @return The timestamp when voting begins in the current epoch\n     */\n    function epochVoteStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + 1 hours;\n        }\n    }\n\n    /**\n     * @notice Returns the end time of the voting window within the current epoch\n     * @dev Voting ends 1 hour before the end of the epoch\n     * @param timestamp The timestamp within the current epoch\n     * @return The timestamp when voting ends in the current epoch\n     */\n    function epochVoteEnd(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK - 1 hours;\n        }\n    }\n}\n",
        "keccak256": "0x5c3e1742bdd83a147f1a62e64d6a8be742cc7132a81252e373f6f810b6aef02d",
        "license": "BUSL-1.1"
      },
      "src/utils/NeverlandUiProvider.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPoolAddressesProvider} from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"@aave/core-v3/contracts/interfaces/IPriceOracleGetter.sol\";\nimport {IPoolDataProvider} from \"@aave/core-v3/contracts/interfaces/IPoolDataProvider.sol\";\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\nimport {IRevenueReward} from \"../interfaces/IRevenueReward.sol\";\nimport {IDustRewardsController} from \"../interfaces/IDustRewardsController.sol\";\nimport {INeverlandUiProvider} from \"../interfaces/INeverlandUiProvider.sol\";\nimport {INeverlandDustHelper} from \"../interfaces/INeverlandDustHelper.sol\";\n\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\nimport {EpochTimeLibrary} from \"../libraries/EpochTimeLibrary.sol\";\n\n/**\n * @title NeverlandUiProvider\n * @author Neverland\n * @notice Aggregates data from DustLock, RevenueReward, and DustRewardsController for efficient UI queries\n * @dev This contract is purely for data aggregation and contains no state-changing functions\n */\ncontract NeverlandUiProvider is INeverlandUiProvider {\n    /*//////////////////////////////////////////////////////////////\n                             CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice USD oracle unit (8 decimals)\n    uint256 private constant USD_PRICE_UNIT = 1e8;\n\n    /*//////////////////////////////////////////////////////////////\n                          IMMUTABLE CONTRACTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice DustLock contract for veNFT and voting power data\n    IDustLock public immutable dustLock;\n\n    /// @notice RevenueReward contract for revenue distribution data\n    IRevenueReward public immutable revenueReward;\n\n    /// @notice DustRewardsController contract for emission rewards data\n    IDustRewardsController public immutable dustRewardsController;\n\n    /// @notice DustOracle contract for DUST price data\n    INeverlandDustHelper public immutable dustOracle;\n\n    /// @notice Aave Lending Pool Address Provider for protocol integration\n    IPoolAddressesProvider public immutable aaveLendingPoolAddressProvider;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initialize the NeverlandUiProvider with core contract addresses\n     * @param _dustLock Address of the DustLock contract\n     * @param _revenueReward Address of the RevenueReward contract\n     * @param _dustRewardsController Address of the DustRewardsController contract\n     * @param _dustOracle Address of the DUST price oracle\n     * @param _aaveLendingPoolAddressProvider Address of the Aave Lending Pool Address Provider\n     */\n    constructor(\n        address _dustLock,\n        address _revenueReward,\n        address _dustRewardsController,\n        address _dustOracle,\n        address _aaveLendingPoolAddressProvider\n    ) {\n        CommonChecksLibrary.revertIfZeroAddress(_dustLock);\n        CommonChecksLibrary.revertIfZeroAddress(_revenueReward);\n        CommonChecksLibrary.revertIfZeroAddress(_dustRewardsController);\n        CommonChecksLibrary.revertIfZeroAddress(_dustOracle);\n        CommonChecksLibrary.revertIfZeroAddress(_aaveLendingPoolAddressProvider);\n\n        dustLock = IDustLock(_dustLock);\n        revenueReward = IRevenueReward(_revenueReward);\n        dustRewardsController = IDustRewardsController(_dustRewardsController);\n        dustOracle = INeverlandDustHelper(_dustOracle);\n        aaveLendingPoolAddressProvider = IPoolAddressesProvider(_aaveLendingPoolAddressProvider);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MAIN UI FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc INeverlandUiProvider\n    function getBatchTokenDetails(uint256[] calldata tokenIds)\n        public\n        view\n        override\n        returns (LockInfo[] memory locks, RewardSummary[] memory rewards)\n    {\n        return _getBatchTokenDetailsInternal(tokenIds);\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUserTokenCount(address user) external view override returns (uint256 count) {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n        return dustLock.balanceOf(user);\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUserDashboard(address user, uint256 offset, uint256 limit)\n        public\n        view\n        override\n        returns (UserDashboardData memory)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n\n        uint256 tokenCount = dustLock.balanceOf(user);\n        uint256 start = offset > tokenCount ? tokenCount : offset;\n        uint256 end = tokenCount;\n        unchecked {\n            // clamp end to start+limit if it doesn't overflow and is smaller than tokenCount\n            uint256 remaining = tokenCount - start;\n            if (limit < remaining) end = start + limit;\n        }\n        uint256 pageLen = end - start;\n\n        uint256[] memory tokenIds = new uint256[](pageLen);\n        for (uint256 i; i < pageLen;) {\n            try dustLock.ownerToNFTokenIdList(user, start + i) returns (uint256 tokenId) {\n                tokenIds[i] = tokenId;\n            } catch {\n                tokenIds[i] = 0;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        (LockInfo[] memory locks, RewardSummary[] memory rewardSummaries) = _getBatchTokenDetailsInternal(tokenIds);\n\n        uint256 totalVotingPower;\n        uint256 totalLockedAmount;\n        for (uint256 i; i < pageLen;) {\n            totalVotingPower += locks[i].votingPower;\n            totalLockedAmount += locks[i].amount;\n            unchecked {\n                ++i;\n            }\n        }\n\n        UserDashboardData memory dash;\n        dash.user = user;\n        dash.tokenIds = tokenIds;\n        dash.locks = locks;\n        dash.rewardSummaries = rewardSummaries;\n        dash.totalVotingPower = totalVotingPower;\n        dash.totalLockedAmount = totalLockedAmount;\n        return dash;\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getTokenDetails(uint256 tokenId) public view override returns (LockInfo memory, RewardSummary memory) {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n        (LockInfo[] memory locks, RewardSummary[] memory rewards) = _getBatchTokenDetailsInternal(tokenIds);\n        return (locks[0], rewards[0]);\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getGlobalStats() public view override returns (GlobalStats memory) {\n        address[] memory rewardTokens = revenueReward.getRewardTokens();\n        uint256[] memory totalRewardsPerToken = new uint256[](rewardTokens.length);\n\n        for (uint256 i; i < rewardTokens.length;) {\n            totalRewardsPerToken[i] = revenueReward.totalRewardsPerToken(rewardTokens[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        GlobalStats memory stats;\n        stats.totalSupply = dustLock.supply();\n        stats.totalVotingPower = dustLock.totalSupplyAt(block.timestamp);\n        stats.permanentLockBalance = dustLock.permanentLockBalance();\n        stats.rewardTokens = rewardTokens;\n        stats.totalRewardsPerToken = totalRewardsPerToken;\n        stats.epoch = dustLock.epoch();\n        stats.activeTokenCount = dustLock.tokenId();\n        return stats;\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUserRewardsSummary(address user, address[] calldata rewardTokens)\n        public\n        view\n        override\n        returns (UserRewardsSummary memory summary)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n        return _getUserRewardsSummaryInternal(user, rewardTokens);\n    }\n\n    /**\n     * @notice Internal function to get user rewards summary\n     * @param user The user address\n     * @param rewardTokens Array of reward token addresses\n     * @return summary User rewards summary\n     */\n    function _getUserRewardsSummaryInternal(address user, address[] memory rewardTokens)\n        internal\n        view\n        returns (UserRewardsSummary memory summary)\n    {\n        uint256[] memory tokenIds = _getUserRelatedTokenIds(user);\n        uint256 tokenCount = tokenIds.length;\n        uint256 rewardTokenCount = rewardTokens.length;\n\n        summary.totalRevenue = new uint256[](rewardTokenCount);\n        summary.totalEmissions = new uint256[](rewardTokenCount);\n        summary.totalHistorical = new uint256[](rewardTokenCount);\n\n        address[] memory revTokens = revenueReward.getRewardTokens();\n        if (revTokens.length > 0 && tokenCount > 0) {\n            (, uint256[] memory totalsPerToken) = revenueReward.earnedRewardsAll(revTokens, tokenIds);\n            for (uint256 j; j < rewardTokenCount;) {\n                address t = rewardTokens[j];\n                for (uint256 r; r < revTokens.length;) {\n                    if (revTokens[r] == t) {\n                        summary.totalRevenue[j] = totalsPerToken[r];\n                        break;\n                    }\n                    unchecked {\n                        ++r;\n                    }\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n        }\n\n        address[] memory emissionTokens = dustRewardsController.getRewardsList();\n        for (uint256 j; j < rewardTokenCount;) {\n            address rewardToken = rewardTokens[j];\n            for (uint256 k; k < emissionTokens.length;) {\n                if (emissionTokens[k] == rewardToken) {\n                    summary.totalEmissions[j] = _getUserEmissionRewards(user, rewardToken);\n                    break;\n                }\n                unchecked {\n                    ++k;\n                }\n            }\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /**\n     * @notice Get all tokenIds that contribute rewards to `user`: owned tokens and tokens forwarding rewards to `user` (self-repay loan)\n     * @param user The user address\n     * @return ids Array of tokenIds\n     */\n    function _getUserRelatedTokenIds(address user) internal view returns (uint256[] memory ids) {\n        uint256 owned = dustLock.balanceOf(user);\n        uint256[] memory srl = revenueReward.getUserTokensWithSelfRepayingLoan(user);\n\n        if (owned == 0 && srl.length == 0) return new uint256[](0);\n\n        // Preallocate max size, then shrink\n        uint256[] memory tmp = new uint256[](owned + srl.length);\n        uint256 n = 0;\n\n        // Add owned tokenIds (unique by ERC721 invariant)\n        for (uint256 i; i < owned;) {\n            try dustLock.ownerToNFTokenIdList(user, i) returns (uint256 tokenId) {\n                tmp[n] = tokenId;\n                unchecked {\n                    ++n;\n                }\n            } catch {\n                // Skip corrupted enumeration entries\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Add SRL tokenIds, dedup only against owned set (SRL itself is an EnumerableSet -> unique)\n        if (srl.length > 0) {\n            for (uint256 j; j < srl.length;) {\n                uint256 tokenId = srl[j];\n                bool duplicate = false;\n                // Check only the first `owned` entries (owned set) for duplicates\n                for (uint256 k; k < owned;) {\n                    if (tmp[k] == tokenId) {\n                        duplicate = true;\n                        break;\n                    }\n                    unchecked {\n                        ++k;\n                    }\n                }\n                if (!duplicate) {\n                    tmp[n] = tokenId;\n                    unchecked {\n                        ++n;\n                    }\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n        }\n\n        // Resize to actual length\n        ids = new uint256[](n);\n        for (uint256 i; i < n;) {\n            ids[i] = tmp[i];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUserRevenueRewards(address user, address[] calldata rewardTokens)\n        public\n        view\n        override\n        returns (uint256[] memory revenueRewards)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n\n        uint256[] memory tokenIds = _getUserRelatedTokenIds(user);\n        uint256 tokenCount = tokenIds.length;\n        uint256 rewardTokenCount = rewardTokens.length;\n\n        // Initialize result (defaults to zeros)\n        revenueRewards = new uint256[](rewardTokenCount);\n\n        // Gather all user's tokenIds\n        if (tokenCount == 0) return revenueRewards;\n\n        // Fetch only registered revenue tokens and compute totals via matrix API\n        address[] memory revTokens = revenueReward.getRewardTokens();\n        if (revTokens.length == 0 || tokenIds.length == 0) return revenueRewards;\n\n        (, uint256[] memory totalsPerToken) = revenueReward.earnedRewardsAll(revTokens, tokenIds);\n\n        // Map into requested order; non-revenue tokens remain zero\n        for (uint256 j; j < rewardTokenCount;) {\n            address t = rewardTokens[j];\n            for (uint256 r; r < revTokens.length;) {\n                if (revTokens[r] == t) {\n                    revenueRewards[j] = totalsPerToken[r];\n                    break;\n                }\n                unchecked {\n                    ++r;\n                }\n            }\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUserEmissionRewards(address user, address[] calldata rewardTokens)\n        public\n        view\n        override\n        returns (uint256[] memory emissionRewards)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n\n        address[] memory emissionTokens = dustRewardsController.getRewardsList();\n        uint256 rewardTokenCount = rewardTokens.length;\n        // Allocate once outside the loop (was incorrectly reallocated per-iteration)\n        emissionRewards = new uint256[](rewardTokenCount);\n        for (uint256 j; j < rewardTokenCount;) {\n            address rewardToken = rewardTokens[j];\n\n            // Check if this token is supported by the emissions controller\n            bool isEmissionToken = false;\n            for (uint256 k; k < emissionTokens.length;) {\n                if (emissionTokens[k] == rewardToken) {\n                    isEmissionToken = true;\n                    break;\n                }\n                unchecked {\n                    ++k;\n                }\n            }\n\n            if (isEmissionToken) emissionRewards[j] = _getUserEmissionRewards(user, rewardToken);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUserEmissionBreakdown(address user, address rewardToken)\n        public\n        view\n        override\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n        assets = _getAllLendingPoolAssets();\n        uint256 n = assets.length;\n        amounts = new uint256[](n);\n        for (uint256 i; i < n;) {\n            amounts[i] = _calculateAssetEmissionRewards(user, assets[i], rewardToken);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUserEmissions(address user)\n        public\n        view\n        override\n        returns (address[] memory rewardTokens, uint256[] memory totalRewards)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n\n        rewardTokens = dustRewardsController.getRewardsList();\n        uint256 n = rewardTokens.length;\n        totalRewards = new uint256[](n);\n\n        for (uint256 i; i < n;) {\n            totalRewards[i] = _getUserEmissionRewards(user, rewardTokens[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           UTILITY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUnlockSchedule(address user)\n        public\n        view\n        override\n        returns (uint256[] memory unlockTimes, uint256[] memory amounts, uint256[] memory tokenIds)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n\n        uint256 tokenCount = dustLock.balanceOf(user);\n        uint256 unlockCount = 0;\n        for (uint256 i; i < tokenCount;) {\n            try dustLock.ownerToNFTokenIdList(user, i) returns (uint256 tokenId) {\n                IDustLock.LockedBalance memory locked = dustLock.locked(tokenId);\n                if (!locked.isPermanent && locked.end > block.timestamp) {\n                    ++unlockCount;\n                }\n            } catch {\n                // Skip corrupted enumeration entries\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        unlockTimes = new uint256[](unlockCount);\n        amounts = new uint256[](unlockCount);\n        tokenIds = new uint256[](unlockCount);\n\n        uint256 index = 0;\n        for (uint256 i; i < tokenCount;) {\n            try dustLock.ownerToNFTokenIdList(user, i) returns (uint256 tokenId) {\n                IDustLock.LockedBalance memory locked = dustLock.locked(tokenId);\n\n                if (!locked.isPermanent && locked.end > block.timestamp) {\n                    unlockTimes[index] = locked.end;\n                    amounts[index] = uint256(locked.amount);\n                    tokenIds[index] = tokenId;\n                    ++index;\n                }\n            } catch {\n                // Skip corrupted enumeration entries\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getEssentialUserView(address user, uint256 offset, uint256 limit)\n        public\n        view\n        override\n        returns (EssentialUserView memory)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n        EssentialUserView memory v;\n        v.user = getUserDashboard(user, offset, limit);\n        v.globalStats = getGlobalStats();\n        (v.emissions.rewardTokens, v.emissions.totalRewards) = getUserEmissions(user);\n        v.marketData = getMarketData();\n        return v;\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getExtendedUserView(address user, uint256 offset, uint256 limit)\n        public\n        view\n        override\n        returns (ExtendedUserView memory)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n        ExtendedUserView memory ext;\n\n        // Build unlock schedule for the requested page only using dashboard page tokenIds\n        UserDashboardData memory pageDash = getUserDashboard(user, offset, limit);\n        uint256 nT = pageDash.tokenIds.length;\n        uint256 count;\n        for (uint256 i; i < nT;) {\n            IDustLock.LockedBalance memory lockInfo = dustLock.locked(pageDash.tokenIds[i]);\n            if (!lockInfo.isPermanent && lockInfo.end > block.timestamp) {\n                unchecked {\n                    ++count;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        uint256[] memory uts = new uint256[](count);\n        uint256[] memory ams = new uint256[](count);\n        uint256[] memory tids = new uint256[](count);\n        uint256 idx;\n        for (uint256 i; i < nT;) {\n            uint256 tid = pageDash.tokenIds[i];\n            IDustLock.LockedBalance memory lockInfo2 = dustLock.locked(tid);\n            if (!lockInfo2.isPermanent && lockInfo2.end > block.timestamp) {\n                uts[idx] = lockInfo2.end;\n                ams[idx] = uint256(lockInfo2.amount);\n                tids[idx] = tid;\n                unchecked {\n                    ++idx;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        ext.unlockSchedule = UnlockSchedule({unlockTimes: uts, amounts: ams, tokenIds: tids});\n\n        // Keep view lightweight to avoid stack/gas issues in large users; fetch detailed components separately\n        ext.rewardsSummary.totalRevenue = new uint256[](0);\n        ext.rewardsSummary.totalEmissions = new uint256[](0);\n        ext.rewardsSummary.totalHistorical = new uint256[](0);\n        ext.allPrices = getAllPrices();\n        ext.emissionBreakdowns = new EmissionAssetBreakdown[](0);\n        return ext;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         COMPREHENSIVE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc INeverlandUiProvider\n    function getMarketData() public view override returns (MarketData memory) {\n        address[] memory rewardTokens = revenueReward.getRewardTokens();\n        uint256 length = rewardTokens.length;\n\n        uint256[] memory balances = new uint256[](length);\n        uint256[] memory rates = new uint256[](length);\n        uint256[] memory epochRewards = new uint256[](length);\n        uint256[] memory nextEpochRewards = new uint256[](length);\n\n        uint256 currentEpoch = EpochTimeLibrary.epochStart(block.timestamp);\n        uint256 nextEpoch = EpochTimeLibrary.epochNext(block.timestamp);\n\n        for (uint256 i; i < length;) {\n            address token = rewardTokens[i];\n            balances[i] = IERC20(token).balanceOf(address(revenueReward));\n            uint256 perEpoch = revenueReward.tokenRewardsPerEpoch(token, currentEpoch);\n            rates[i] = perEpoch;\n            epochRewards[i] = perEpoch;\n            nextEpochRewards[i] = revenueReward.tokenRewardsPerEpoch(token, nextEpoch);\n            unchecked {\n                ++i;\n            }\n        }\n\n        MarketData memory m;\n        m.rewardTokens = rewardTokens;\n        m.rewardTokenBalances = balances;\n        m.distributionRates = rates;\n        m.nextEpochTimestamp = nextEpoch;\n        m.currentEpoch = dustLock.epoch();\n        m.epochRewards = epochRewards;\n        m.nextEpochRewards = nextEpochRewards;\n        m.totalValueLockedUSD = dustOracle.getDustValueInUSD(dustLock.supply());\n        return m;\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getAllPrices() public view override returns (PriceData memory) {\n        address[] memory rewardTokens = revenueReward.getRewardTokens();\n        uint256 length = rewardTokens.length + 1;\n\n        PriceData memory p;\n        p.tokens = new address[](length);\n        p.prices = new uint256[](length);\n        p.lastUpdated = new uint256[](length);\n        p.isStale = new bool[](length);\n\n        p.tokens[0] = dustLock.token();\n        (p.prices[0],) = dustOracle.getPrice();\n        p.lastUpdated[0] = dustOracle.latestTimestamp();\n        p.isStale[0] = dustOracle.isPriceCacheStale();\n        for (uint256 i; i < rewardTokens.length;) {\n            uint256 idx = i + 1;\n            address t = rewardTokens[i];\n            p.tokens[idx] = t;\n            p.prices[idx] = _getTokenPriceInUSD(t);\n            p.lastUpdated[idx] = block.timestamp;\n            unchecked {\n                ++i;\n            }\n        }\n        return p;\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getNetworkData() public view override returns (NetworkData memory) {\n        NetworkData memory n;\n        n.currentBlock = block.number;\n        n.currentTimestamp = block.timestamp;\n        n.gasPrice = tx.gasprice;\n        return n;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to get batch token details\n     * @param tokenIds Array of veNFT token IDs\n     * @return locks Array of detailed lock information\n     * @return rewards Array of reward summaries\n     */\n    function _getBatchTokenDetailsInternal(uint256[] memory tokenIds)\n        internal\n        view\n        returns (LockInfo[] memory locks, RewardSummary[] memory rewards)\n    {\n        uint256 length = tokenIds.length;\n        locks = new LockInfo[](length);\n        rewards = new RewardSummary[](length);\n\n        address[] memory rewardTokens = revenueReward.getRewardTokens();\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 tokenId = tokenIds[i];\n            locks[i] = _getLockInfo(tokenId);\n            rewards[i] = _getRewardSummary(tokenId, rewardTokens);\n        }\n    }\n\n    /**\n     * @notice Get detailed lock information for a token\n     * @param tokenId The veNFT token ID\n     * @return LockInfo Detailed lock information\n     */\n    function _getLockInfo(uint256 tokenId) internal view returns (LockInfo memory) {\n        IDustLock.LockedBalance memory locked = dustLock.locked(tokenId);\n        address owner = dustLock.ownerOf(tokenId);\n        uint256 votingPower = dustLock.balanceOfNFT(tokenId);\n        address rewardReceiver = revenueReward.tokenRewardReceiver(tokenId);\n\n        LockInfo memory info;\n        info.tokenId = tokenId;\n        info.amount = uint256(locked.amount);\n        info.end = locked.end;\n        info.effectiveStart = locked.effectiveStart;\n        info.isPermanent = locked.isPermanent;\n        info.votingPower = votingPower;\n        info.rewardReceiver = rewardReceiver;\n        info.owner = owner;\n        return info;\n    }\n\n    /**\n     * @notice Get reward summary for a token\n     * @param tokenId The veNFT token ID\n     * @param rewardTokens Array of reward token addresses\n     * @return RewardSummary Reward summary for the token\n     */\n    function _getRewardSummary(uint256 tokenId, address[] memory rewardTokens)\n        internal\n        view\n        returns (RewardSummary memory)\n    {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n\n        uint256 length = rewardTokens.length;\n        uint256[] memory emissionRewards = new uint256[](length);\n        uint256[] memory totalEarned = new uint256[](length);\n        uint256[] memory revenueRewardsResult = new uint256[](length);\n\n        // Only call earnedRewardsAll if there are reward tokens\n        if (rewardTokens.length > 0) {\n            try revenueReward.earnedRewardsAll(rewardTokens, tokenIds) returns (\n                uint256[][] memory matrix, uint256[] memory\n            ) {\n                revenueRewardsResult = matrix.length > 0 ? matrix[0] : new uint256[](length);\n            } catch {\n                // If earnedRewardsAll fails (e.g., UnknownRewardToken), return zeros\n                revenueRewardsResult = new uint256[](length);\n            }\n        }\n\n        RewardSummary memory summary;\n        summary.tokenId = tokenId;\n        summary.revenueRewards = revenueRewardsResult;\n        summary.emissionRewards = emissionRewards;\n        summary.rewardTokens = rewardTokens;\n        summary.totalEarned = totalEarned;\n        return summary;\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getProtocolMeta() public view returns (ProtocolMeta memory meta) {\n        meta.dustLock = address(dustLock);\n        meta.revenueReward = address(revenueReward);\n        meta.dustRewardsController = address(dustRewardsController);\n        meta.dustOracle = address(dustOracle);\n        meta.earlyWithdrawPenalty = dustLock.earlyWithdrawPenalty();\n        meta.minLockAmount = dustLock.minLockAmount();\n        try revenueReward.rewardDistributor() returns (address rd) {\n            meta.rewardDistributor = rd;\n        } catch {\n            meta.rewardDistributor = address(0);\n        }\n        meta.revenueRewardTokens = revenueReward.getRewardTokens();\n        meta.emissionRewardTokens = dustRewardsController.getRewardsList();\n        meta.emissionStrategies = new address[](meta.emissionRewardTokens.length);\n        for (uint256 i; i < meta.emissionRewardTokens.length;) {\n            meta.emissionStrategies[i] = dustRewardsController.getTransferStrategy(meta.emissionRewardTokens[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ONE-CALL UI AGGREGATES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUiBootstrap() public view override returns (UiBootstrap memory boot) {\n        boot.meta = getProtocolMeta();\n        boot.globalStats = getGlobalStats();\n        boot.marketData = getMarketData();\n        boot.allPrices = getAllPrices();\n        boot.network = getNetworkData();\n    }\n\n    /// @inheritdoc INeverlandUiProvider\n    function getUiFullBundle(address user, uint256 offset, uint256 limit)\n        public\n        view\n        override\n        returns (UiFullBundle memory bundle)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(user);\n        bundle.meta = getProtocolMeta();\n        bundle.essential = getEssentialUserView(user, offset, limit);\n        bundle.extended = getExtendedUserView(user, offset, limit);\n        bundle.network = getNetworkData();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EMISSION REWARD HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get user's total emission rewards for a specific reward token\n     * @param user User address\n     * @param rewardToken Reward token address\n     * @return totalRewards Total emission rewards for the user\n     */\n    function _getUserEmissionRewards(address user, address rewardToken) internal view returns (uint256 totalRewards) {\n        address[] memory assets = _getAllLendingPoolAssets();\n\n        for (uint256 i = 0; i < assets.length; ++i) {\n            address asset = assets[i];\n            uint256 userBalance = _getUserAssetBalance(user, asset);\n\n            if (userBalance > 0) {\n                totalRewards += _calculateAssetEmissionRewards(user, asset, rewardToken);\n            }\n        }\n    }\n\n    /**\n     * @notice Get all lending pool assets from Aave Protocol Data Provider\n     * @return assets Array of lending pool asset addresses (ATokens + Variable Debt Tokens)\n     */\n    function _getAllLendingPoolAssets() internal view returns (address[] memory assets) {\n        address dataProviderAddr = aaveLendingPoolAddressProvider.getPoolDataProvider();\n        if (dataProviderAddr == address(0)) {\n            return new address[](0);\n        }\n\n        IPoolDataProvider dp = IPoolDataProvider(dataProviderAddr);\n\n        // Get all reserve tokens\n        IPoolDataProvider.TokenData[] memory reserveTokens;\n        try dp.getAllReservesTokens() returns (IPoolDataProvider.TokenData[] memory tokens) {\n            reserveTokens = tokens;\n        } catch {\n            return new address[](0);\n        }\n\n        uint256 reserveTokensLen = reserveTokens.length;\n        if (reserveTokensLen == 0) return new address[](0);\n\n        assets = new address[](reserveTokensLen * 2);\n        uint256 assetCount = 0;\n\n        for (uint256 i = 0; i < reserveTokensLen; ++i) {\n            try dp.getReserveTokensAddresses(reserveTokens[i].tokenAddress) returns (\n                address aTokenAddr, address, /*stableDebt*/ address variableDebtTokenAddr\n            ) {\n                if (aTokenAddr != address(0)) {\n                    assets[assetCount] = aTokenAddr;\n                    unchecked {\n                        ++assetCount;\n                    }\n                }\n\n                if (variableDebtTokenAddr != address(0)) {\n                    assets[assetCount] = variableDebtTokenAddr;\n                    unchecked {\n                        ++assetCount;\n                    }\n                }\n            } catch {\n                continue;\n            }\n        }\n\n        if (assetCount != reserveTokensLen * 2) {\n            address[] memory resizedAssets = new address[](assetCount);\n            for (uint256 i = 0; i < assetCount; ++i) {\n                resizedAssets[i] = assets[i];\n            }\n            assets = resizedAssets;\n        }\n    }\n\n    /**\n     * @notice Get user's balance in a specific lending pool asset\n     * @param user User address\n     * @param asset Asset address (aToken)\n     * @return balance User's balance in the asset\n     */\n    function _getUserAssetBalance(address user, address asset) internal view returns (uint256 balance) {\n        try IERC20(asset).balanceOf(user) returns (uint256 userBalance) {\n            balance = userBalance;\n        } catch {\n            balance = 0;\n        }\n    }\n\n    /**\n     * @notice Calculate emission rewards for a user on a specific asset\n     * @param user User address\n     * @param asset Asset address\n     * @param rewardToken Reward token address\n     * @return rewards Calculated emission rewards\n     */\n    function _calculateAssetEmissionRewards(address user, address asset, address rewardToken)\n        internal\n        view\n        returns (uint256 rewards)\n    {\n        uint256 direct = _tryUserRewardsSingle(user, asset, rewardToken);\n        if (direct > 0) return direct;\n\n        uint256 accrued = _tryUserAccruedProRata(user, asset, rewardToken);\n        if (accrued > 0) return accrued;\n\n        return _calculateManualEmissionRewards(user, asset, rewardToken);\n    }\n\n    /**\n     * @notice Manual calculation of emission rewards using indices\n     * @param user User address\n     * @param asset Asset address\n     * @param rewardToken Reward token address\n     * @return rewards Manually calculated rewards\n     */\n    function _calculateManualEmissionRewards(address user, address asset, address rewardToken)\n        internal\n        view\n        returns (uint256 rewards)\n    {\n        (bool ok, uint256 assetIndex, uint256 emissionPerSecond, uint256 lastUpdateTimestamp, uint256 distributionEnd) =\n            _safeGetRewardsData(asset, rewardToken);\n        if (!ok || emissionPerSecond < 1) return 0;\n\n        uint256 userBalance = _getUserAssetBalance(user, asset);\n        if (userBalance < 1) return 0;\n\n        (bool hasUserIndex, uint256 userIndex) = _safeGetUserAssetIndex(user, asset, rewardToken);\n        if (hasUserIndex && assetIndex > userIndex) {\n            uint256 indexDiff = assetIndex - userIndex;\n            return (userBalance * indexDiff) / 1e27;\n        }\n\n        if (distributionEnd <= lastUpdateTimestamp) return 0;\n        uint256 activeEnd = distributionEnd < block.timestamp ? distributionEnd : block.timestamp;\n        uint256 activeDuration = activeEnd - lastUpdateTimestamp;\n        uint256 totalEmissions = emissionPerSecond * activeDuration;\n        uint256 totalSupply = _safeTotalSupply(asset);\n        if (totalSupply < 1) return 0;\n        return (totalEmissions * userBalance) / totalSupply;\n    }\n\n    /// @notice Tries to read user rewards via controller for a single asset\n    /// @param user The user address\n    /// @param asset The asset address\n    /// @param rewardToken The reward token address\n    /// @return amount Rewards amount (0 on failure)\n    function _tryUserRewardsSingle(address user, address asset, address rewardToken)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        address[] memory singleAsset = new address[](1);\n        singleAsset[0] = asset;\n        try dustRewardsController.getUserRewards(singleAsset, user, rewardToken) returns (uint256 userRewards) {\n            return userRewards;\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice Estimates rewards pro-rata from accrued rewards across all assets\n    /// @param user The user address\n    /// @param asset The asset address\n    /// @param rewardToken The reward token address\n    /// @return amount Estimated rewards (0 on failure)\n    function _tryUserAccruedProRata(address user, address asset, address rewardToken)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        try dustRewardsController.getUserAccruedRewards(user, rewardToken) returns (uint256 accruedRewards) {\n            if (accruedRewards < 1) return 0;\n            uint256 userAssetBalance = _getUserAssetBalance(user, asset);\n            if (userAssetBalance < 1) return 0;\n            uint256 totalUserBalance = _getTotalUserBalance(user);\n            if (totalUserBalance < 1) return 0;\n            return (accruedRewards * userAssetBalance) / totalUserBalance;\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice Safely reads rewards data for an asset/reward pair\n    /// @param asset The asset address\n    /// @param rewardToken The reward token address\n    /// @return ok True if the call succeeded\n    /// @return assetIndex Asset index value\n    /// @return emissionPerSecond Emission rate per second\n    /// @return lastUpdateTimestamp Last update timestamp\n    /// @return distributionEnd Distribution end timestamp\n    function _safeGetRewardsData(address asset, address rewardToken)\n        internal\n        view\n        returns (bool, uint256, uint256, uint256, uint256)\n    {\n        try dustRewardsController.getRewardsData(asset, rewardToken) returns (\n            uint256 assetIndex, uint256 emissionPerSecond, uint256 lastUpdateTimestamp, uint256 distributionEnd\n        ) {\n            return (true, assetIndex, emissionPerSecond, lastUpdateTimestamp, distributionEnd);\n        } catch {\n            return (false, 0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Safely reads user's asset index for a given reward\n    /// @param user The user address\n    /// @param asset The asset address\n    /// @param rewardToken The reward token address\n    /// @return ok True if the call succeeded\n    /// @return userIndex The user index value\n    function _safeGetUserAssetIndex(address user, address asset, address rewardToken)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        try dustRewardsController.getUserAssetIndex(user, asset, rewardToken) returns (uint256 userIndex) {\n            return (true, userIndex);\n        } catch {\n            return (false, 0);\n        }\n    }\n\n    /// @notice Safely returns total supply for an ERC20 asset (0 on failure)\n    /// @param asset The asset address\n    /// @return supply Total supply\n    function _safeTotalSupply(address asset) internal view returns (uint256 supply) {\n        try IERC20(asset).totalSupply() returns (uint256 totalSupply) {\n            return totalSupply;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get total user balance across all lending assets\n     * @param user User address\n     * @return totalBalance Total balance across all assets\n     */\n    function _getTotalUserBalance(address user) internal view returns (uint256 totalBalance) {\n        address[] memory assets = _getAllLendingPoolAssets();\n\n        for (uint256 i = 0; i < assets.length; ++i) {\n            totalBalance += _getUserAssetBalance(user, assets[i]);\n        }\n    }\n\n    /// @notice Returns token USD price (8 decimals) using DustHelper for DUST and Aave Oracle for pool assets\n    /// @param token The token address\n    /// @return price USD price (8 decimals)\n    function _getTokenPriceInUSD(address token) internal view returns (uint256 price) {\n        if (token == dustLock.token()) {\n            (price,) = dustOracle.getPrice();\n            return price;\n        }\n\n        address oracleAddr = aaveLendingPoolAddressProvider.getPriceOracle();\n        if (oracleAddr == address(0)) revert PriceOracleUnavailable();\n\n        IPriceOracleGetter oracle = IPriceOracleGetter(oracleAddr);\n        uint256 unit;\n        try oracle.BASE_CURRENCY_UNIT() returns (uint256 u) {\n            unit = u;\n        } catch {\n            revert PriceOracleUnavailable();\n        }\n        if (unit < 1) revert PriceOracleUnavailable();\n\n        uint256 p;\n        try oracle.getAssetPrice(token) returns (uint256 price_) {\n            p = price_;\n        } catch {\n            revert PriceOracleUnavailable();\n        }\n        if (p < 1) revert AssetPriceUnavailable(token);\n\n        if (unit == USD_PRICE_UNIT) return p;\n        return (p * USD_PRICE_UNIT) / unit;\n    }\n}\n",
        "keccak256": "0xfbce7ef4fe1d5b0736e3e11a9cf51c0848881b42e97a884f2fe77bfb07b11371",
        "license": "BUSL-1.1"
      }
    },
    "version": 1
  },
  "address": "0x733241d82C4410ec79C6ec9561440B463C0d6007"
}