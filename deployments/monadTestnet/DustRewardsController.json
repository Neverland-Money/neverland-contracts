{
  "networkName": "monadTestnet",
  "chainId": 10143,
  "contract": "DustRewardsController",
  "metadata": {
    "compiler": {
      "version": "0.8.30+commit.73712a01"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "emissionManager",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "name": "ClaimerUnauthorized",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidRewardAddress",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidToAddress",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidUserAddress",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "OnlyEmissionManagerOrSelf",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "StrategyNotContract",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "StrategyZeroAddress",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "TransferError",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "assetIndex",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "userIndex",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "rewardsAccrued",
              "type": "uint256"
            }
          ],
          "name": "Accrued",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "oldEmission",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "newEmission",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "oldDistributionEnd",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "newDistributionEnd",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "assetIndex",
              "type": "uint256"
            }
          ],
          "name": "AssetConfigUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "claimer",
              "type": "address"
            }
          ],
          "name": "ClaimerSet",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "claimer",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "RewardsClaimed",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "transferStrategy",
              "type": "address"
            }
          ],
          "name": "TransferStrategyInstalled",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "EMISSION_MANAGER",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "REVISION",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lockTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "claimAllRewards",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "rewardsList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "claimedAmounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lockTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "claimAllRewardsOnBehalf",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "rewardsList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "claimedAmounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256",
              "name": "lockTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "claimAllRewardsToSelf",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "rewardsList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "claimedAmounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lockTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "claimRewards",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lockTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "claimRewardsOnBehalf",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lockTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "claimRewardsToSelf",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "internalType": "uint88",
                  "name": "emissionPerSecond",
                  "type": "uint88"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "distributionEnd",
                  "type": "uint32"
                },
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "reward",
                  "type": "address"
                },
                {
                  "internalType": "contract ITransferStrategyBase",
                  "name": "transferStrategy",
                  "type": "address"
                },
                {
                  "internalType": "contract IEACAggregatorProxy",
                  "name": "rewardOracle",
                  "type": "address"
                }
              ],
              "internalType": "struct RewardsDataTypes.RewardsConfigInput[]",
              "name": "config",
              "type": "tuple[]"
            }
          ],
          "name": "configureAssets",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getAllUserRewards",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "rewardsList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "unclaimedAmounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            }
          ],
          "name": "getAssetDecimals",
          "outputs": [
            {
              "internalType": "uint8",
              "name": "",
              "type": "uint8"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            }
          ],
          "name": "getAssetIndex",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            }
          ],
          "name": "getClaimer",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            }
          ],
          "name": "getDistributionEnd",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getEmissionManager",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            }
          ],
          "name": "getRewardsByAsset",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "",
              "type": "address[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            }
          ],
          "name": "getRewardsData",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getRewardsList",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "",
              "type": "address[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            }
          ],
          "name": "getTransferStrategy",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            }
          ],
          "name": "getUserAccruedRewards",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            }
          ],
          "name": "getUserAssetIndex",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            }
          ],
          "name": "getUserRewards",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "userBalance",
              "type": "uint256"
            }
          ],
          "name": "handleAction",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "name": "initialize",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "claimer",
              "type": "address"
            }
          ],
          "name": "setClaimer",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "newDistributionEnd",
              "type": "uint32"
            }
          ],
          "name": "setDistributionEnd",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "rewards",
              "type": "address[]"
            },
            {
              "internalType": "uint88[]",
              "name": "newEmissionsPerSecond",
              "type": "uint88[]"
            }
          ],
          "name": "setEmissionPerSecond",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "internalType": "contract IDustTransferStrategy",
              "name": "transferStrategy",
              "type": "address"
            }
          ],
          "name": "setTransferStrategy",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "devdoc": {
        "author": "Original implementation by AaveExtended by Neverland",
        "events": {
          "Accrued(address,address,address,uint256,uint256,uint256)": {
            "details": "Emitted when rewards of an asset are accrued on behalf of a user.",
            "params": {
              "asset": "The address of the incentivized asset",
              "assetIndex": "The index of the asset distribution",
              "reward": "The address of the reward token",
              "rewardsAccrued": "The amount of rewards accrued",
              "user": "The address of the user that rewards are accrued on behalf of",
              "userIndex": "The index of the asset distribution on behalf of the user"
            }
          },
          "AssetConfigUpdated(address,address,uint256,uint256,uint256,uint256,uint256)": {
            "details": "Emitted when the configuration of the rewards of an asset is updated.",
            "params": {
              "asset": "The address of the incentivized asset",
              "assetIndex": "The index of the asset distribution",
              "newDistributionEnd": "The new end timestamp of the reward distribution",
              "newEmission": "The new emissions per second value of the reward distribution",
              "oldDistributionEnd": "The old end timestamp of the reward distribution",
              "oldEmission": "The old emissions per second value of the reward distribution",
              "reward": "The address of the reward token"
            }
          },
          "ClaimerSet(address,address)": {
            "params": {
              "claimer": "The address of the claimer",
              "user": "The address of the user"
            }
          },
          "RewardsClaimed(address,address,address,address,uint256)": {
            "params": {
              "amount": "The amount of rewards claimed",
              "claimer": "The address of the claimer",
              "reward": "The address of the token reward is claimed",
              "to": "The address of the receiver of the rewards",
              "user": "The address of the user rewards has been claimed on behalf of"
            }
          },
          "TransferStrategyInstalled(address,address)": {
            "params": {
              "reward": "The address of the token reward",
              "transferStrategy": "The address of TransferStrategy contract"
            }
          }
        },
        "kind": "dev",
        "methods": {
          "claimAllRewards(address[],address,uint256,uint256)": {
            "details": "Processes all reward types in a single transaction for efficiency      Returns two parallel arrays with reward tokens and their claimed amounts      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs",
            "params": {
              "assets": "Array of asset addresses to check for eligible distributions",
              "lockTime": "Optional lock duration in seconds when claiming as veNFT (0 for no lock)",
              "to": "The address that will receive the rewards",
              "tokenId": "Optional veNFT ID when adding rewards to an existing position (0 for new position)"
            },
            "returns": {
              "claimedAmounts": "Array of claimed amounts, with indices matching the rewardsList array",
              "rewardsList": "Array of addresses of all claimed reward tokens"
            }
          },
          "claimAllRewardsOnBehalf(address[],address,address,uint256,uint256)": {
            "details": "Similar to claimAllRewards but allows a whitelisted claimer to claim on behalf of another user      The claimer must be previously authorized by the user with setClaimer via \"allowClaimOnBehalf\" function      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs",
            "params": {
              "assets": "Array of asset addresses to check for eligible distributions",
              "lockTime": "Optional lock duration in seconds when claiming as veNFT (0 for no lock)",
              "to": "The address that will receive the rewards",
              "tokenId": "Optional veNFT ID when adding rewards to an existing position (0 for new position)",
              "user": "The address of the user whose rewards are being claimed"
            },
            "returns": {
              "claimedAmounts": "Array of claimed amounts, with indices matching the rewardsList array",
              "rewardsList": "Array of addresses of all claimed reward tokens"
            }
          },
          "claimAllRewardsToSelf(address[],uint256,uint256)": {
            "details": "Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards",
            "params": {
              "assets": "The list of assets to check eligible distributions before claiming rewards",
              "lockTime": "Optional lock time for supported rewards",
              "tokenId": "Optional tokenId for supported rewards"
            },
            "returns": {
              "claimedAmounts": "List that contains the claimed amount per reward, following same order as \"rewardsList\"",
              "rewardsList": "List of addresses of the reward tokens"
            }
          },
          "claimRewards(address[],uint256,address,address,uint256,uint256)": {
            "details": "Calculates and transfers accumulated rewards to the specified recipient      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs",
            "params": {
              "amount": "The amount of rewards to claim (use type(uint256).max for all available rewards)",
              "assets": "Array of asset addresses to check for eligible distributions",
              "lockTime": "Optional lock duration in seconds when claiming as veNFT (0 for no lock)",
              "reward": "The address of the reward token to claim",
              "to": "The address that will receive the rewards",
              "tokenId": "Optional veNFT ID when adding rewards to an existing position (0 for new position)"
            },
            "returns": {
              "_0": "The actual amount of rewards claimed"
            }
          },
          "claimRewardsOnBehalf(address[],uint256,address,address,address,uint256,uint256)": {
            "details": "Allows a whitelisted claimer to claim rewards for another user      The claimer must be previously authorized via setClaimer function      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs",
            "params": {
              "amount": "The amount of rewards to claim (use type(uint256).max for all available rewards)",
              "assets": "Array of asset addresses to check for eligible distributions",
              "lockTime": "Optional lock duration in seconds when claiming as veNFT (0 for no lock)",
              "reward": "The address of the reward token to claim",
              "to": "The address that will receive the rewards",
              "tokenId": "Optional veNFT ID when adding rewards to an existing position (0 for new position)",
              "user": "The address of the user whose rewards are being claimed"
            },
            "returns": {
              "_0": "The actual amount of rewards claimed"
            }
          },
          "claimRewardsToSelf(address[],uint256,address,uint256,uint256)": {
            "details": "Convenience function that claims rewards and sends them to the caller      Equivalent to calling claimRewards with 'to' set to msg.sender      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs",
            "params": {
              "amount": "The amount of rewards to claim (use type(uint256).max for all available rewards)",
              "assets": "Array of asset addresses to check for eligible distributions",
              "lockTime": "Optional lock duration in seconds when claiming as veNFT (0 for no lock)",
              "reward": "The address of the reward token to claim",
              "tokenId": "Optional veNFT ID when adding rewards to an existing position (0 for new position)"
            },
            "returns": {
              "_0": "The actual amount of rewards claimed"
            }
          },
          "configureAssets((uint88,uint256,uint32,address,address,address,address)[])": {
            "details": "Sets up reward distributions for assets with specified emission rates      Each asset can be configured with its own reward token, distribution schedule, and transfer strategy      Only callable by the contract admin",
            "params": {
              "config": "Array of configuration inputs with the following fields for each asset:   - emissionPerSecond: Rate of reward distribution per second (in reward token units)   - totalSupply: Current total supply of the incentivized asset   - distributionEnd: Timestamp when reward distribution ends   - asset: Address of the asset being incentivized   - reward: Address of the reward token to distribute   - transferStrategy: Implementation of IDustTransferStrategy for reward transfers   - rewardOracle: Not used in Neverland implementation, can be set to address(0)"
            }
          },
          "constructor": {
            "params": {
              "emissionManager": "The address of the emission manager (Aave semantics)"
            }
          },
          "getAllUserRewards(address[],address)": {
            "details": "Returns a list all rewards of a user, including already accrued and unrealized claimable rewards",
            "params": {
              "assets": "List of incentivized assets to check eligible distributions",
              "user": "The address of the user"
            },
            "returns": {
              "rewardsList": "The list of reward addresses",
              "unclaimedAmounts": "The list of unclaimed amount of rewards*"
            }
          },
          "getAssetDecimals(address)": {
            "details": "Returns the decimals of an asset to calculate the distribution delta",
            "params": {
              "asset": "The address to retrieve decimals"
            },
            "returns": {
              "_0": "The decimals of an underlying asset"
            }
          },
          "getAssetIndex(address,address)": {
            "details": "Calculates the next value of an specific distribution index, with validations.",
            "params": {
              "asset": "The incentivized asset",
              "reward": "The reward token of the incentivized asset"
            },
            "returns": {
              "_0": "The old index of the asset distribution",
              "_1": "The new index of the asset distribution*"
            }
          },
          "getClaimer(address)": {
            "details": "Used to verify permission when claimRewardsOnBehalf is called      Returns the zero address if no claimer has been set",
            "params": {
              "user": "The address of the user whose authorized claimer is being queried"
            },
            "returns": {
              "_0": "The address authorized to claim on behalf of the user, or address(0) if none"
            }
          },
          "getDistributionEnd(address,address)": {
            "details": "Gets the end date for the distribution",
            "params": {
              "asset": "The incentivized asset",
              "reward": "The reward token of the incentivized asset"
            },
            "returns": {
              "_0": "The timestamp with the end of the distribution, in unix time format*"
            }
          },
          "getEmissionManager()": {
            "details": "Returns the address of the emission manager. Deprecated: This getter is maintained for compatibility purposes. Use the `EMISSION_MANAGER()` function instead.",
            "returns": {
              "_0": "The address of the EmissionManager"
            }
          },
          "getRewardsByAsset(address)": {
            "details": "Returns the list of available reward token addresses of an incentivized asset",
            "params": {
              "asset": "The incentivized asset"
            },
            "returns": {
              "_0": "List of rewards addresses of the input asset*"
            }
          },
          "getRewardsData(address,address)": {
            "details": "Returns the configuration of the distribution reward for a certain asset",
            "params": {
              "asset": "The incentivized asset",
              "reward": "The reward token of the incentivized asset"
            },
            "returns": {
              "_0": "The index of the asset distribution",
              "_1": "The emission per second of the reward distribution",
              "_2": "The timestamp of the last update of the index",
              "_3": "The timestamp of the distribution end*"
            }
          },
          "getRewardsList()": {
            "details": "Returns the list of available reward addresses",
            "returns": {
              "_0": "List of rewards supported in this contract*"
            }
          },
          "getTransferStrategy(address)": {
            "details": "Each reward token can have its own dedicated transfer strategy implementation      The returned address implements the IDustTransferStrategy interface",
            "params": {
              "reward": "The address of the reward token"
            },
            "returns": {
              "_0": "The address of the transfer strategy contract for the specified reward token"
            }
          },
          "getUserAccruedRewards(address,address)": {
            "details": "Returns the accrued rewards balance of a user, not including virtually accrued rewards since last distribution.",
            "params": {
              "reward": "The address of the reward token",
              "user": "The address of the user"
            },
            "returns": {
              "_0": "Unclaimed rewards, not including new distributions*"
            }
          },
          "getUserAssetIndex(address,address,address)": {
            "details": "Returns the index of a user on a reward distribution",
            "params": {
              "asset": "The incentivized asset",
              "reward": "The reward token of the incentivized asset",
              "user": "Address of the user"
            },
            "returns": {
              "_0": "The current user asset index, not including new distributions*"
            }
          },
          "getUserRewards(address[],address,address)": {
            "details": "Returns a single rewards balance of a user, including virtually accrued and unrealized claimable rewards.",
            "params": {
              "assets": "List of incentivized assets to check eligible distributions",
              "reward": "The address of the reward token",
              "user": "The address of the user"
            },
            "returns": {
              "_0": "The rewards amount*"
            }
          },
          "handleAction(address,uint256,uint256)": {
            "details": "Called by incentivized assets as a hook during transfers or other balance-changing operations      Records snapshots of user and global state to ensure accurate reward calculation      Must be called by the incentivized asset contract before making any changes to balances",
            "params": {
              "totalSupply": "The total supply of the asset before the balance change",
              "user": "The address of the user whose balance is changing",
              "userBalance": "The user's balance before the change is applied"
            }
          },
          "initialize(address)": {
            "details": "It expects an address as argument since its initialized via PoolAddressesProvider._updateImpl()"
          },
          "setClaimer(address,address)": {
            "details": "Establishes a delegation relationship for reward claiming      This is useful for integrating with other protocols or allowing      trusted services to manage reward claims for users      Only callable by users for their own accounts or by admin",
            "params": {
              "claimer": "The address being authorized to claim on behalf of the user",
              "user": "The address of the user granting claim permission"
            }
          },
          "setDistributionEnd(address,address,uint32)": {
            "details": "Sets the end date for the distribution",
            "params": {
              "asset": "The asset to incentivize",
              "newDistributionEnd": "The end date of the incentivization, in unix time format*",
              "reward": "The reward token that incentives the asset"
            }
          },
          "setEmissionPerSecond(address,address[],uint88[])": {
            "details": "Sets the emission per second of a set of reward distributions",
            "params": {
              "asset": "The asset is being incentivized",
              "newEmissionsPerSecond": "List of new reward emissions per second",
              "rewards": "List of reward addresses are being distributed"
            }
          },
          "setTransferStrategy(address,address)": {
            "details": "Each reward token can have its own unique transfer logic      For veNFT integration, typically set to a DustLockTransferStrategy      which handles locking tokens into veNFTs during claiming      Only callable by contract admin",
            "params": {
              "reward": "The address of the reward token to configure",
              "transferStrategy": "The implementation of IDustTransferStrategy that will handle reward transfers"
            }
          }
        },
        "stateVariables": {
          "_authorizedClaimers": {
            "details": "Mapping of users to their authorized claimers for reward delegation.      Useful for contracts holding rewarded tokens without native claiming logic"
          },
          "_transferStrategy": {
            "details": "Mapping of reward tokens to their corresponding transfer strategy contracts.      Transfer strategies abstract reward source logic and transfer mechanisms"
          }
        },
        "title": "DustRewardsController",
        "version": 1
      },
      "userdoc": {
        "errors": {
          "ClaimerUnauthorized()": [
            {
              "notice": "Error thrown when a user is not authorized to claim rewards on behalf of another user"
            }
          ],
          "InvalidRewardAddress()": [
            {
              "notice": "Error thrown when a reward token address is invalid (zero)"
            }
          ],
          "InvalidToAddress()": [
            {
              "notice": "Used when a to address is invalid."
            }
          ],
          "InvalidUserAddress()": [
            {
              "notice": "Error thrown when the user address is invalid"
            }
          ],
          "OnlyEmissionManagerOrSelf()": [
            {
              "notice": "Error thrown when the caller is not the emission manager or self"
            }
          ],
          "StrategyNotContract()": [
            {
              "notice": "Error thrown when the strategy is not a contract"
            }
          ],
          "StrategyZeroAddress()": [
            {
              "notice": "Error thrown when the strategy address is zero"
            }
          ],
          "TransferError()": [
            {
              "notice": "Error thrown when a transfer error occurs"
            }
          ]
        },
        "events": {
          "ClaimerSet(address,address)": {
            "notice": "Emitted when a new address is whitelisted as claimer of rewards on behalf of a user"
          },
          "RewardsClaimed(address,address,address,address,uint256)": {
            "notice": "Emitted when rewards are claimed"
          },
          "TransferStrategyInstalled(address,address)": {
            "notice": "Emitted when a transfer strategy is installed for the reward distribution"
          }
        },
        "kind": "user",
        "methods": {
          "REVISION()": {
            "notice": "Implementation revision number for proxy upgrades bookkeeping"
          },
          "claimAllRewards(address[],address,uint256,uint256)": {
            "notice": "Claims all available rewards across all reward tokens for a user"
          },
          "claimAllRewardsOnBehalf(address[],address,address,uint256,uint256)": {
            "notice": "Claims all available rewards across all reward tokens for a user on behalf of someone else"
          },
          "claimAllRewardsToSelf(address[],uint256,uint256)": {
            "notice": "Claims all rewards for msg.sender across all configured reward tokens"
          },
          "claimRewards(address[],uint256,address,address,uint256,uint256)": {
            "notice": "Claims specified amount of rewards for a user across multiple assets"
          },
          "claimRewardsOnBehalf(address[],uint256,address,address,address,uint256,uint256)": {
            "notice": "Claims rewards on behalf of another user (requires authorization)"
          },
          "claimRewardsToSelf(address[],uint256,address,uint256,uint256)": {
            "notice": "Claims rewards for the caller (msg.sender) across multiple assets"
          },
          "configureAssets((uint88,uint256,uint32,address,address,address,address)[])": {
            "notice": "Configures incentivized assets with emission schedules and reward rates"
          },
          "constructor": {
            "notice": "Constructs the rewards controller"
          },
          "getClaimer(address)": {
            "notice": "Returns the address authorized to claim rewards on behalf of a specific user"
          },
          "getTransferStrategy(address)": {
            "notice": "Returns the transfer strategy implementation for a specific reward token"
          },
          "handleAction(address,uint256,uint256)": {
            "notice": "Updates reward accrual when a user's balance or asset state changes"
          },
          "initialize(address)": {
            "notice": "Initialize for RewardsController (no-op)"
          },
          "setClaimer(address,address)": {
            "notice": "Authorizes an address to claim rewards on behalf of another user"
          },
          "setTransferStrategy(address,address)": {
            "notice": "Sets the transfer strategy implementation for a specific reward token"
          }
        },
        "notice": "Modified Aave's RewardsController contract to pass lockTime and         tokenId to the `IDustTransferStrategy` and remove rewards oracles.",
        "version": 1
      }
    },
    "settings": {
      "compilationTarget": {
        "src/emissions/DustRewardsController.sol": "DustRewardsController"
      },
      "evmVersion": "paris",
      "libraries": {},
      "metadata": {
        "bytecodeHash": "none",
        "useLiteralContent": true
      },
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "remappings": []
    },
    "sources": {
      "@aave-v3-periphery/contracts/misc/interfaces/IEACAggregatorProxy.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\ninterface IEACAggregatorProxy {\n  function decimals() external view returns (uint8);\n\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\n}\n",
        "keccak256": "0x75bb34641419925730f87eeb122521b34cfd953b800212c362770ed1c7c5d719",
        "license": "AGPL-3.0"
      },
      "@aave-v3-periphery/contracts/rewards/RewardsDistributor.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {IScaledBalanceToken} from '@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol';\nimport {IERC20Detailed} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IRewardsDistributor} from './interfaces/IRewardsDistributor.sol';\nimport {RewardsDataTypes} from './libraries/RewardsDataTypes.sol';\n\n/**\n * @title RewardsDistributor\n * @notice Accounting contract to manage multiple staking distributions with multiple rewards\n * @author Aave\n **/\nabstract contract RewardsDistributor is IRewardsDistributor {\n  using SafeCast for uint256;\n\n  // Manager of incentives\n  address public immutable EMISSION_MANAGER;\n  // Deprecated: This storage slot is kept for backwards compatibility purposes.\n  address internal _emissionManager;\n\n  // Map of rewarded asset addresses and their data (assetAddress => assetData)\n  mapping(address => RewardsDataTypes.AssetData) internal _assets;\n\n  // Map of reward assets (rewardAddress => enabled)\n  mapping(address => bool) internal _isRewardEnabled;\n\n  // Rewards list\n  address[] internal _rewardsList;\n\n  // Assets list\n  address[] internal _assetsList;\n\n  modifier onlyEmissionManager() {\n    require(msg.sender == EMISSION_MANAGER, 'ONLY_EMISSION_MANAGER');\n    _;\n  }\n\n  constructor(address emissionManager) {\n    EMISSION_MANAGER = emissionManager;\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getRewardsData(\n    address asset,\n    address reward\n  ) public view override returns (uint256, uint256, uint256, uint256) {\n    return (\n      _assets[asset].rewards[reward].index,\n      _assets[asset].rewards[reward].emissionPerSecond,\n      _assets[asset].rewards[reward].lastUpdateTimestamp,\n      _assets[asset].rewards[reward].distributionEnd\n    );\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getAssetIndex(\n    address asset,\n    address reward\n  ) external view override returns (uint256, uint256) {\n    RewardsDataTypes.RewardData storage rewardData = _assets[asset].rewards[reward];\n    return\n      _getAssetIndex(\n        rewardData,\n        IScaledBalanceToken(asset).scaledTotalSupply(),\n        10 ** _assets[asset].decimals\n      );\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getDistributionEnd(\n    address asset,\n    address reward\n  ) external view override returns (uint256) {\n    return _assets[asset].rewards[reward].distributionEnd;\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getRewardsByAsset(address asset) external view override returns (address[] memory) {\n    uint128 rewardsCount = _assets[asset].availableRewardsCount;\n    address[] memory availableRewards = new address[](rewardsCount);\n\n    for (uint128 i = 0; i < rewardsCount; i++) {\n      availableRewards[i] = _assets[asset].availableRewards[i];\n    }\n    return availableRewards;\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getRewardsList() external view override returns (address[] memory) {\n    return _rewardsList;\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getUserAssetIndex(\n    address user,\n    address asset,\n    address reward\n  ) public view override returns (uint256) {\n    return _assets[asset].rewards[reward].usersData[user].index;\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getUserAccruedRewards(\n    address user,\n    address reward\n  ) external view override returns (uint256) {\n    uint256 totalAccrued;\n    for (uint256 i = 0; i < _assetsList.length; i++) {\n      totalAccrued += _assets[_assetsList[i]].rewards[reward].usersData[user].accrued;\n    }\n\n    return totalAccrued;\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getUserRewards(\n    address[] calldata assets,\n    address user,\n    address reward\n  ) external view override returns (uint256) {\n    return _getUserReward(user, reward, _getUserAssetBalances(assets, user));\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getAllUserRewards(\n    address[] calldata assets,\n    address user\n  )\n    external\n    view\n    override\n    returns (address[] memory rewardsList, uint256[] memory unclaimedAmounts)\n  {\n    RewardsDataTypes.UserAssetBalance[] memory userAssetBalances = _getUserAssetBalances(\n      assets,\n      user\n    );\n    rewardsList = new address[](_rewardsList.length);\n    unclaimedAmounts = new uint256[](rewardsList.length);\n\n    // Add unrealized rewards from user to unclaimedRewards\n    for (uint256 i = 0; i < userAssetBalances.length; i++) {\n      for (uint256 r = 0; r < rewardsList.length; r++) {\n        rewardsList[r] = _rewardsList[r];\n        unclaimedAmounts[r] += _assets[userAssetBalances[i].asset]\n          .rewards[rewardsList[r]]\n          .usersData[user]\n          .accrued;\n\n        if (userAssetBalances[i].userBalance == 0) {\n          continue;\n        }\n        unclaimedAmounts[r] += _getPendingRewards(user, rewardsList[r], userAssetBalances[i]);\n      }\n    }\n    return (rewardsList, unclaimedAmounts);\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function setDistributionEnd(\n    address asset,\n    address reward,\n    uint32 newDistributionEnd\n  ) external override onlyEmissionManager {\n    uint256 oldDistributionEnd = _assets[asset].rewards[reward].distributionEnd;\n    _assets[asset].rewards[reward].distributionEnd = newDistributionEnd;\n\n    emit AssetConfigUpdated(\n      asset,\n      reward,\n      _assets[asset].rewards[reward].emissionPerSecond,\n      _assets[asset].rewards[reward].emissionPerSecond,\n      oldDistributionEnd,\n      newDistributionEnd,\n      _assets[asset].rewards[reward].index\n    );\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function setEmissionPerSecond(\n    address asset,\n    address[] calldata rewards,\n    uint88[] calldata newEmissionsPerSecond\n  ) external override onlyEmissionManager {\n    require(rewards.length == newEmissionsPerSecond.length, 'INVALID_INPUT');\n    for (uint256 i = 0; i < rewards.length; i++) {\n      RewardsDataTypes.AssetData storage assetConfig = _assets[asset];\n      RewardsDataTypes.RewardData storage rewardConfig = _assets[asset].rewards[rewards[i]];\n      uint256 decimals = assetConfig.decimals;\n      require(\n        decimals != 0 && rewardConfig.lastUpdateTimestamp != 0,\n        'DISTRIBUTION_DOES_NOT_EXIST'\n      );\n\n      (uint256 newIndex, ) = _updateRewardData(\n        rewardConfig,\n        IScaledBalanceToken(asset).scaledTotalSupply(),\n        10 ** decimals\n      );\n\n      uint256 oldEmissionPerSecond = rewardConfig.emissionPerSecond;\n      rewardConfig.emissionPerSecond = newEmissionsPerSecond[i];\n\n      emit AssetConfigUpdated(\n        asset,\n        rewards[i],\n        oldEmissionPerSecond,\n        newEmissionsPerSecond[i],\n        rewardConfig.distributionEnd,\n        rewardConfig.distributionEnd,\n        newIndex\n      );\n    }\n  }\n\n  /**\n   * @dev Configure the _assets for a specific emission\n   * @param rewardsInput The array of each asset configuration\n   **/\n  function _configureAssets(RewardsDataTypes.RewardsConfigInput[] memory rewardsInput) internal {\n    for (uint256 i = 0; i < rewardsInput.length; i++) {\n      if (_assets[rewardsInput[i].asset].decimals == 0) {\n        //never initialized before, adding to the list of assets\n        _assetsList.push(rewardsInput[i].asset);\n      }\n\n      uint256 decimals = _assets[rewardsInput[i].asset].decimals = IERC20Detailed(\n        rewardsInput[i].asset\n      ).decimals();\n\n      RewardsDataTypes.RewardData storage rewardConfig = _assets[rewardsInput[i].asset].rewards[\n        rewardsInput[i].reward\n      ];\n\n      // Add reward address to asset available rewards if latestUpdateTimestamp is zero\n      if (rewardConfig.lastUpdateTimestamp == 0) {\n        _assets[rewardsInput[i].asset].availableRewards[\n          _assets[rewardsInput[i].asset].availableRewardsCount\n        ] = rewardsInput[i].reward;\n        _assets[rewardsInput[i].asset].availableRewardsCount++;\n      }\n\n      // Add reward address to global rewards list if still not enabled\n      if (_isRewardEnabled[rewardsInput[i].reward] == false) {\n        _isRewardEnabled[rewardsInput[i].reward] = true;\n        _rewardsList.push(rewardsInput[i].reward);\n      }\n\n      // Due emissions is still zero, updates only latestUpdateTimestamp\n      (uint256 newIndex, ) = _updateRewardData(\n        rewardConfig,\n        rewardsInput[i].totalSupply,\n        10 ** decimals\n      );\n\n      // Configure emission and distribution end of the reward per asset\n      uint88 oldEmissionsPerSecond = rewardConfig.emissionPerSecond;\n      uint32 oldDistributionEnd = rewardConfig.distributionEnd;\n      rewardConfig.emissionPerSecond = rewardsInput[i].emissionPerSecond;\n      rewardConfig.distributionEnd = rewardsInput[i].distributionEnd;\n\n      emit AssetConfigUpdated(\n        rewardsInput[i].asset,\n        rewardsInput[i].reward,\n        oldEmissionsPerSecond,\n        rewardsInput[i].emissionPerSecond,\n        oldDistributionEnd,\n        rewardsInput[i].distributionEnd,\n        newIndex\n      );\n    }\n  }\n\n  /**\n   * @dev Updates the state of the distribution for the specified reward\n   * @param rewardData Storage pointer to the distribution reward config\n   * @param totalSupply Current total of underlying assets for this distribution\n   * @param assetUnit One unit of asset (10**decimals)\n   * @return The new distribution index\n   * @return True if the index was updated, false otherwise\n   **/\n  function _updateRewardData(\n    RewardsDataTypes.RewardData storage rewardData,\n    uint256 totalSupply,\n    uint256 assetUnit\n  ) internal returns (uint256, bool) {\n    (uint256 oldIndex, uint256 newIndex) = _getAssetIndex(rewardData, totalSupply, assetUnit);\n    bool indexUpdated;\n    if (newIndex != oldIndex) {\n      require(newIndex <= type(uint104).max, 'INDEX_OVERFLOW');\n      indexUpdated = true;\n\n      //optimization: storing one after another saves one SSTORE\n      rewardData.index = uint104(newIndex);\n      rewardData.lastUpdateTimestamp = block.timestamp.toUint32();\n    } else {\n      rewardData.lastUpdateTimestamp = block.timestamp.toUint32();\n    }\n\n    return (newIndex, indexUpdated);\n  }\n\n  /**\n   * @dev Updates the state of the distribution for the specific user\n   * @param rewardData Storage pointer to the distribution reward config\n   * @param user The address of the user\n   * @param userBalance The user balance of the asset\n   * @param newAssetIndex The new index of the asset distribution\n   * @param assetUnit One unit of asset (10**decimals)\n   * @return The rewards accrued since the last update\n   **/\n  function _updateUserData(\n    RewardsDataTypes.RewardData storage rewardData,\n    address user,\n    uint256 userBalance,\n    uint256 newAssetIndex,\n    uint256 assetUnit\n  ) internal returns (uint256, bool) {\n    uint256 userIndex = rewardData.usersData[user].index;\n    uint256 rewardsAccrued;\n    bool dataUpdated;\n    if ((dataUpdated = userIndex != newAssetIndex)) {\n      // already checked for overflow in _updateRewardData\n      rewardData.usersData[user].index = uint104(newAssetIndex);\n      if (userBalance != 0) {\n        rewardsAccrued = _getRewards(userBalance, newAssetIndex, userIndex, assetUnit);\n\n        rewardData.usersData[user].accrued += rewardsAccrued.toUint128();\n      }\n    }\n    return (rewardsAccrued, dataUpdated);\n  }\n\n  /**\n   * @dev Iterates and accrues all the rewards for asset of the specific user\n   * @param asset The address of the reference asset of the distribution\n   * @param user The user address\n   * @param userBalance The current user asset balance\n   * @param totalSupply Total supply of the asset\n   **/\n  function _updateData(\n    address asset,\n    address user,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) internal {\n    uint256 assetUnit;\n    uint256 numAvailableRewards = _assets[asset].availableRewardsCount;\n    unchecked {\n      assetUnit = 10 ** _assets[asset].decimals;\n    }\n\n    if (numAvailableRewards == 0) {\n      return;\n    }\n    unchecked {\n      for (uint128 r = 0; r < numAvailableRewards; r++) {\n        address reward = _assets[asset].availableRewards[r];\n        RewardsDataTypes.RewardData storage rewardData = _assets[asset].rewards[reward];\n\n        (uint256 newAssetIndex, bool rewardDataUpdated) = _updateRewardData(\n          rewardData,\n          totalSupply,\n          assetUnit\n        );\n\n        (uint256 rewardsAccrued, bool userDataUpdated) = _updateUserData(\n          rewardData,\n          user,\n          userBalance,\n          newAssetIndex,\n          assetUnit\n        );\n\n        if (rewardDataUpdated || userDataUpdated) {\n          emit Accrued(asset, reward, user, newAssetIndex, newAssetIndex, rewardsAccrued);\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Accrues all the rewards of the assets specified in the userAssetBalances list\n   * @param user The address of the user\n   * @param userAssetBalances List of structs with the user balance and total supply of a set of assets\n   **/\n  function _updateDataMultiple(\n    address user,\n    RewardsDataTypes.UserAssetBalance[] memory userAssetBalances\n  ) internal {\n    for (uint256 i = 0; i < userAssetBalances.length; i++) {\n      _updateData(\n        userAssetBalances[i].asset,\n        user,\n        userAssetBalances[i].userBalance,\n        userAssetBalances[i].totalSupply\n      );\n    }\n  }\n\n  /**\n   * @dev Return the accrued unclaimed amount of a reward from a user over a list of distribution\n   * @param user The address of the user\n   * @param reward The address of the reward token\n   * @param userAssetBalances List of structs with the user balance and total supply of a set of assets\n   * @return unclaimedRewards The accrued rewards for the user until the moment\n   **/\n  function _getUserReward(\n    address user,\n    address reward,\n    RewardsDataTypes.UserAssetBalance[] memory userAssetBalances\n  ) internal view returns (uint256 unclaimedRewards) {\n    // Add unrealized rewards\n    for (uint256 i = 0; i < userAssetBalances.length; i++) {\n      if (userAssetBalances[i].userBalance == 0) {\n        unclaimedRewards += _assets[userAssetBalances[i].asset]\n          .rewards[reward]\n          .usersData[user]\n          .accrued;\n      } else {\n        unclaimedRewards +=\n          _getPendingRewards(user, reward, userAssetBalances[i]) +\n          _assets[userAssetBalances[i].asset].rewards[reward].usersData[user].accrued;\n      }\n    }\n\n    return unclaimedRewards;\n  }\n\n  /**\n   * @dev Calculates the pending (not yet accrued) rewards since the last user action\n   * @param user The address of the user\n   * @param reward The address of the reward token\n   * @param userAssetBalance struct with the user balance and total supply of the incentivized asset\n   * @return The pending rewards for the user since the last user action\n   **/\n  function _getPendingRewards(\n    address user,\n    address reward,\n    RewardsDataTypes.UserAssetBalance memory userAssetBalance\n  ) internal view returns (uint256) {\n    RewardsDataTypes.RewardData storage rewardData = _assets[userAssetBalance.asset].rewards[\n      reward\n    ];\n    uint256 assetUnit = 10 ** _assets[userAssetBalance.asset].decimals;\n    (, uint256 nextIndex) = _getAssetIndex(rewardData, userAssetBalance.totalSupply, assetUnit);\n\n    return\n      _getRewards(\n        userAssetBalance.userBalance,\n        nextIndex,\n        rewardData.usersData[user].index,\n        assetUnit\n      );\n  }\n\n  /**\n   * @dev Internal function for the calculation of user's rewards on a distribution\n   * @param userBalance Balance of the user asset on a distribution\n   * @param reserveIndex Current index of the distribution\n   * @param userIndex Index stored for the user, representation his staking moment\n   * @param assetUnit One unit of asset (10**decimals)\n   * @return The rewards\n   **/\n  function _getRewards(\n    uint256 userBalance,\n    uint256 reserveIndex,\n    uint256 userIndex,\n    uint256 assetUnit\n  ) internal pure returns (uint256) {\n    uint256 result = userBalance * (reserveIndex - userIndex);\n    assembly {\n      result := div(result, assetUnit)\n    }\n    return result;\n  }\n\n  /**\n   * @dev Calculates the next value of an specific distribution index, with validations\n   * @param rewardData Storage pointer to the distribution reward config\n   * @param totalSupply of the asset being rewarded\n   * @param assetUnit One unit of asset (10**decimals)\n   * @return The new index.\n   **/\n  function _getAssetIndex(\n    RewardsDataTypes.RewardData storage rewardData,\n    uint256 totalSupply,\n    uint256 assetUnit\n  ) internal view returns (uint256, uint256) {\n    uint256 oldIndex = rewardData.index;\n    uint256 distributionEnd = rewardData.distributionEnd;\n    uint256 emissionPerSecond = rewardData.emissionPerSecond;\n    uint256 lastUpdateTimestamp = rewardData.lastUpdateTimestamp;\n\n    if (\n      emissionPerSecond == 0 ||\n      totalSupply == 0 ||\n      lastUpdateTimestamp == block.timestamp ||\n      lastUpdateTimestamp >= distributionEnd\n    ) {\n      return (oldIndex, oldIndex);\n    }\n\n    uint256 currentTimestamp = block.timestamp > distributionEnd\n      ? distributionEnd\n      : block.timestamp;\n    uint256 timeDelta = currentTimestamp - lastUpdateTimestamp;\n    uint256 firstTerm = emissionPerSecond * timeDelta * assetUnit;\n    assembly {\n      firstTerm := div(firstTerm, totalSupply)\n    }\n    return (oldIndex, (firstTerm + oldIndex));\n  }\n\n  /**\n   * @dev Get user balances and total supply of all the assets specified by the assets parameter\n   * @param assets List of assets to retrieve user balance and total supply\n   * @param user Address of the user\n   * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n   */\n  function _getUserAssetBalances(\n    address[] calldata assets,\n    address user\n  ) internal view virtual returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances);\n\n  /// @inheritdoc IRewardsDistributor\n  function getAssetDecimals(address asset) external view returns (uint8) {\n    return _assets[asset].decimals;\n  }\n\n  /// @inheritdoc IRewardsDistributor\n  function getEmissionManager() external view returns (address) {\n    return EMISSION_MANAGER;\n  }\n}\n",
        "keccak256": "0x2ebbe04658923f2023c5ace6a75ce38090e41be420648e71ac51f2f4e5da2531",
        "license": "BUSL-1.1"
      },
      "@aave-v3-periphery/contracts/rewards/interfaces/IRewardsDistributor.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\n/**\n * @title IRewardsDistributor\n * @author Aave\n * @notice Defines the basic interface for a Rewards Distributor.\n */\ninterface IRewardsDistributor {\n  /**\n   * @dev Emitted when the configuration of the rewards of an asset is updated.\n   * @param asset The address of the incentivized asset\n   * @param reward The address of the reward token\n   * @param oldEmission The old emissions per second value of the reward distribution\n   * @param newEmission The new emissions per second value of the reward distribution\n   * @param oldDistributionEnd The old end timestamp of the reward distribution\n   * @param newDistributionEnd The new end timestamp of the reward distribution\n   * @param assetIndex The index of the asset distribution\n   */\n  event AssetConfigUpdated(\n    address indexed asset,\n    address indexed reward,\n    uint256 oldEmission,\n    uint256 newEmission,\n    uint256 oldDistributionEnd,\n    uint256 newDistributionEnd,\n    uint256 assetIndex\n  );\n\n  /**\n   * @dev Emitted when rewards of an asset are accrued on behalf of a user.\n   * @param asset The address of the incentivized asset\n   * @param reward The address of the reward token\n   * @param user The address of the user that rewards are accrued on behalf of\n   * @param assetIndex The index of the asset distribution\n   * @param userIndex The index of the asset distribution on behalf of the user\n   * @param rewardsAccrued The amount of rewards accrued\n   */\n  event Accrued(\n    address indexed asset,\n    address indexed reward,\n    address indexed user,\n    uint256 assetIndex,\n    uint256 userIndex,\n    uint256 rewardsAccrued\n  );\n\n  /**\n   * @dev Sets the end date for the distribution\n   * @param asset The asset to incentivize\n   * @param reward The reward token that incentives the asset\n   * @param newDistributionEnd The end date of the incentivization, in unix time format\n   **/\n  function setDistributionEnd(address asset, address reward, uint32 newDistributionEnd) external;\n\n  /**\n   * @dev Sets the emission per second of a set of reward distributions\n   * @param asset The asset is being incentivized\n   * @param rewards List of reward addresses are being distributed\n   * @param newEmissionsPerSecond List of new reward emissions per second\n   */\n  function setEmissionPerSecond(\n    address asset,\n    address[] calldata rewards,\n    uint88[] calldata newEmissionsPerSecond\n  ) external;\n\n  /**\n   * @dev Gets the end date for the distribution\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The timestamp with the end of the distribution, in unix time format\n   **/\n  function getDistributionEnd(address asset, address reward) external view returns (uint256);\n\n  /**\n   * @dev Returns the index of a user on a reward distribution\n   * @param user Address of the user\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The current user asset index, not including new distributions\n   **/\n  function getUserAssetIndex(\n    address user,\n    address asset,\n    address reward\n  ) external view returns (uint256);\n\n  /**\n   * @dev Returns the configuration of the distribution reward for a certain asset\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The index of the asset distribution\n   * @return The emission per second of the reward distribution\n   * @return The timestamp of the last update of the index\n   * @return The timestamp of the distribution end\n   **/\n  function getRewardsData(\n    address asset,\n    address reward\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  /**\n   * @dev Calculates the next value of an specific distribution index, with validations.\n   * @param asset The incentivized asset\n   * @param reward The reward token of the incentivized asset\n   * @return The old index of the asset distribution\n   * @return The new index of the asset distribution\n   **/\n  function getAssetIndex(address asset, address reward) external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the list of available reward token addresses of an incentivized asset\n   * @param asset The incentivized asset\n   * @return List of rewards addresses of the input asset\n   **/\n  function getRewardsByAsset(address asset) external view returns (address[] memory);\n\n  /**\n   * @dev Returns the list of available reward addresses\n   * @return List of rewards supported in this contract\n   **/\n  function getRewardsList() external view returns (address[] memory);\n\n  /**\n   * @dev Returns the accrued rewards balance of a user, not including virtually accrued rewards since last distribution.\n   * @param user The address of the user\n   * @param reward The address of the reward token\n   * @return Unclaimed rewards, not including new distributions\n   **/\n  function getUserAccruedRewards(address user, address reward) external view returns (uint256);\n\n  /**\n   * @dev Returns a single rewards balance of a user, including virtually accrued and unrealized claimable rewards.\n   * @param assets List of incentivized assets to check eligible distributions\n   * @param user The address of the user\n   * @param reward The address of the reward token\n   * @return The rewards amount\n   **/\n  function getUserRewards(\n    address[] calldata assets,\n    address user,\n    address reward\n  ) external view returns (uint256);\n\n  /**\n   * @dev Returns a list all rewards of a user, including already accrued and unrealized claimable rewards\n   * @param assets List of incentivized assets to check eligible distributions\n   * @param user The address of the user\n   * @return The list of reward addresses\n   * @return The list of unclaimed amount of rewards\n   **/\n  function getAllUserRewards(\n    address[] calldata assets,\n    address user\n  ) external view returns (address[] memory, uint256[] memory);\n\n  /**\n   * @dev Returns the decimals of an asset to calculate the distribution delta\n   * @param asset The address to retrieve decimals\n   * @return The decimals of an underlying asset\n   */\n  function getAssetDecimals(address asset) external view returns (uint8);\n\n  /**\n   * @dev Returns the address of the emission manager\n   * @return The address of the EmissionManager\n   */\n  function EMISSION_MANAGER() external view returns (address);\n\n  /**\n   * @dev Returns the address of the emission manager.\n   * Deprecated: This getter is maintained for compatibility purposes. Use the `EMISSION_MANAGER()` function instead.\n   * @return The address of the EmissionManager\n   */\n  function getEmissionManager() external view returns (address);\n}\n",
        "keccak256": "0xd393efd85f696114f9ab69e6bfdcbf3a2bcf16ef5002516d56a0f0359e3d9bba",
        "license": "AGPL-3.0"
      },
      "@aave-v3-periphery/contracts/rewards/interfaces/ITransferStrategyBase.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\ninterface ITransferStrategyBase {\n  event EmergencyWithdrawal(\n    address indexed caller,\n    address indexed token,\n    address indexed to,\n    uint256 amount\n  );\n\n  /**\n   * @dev Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n   * @param to Account to transfer rewards\n   * @param reward Address of the reward token\n   * @param amount Amount to transfer to the \"to\" address parameter\n   * @return Returns true bool if transfer logic succeeds\n   */\n  function performTransfer(address to, address reward, uint256 amount) external returns (bool);\n\n  /**\n   * @return Returns the address of the Incentives Controller\n   */\n  function getIncentivesController() external view returns (address);\n\n  /**\n   * @return Returns the address of the Rewards admin\n   */\n  function getRewardsAdmin() external view returns (address);\n\n  /**\n   * @dev Perform an emergency token withdrawal only callable by the Rewards admin\n   * @param token Address of the token to withdraw funds from this contract\n   * @param to Address of the recipient of the withdrawal\n   * @param amount Amount of the withdrawal\n   */\n  function emergencyWithdrawal(address token, address to, uint256 amount) external;\n}\n",
        "keccak256": "0xa52a6dc237879acbed7325787ce58238a3afd626fa2ed827d4e321d2e4ef51ad",
        "license": "AGPL-3.0"
      },
      "@aave-v3-periphery/contracts/rewards/libraries/RewardsDataTypes.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport {ITransferStrategyBase} from '../interfaces/ITransferStrategyBase.sol';\nimport {IEACAggregatorProxy} from '../../misc/interfaces/IEACAggregatorProxy.sol';\n\nlibrary RewardsDataTypes {\n  struct RewardsConfigInput {\n    uint88 emissionPerSecond;\n    uint256 totalSupply;\n    uint32 distributionEnd;\n    address asset;\n    address reward;\n    ITransferStrategyBase transferStrategy;\n    IEACAggregatorProxy rewardOracle;\n  }\n\n  struct UserAssetBalance {\n    address asset;\n    uint256 userBalance;\n    uint256 totalSupply;\n  }\n\n  struct UserData {\n    // Liquidity index of the reward distribution for the user\n    uint104 index;\n    // Amount of accrued rewards for the user since last user index update\n    uint128 accrued;\n  }\n\n  struct RewardData {\n    // Liquidity index of the reward distribution\n    uint104 index;\n    // Amount of reward tokens distributed per second\n    uint88 emissionPerSecond;\n    // Timestamp of the last reward index update\n    uint32 lastUpdateTimestamp;\n    // The end of the distribution of rewards (in seconds)\n    uint32 distributionEnd;\n    // Map of user addresses and their rewards data (userAddress => userData)\n    mapping(address => UserData) usersData;\n  }\n\n  struct AssetData {\n    // Map of reward token addresses and their data (rewardTokenAddress => rewardData)\n    mapping(address => RewardData) rewards;\n    // List of reward token addresses for the asset\n    mapping(uint128 => address) availableRewards;\n    // Count of reward tokens for the asset\n    uint128 availableRewardsCount;\n    // Number of decimals of the asset\n    uint8 decimals;\n  }\n}\n",
        "keccak256": "0xaaa314b4e9f40878f4fd20e99075fe60309c9e223a5b8c244aaaeb7229d8c318",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n",
        "keccak256": "0xf57d62241e553696a1324d225663ba2e1a51db0a51ca236d0c1b009d89b6284c",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from './IERC20.sol';\n\ninterface IERC20Detailed is IERC20 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n}\n",
        "keccak256": "0x9365cd885dc1ed7aed1364ae4dedf8e4660100cba0437061013f64c5002b385a",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, 'SafeCast: value must be positive');\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt128(int256 value) internal pure returns (int128) {\n    require(\n      value >= type(int128).min && value <= type(int128).max,\n      \"SafeCast: value doesn't fit in 128 bits\"\n    );\n    return int128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt64(int256 value) internal pure returns (int64) {\n    require(\n      value >= type(int64).min && value <= type(int64).max,\n      \"SafeCast: value doesn't fit in 64 bits\"\n    );\n    return int64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt32(int256 value) internal pure returns (int32) {\n    require(\n      value >= type(int32).min && value <= type(int32).max,\n      \"SafeCast: value doesn't fit in 32 bits\"\n    );\n    return int32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt16(int256 value) internal pure returns (int16) {\n    require(\n      value >= type(int16).min && value <= type(int16).max,\n      \"SafeCast: value doesn't fit in 16 bits\"\n    );\n    return int16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   *\n   * _Available since v3.1._\n   */\n  function toInt8(int256 value) internal pure returns (int8) {\n    require(\n      value >= type(int8).min && value <= type(int8).max,\n      \"SafeCast: value doesn't fit in 8 bits\"\n    );\n    return int8(value);\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n    return int256(value);\n  }\n}\n",
        "keccak256": "0x36824ad8ec8a12aa21938a05f971e21d23c7e84ae3b3a19b0643c5ebb873166e",
        "license": "MIT"
      },
      "@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}\n",
        "keccak256": "0x72b3ea433cd3386f369f1643a154bf233ec60c02acd02c32088a97556207d2e4",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title VersionedInitializable\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n * @notice Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * @dev WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\nabstract contract VersionedInitializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  uint256 private lastInitializedRevision = 0;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    uint256 revision = getRevision();\n    require(\n      initializing || isConstructor() || revision > lastInitializedRevision,\n      'Contract instance has already been initialized'\n    );\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      lastInitializedRevision = revision;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /**\n   * @notice Returns the revision number of the contract\n   * @dev Needs to be defined in the inherited class as a constant.\n   * @return The revision number\n   */\n  function getRevision() internal pure virtual returns (uint256);\n\n  /**\n   * @notice Returns true if and only if the function is running in the constructor\n   * @return True if the function is running in the constructor\n   */\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    //solium-disable-next-line\n    assembly {\n      cs := extcodesize(address())\n    }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n",
        "keccak256": "0x311b8f1bd3d015a0c9c37680aceca36f59658284b9a7b2ca185b19afe58c3be0",
        "license": "AGPL-3.0"
      },
      "src/emissions/DustRewardsController.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {RewardsDataTypes} from \"@aave-v3-periphery/contracts/rewards/libraries/RewardsDataTypes.sol\";\nimport {RewardsDistributor} from \"@aave-v3-periphery/contracts/rewards/RewardsDistributor.sol\";\nimport {IScaledBalanceToken} from \"@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol\";\nimport {SafeCast} from \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport {VersionedInitializable} from\n    \"@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol\";\n\nimport {IDustRewardsController} from \"../interfaces/IDustRewardsController.sol\";\nimport {IDustTransferStrategy} from \"../interfaces/IDustTransferStrategy.sol\";\n\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\nimport {CommonLibrary} from \"../libraries/CommonLibrary.sol\";\n\n/**\n * @title DustRewardsController\n * @author Original implementation by Aave\n * @author Extended by Neverland\n * @notice Modified Aave's RewardsController contract to pass lockTime and\n *         tokenId to the `IDustTransferStrategy` and remove rewards oracles.\n */\ncontract DustRewardsController is RewardsDistributor, VersionedInitializable, IDustRewardsController {\n    using SafeCast for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                             CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Implementation revision number for proxy upgrades bookkeeping\n    uint256 public constant REVISION = 1;\n\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Mapping of users to their authorized claimers for reward delegation.\n     *      Useful for contracts holding rewarded tokens without native claiming logic\n     */\n    mapping(address => address) internal _authorizedClaimers;\n\n    /**\n     * @dev Mapping of reward tokens to their corresponding transfer strategy contracts.\n     *      Transfer strategies abstract reward source logic and transfer mechanisms\n     */\n    mapping(address => IDustTransferStrategy) internal _transferStrategy;\n\n    /*//////////////////////////////////////////////////////////////\n                           ACCESS CONTROL\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyAuthorizedClaimers(address claimer, address user) {\n        if (_authorizedClaimers[user] != claimer) revert ClaimerUnauthorized();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructs the rewards controller\n     * @param emissionManager The address of the emission manager (Aave semantics)\n     */\n    constructor(address emissionManager) RewardsDistributor(emissionManager) {}\n\n    /*//////////////////////////////////////////////////////////////\n                           INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initialize for RewardsController (no-op)\n     * @dev It expects an address as argument since its initialized via PoolAddressesProvider._updateImpl()\n     */\n    function initialize(address) external initializer {}\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustRewardsController\n    function getClaimer(address user) external view override returns (address) {\n        return _authorizedClaimers[user];\n    }\n\n    /**\n     * @notice Returns the implementation revision used by Aave's initializer pattern\n     * @dev Returns the revision of the implementation contract\n     * @return uint256, current revision version\n     */\n    function getRevision() internal pure override returns (uint256) {\n        return REVISION;\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function getTransferStrategy(address reward) external view override returns (address) {\n        return address(_transferStrategy[reward]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustRewardsController\n    function configureAssets(RewardsDataTypes.RewardsConfigInput[] calldata config)\n        external\n        override\n        onlyEmissionManager\n    {\n        RewardsDataTypes.RewardsConfigInput[] memory configCopy = config;\n        for (uint256 i = 0; i < config.length; ++i) {\n            // Get the current Scaled Total Supply of AToken or Debt token\n            configCopy[i].totalSupply = IScaledBalanceToken(configCopy[i].asset).scaledTotalSupply();\n\n            // Install TransferStrategy logic at IncentivesController\n            _installTransferStrategy(\n                configCopy[i].reward, IDustTransferStrategy(address(configCopy[i].transferStrategy))\n            );\n        }\n        _configureAssets(configCopy);\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function setTransferStrategy(address reward, IDustTransferStrategy transferStrategy) external onlyEmissionManager {\n        _installTransferStrategy(reward, transferStrategy);\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function setClaimer(address user, address claimer) external override {\n        if (msg.sender != user && msg.sender != EMISSION_MANAGER) revert OnlyEmissionManagerOrSelf();\n\n        _authorizedClaimers[user] = claimer;\n\n        emit ClaimerSet(user, claimer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            REWARDS ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustRewardsController\n    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external override {\n        _updateData(msg.sender, user, userBalance, totalSupply);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           REWARDS CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustRewardsController\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external override returns (uint256) {\n        CommonChecksLibrary.revertIfInvalidToAddress(to);\n\n        return _claimRewards(assets, amount, msg.sender, msg.sender, to, reward, lockTime, tokenId);\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n        CommonChecksLibrary.revertIfInvalidToAddress(to);\n        if (user == address(0)) revert InvalidUserAddress();\n\n        return _claimRewards(assets, amount, msg.sender, user, to, reward, lockTime, tokenId);\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external override returns (uint256) {\n        return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender, reward, lockTime, tokenId);\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function claimAllRewards(address[] calldata assets, address to, uint256 lockTime, uint256 tokenId)\n        external\n        override\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        CommonChecksLibrary.revertIfInvalidToAddress(to);\n\n        return _claimAllRewards(assets, msg.sender, msg.sender, to, lockTime, tokenId);\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to,\n        uint256 lockTime,\n        uint256 tokenId\n    )\n        external\n        override\n        onlyAuthorizedClaimers(msg.sender, user)\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        CommonChecksLibrary.revertIfInvalidToAddress(to);\n        if (user == address(0)) revert InvalidUserAddress();\n\n        return _claimAllRewards(assets, msg.sender, user, to, lockTime, tokenId);\n    }\n\n    /// @inheritdoc IDustRewardsController\n    function claimAllRewardsToSelf(address[] calldata assets, uint256 lockTime, uint256 tokenId)\n        external\n        override\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        return _claimAllRewards(assets, msg.sender, msg.sender, msg.sender, lockTime, tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get user balances and total supply for a list of assets\n     * @dev Get user balances and total supply of all the assets specified by the assets parameter\n     * @param assets List of assets to retrieve user balance and total supply\n     * @param user Address of the user\n     * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n     */\n    function _getUserAssetBalances(address[] calldata assets, address user)\n        internal\n        view\n        override\n        returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances)\n    {\n        userAssetBalances = new RewardsDataTypes.UserAssetBalance[](assets.length);\n        for (uint256 i = 0; i < assets.length; ++i) {\n            userAssetBalances[i].asset = assets[i];\n            (userAssetBalances[i].userBalance, userAssetBalances[i].totalSupply) =\n                IScaledBalanceToken(assets[i]).getScaledUserBalanceAndSupply(user);\n        }\n        return userAssetBalances;\n    }\n\n    /**\n     * @notice Internal helper to claim a single reward type across assets\n     * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param amount Amount of rewards to claim\n     * @param claimer Address of the claimer who claims rewards on behalf of user\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @param reward Address of the reward token\n     * @param lockTime Optional lock time for supported rewards\n     * @param tokenId Optional tokenId for supported rewards\n     * @return Rewards claimed\n     */\n    function _claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address claimer,\n        address user,\n        address to,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) internal returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        uint256 totalRewards;\n\n        _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n        for (uint256 i = 0; i < assets.length; ++i) {\n            address asset = assets[i];\n            totalRewards += _assets[asset].rewards[reward].usersData[user].accrued;\n\n            if (totalRewards <= amount) {\n                _assets[asset].rewards[reward].usersData[user].accrued = 0;\n            } else {\n                uint256 difference = totalRewards - amount;\n                totalRewards -= difference;\n                _assets[asset].rewards[reward].usersData[user].accrued = difference.toUint128();\n                break;\n            }\n        }\n\n        if (totalRewards == 0) {\n            return 0;\n        }\n\n        _transferRewards(to, reward, totalRewards, lockTime, tokenId);\n\n        emit RewardsClaimed(user, reward, to, claimer, totalRewards);\n        return totalRewards;\n    }\n\n    /**\n     * @notice Internal helper to claim all reward types across assets\n     * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param claimer Address of the claimer on behalf of user\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @param lockTime Optional lock time for supported rewards\n     * @param tokenId Optional tokenId for supported rewards\n     * @return rewardsList List of reward addresses\n     * @return claimedAmounts List of claimed amounts, follows \"rewardsList\" items order\n     */\n    function _claimAllRewards(\n        address[] calldata assets,\n        address claimer,\n        address user,\n        address to,\n        uint256 lockTime,\n        uint256 tokenId\n    ) internal returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n        uint256 rewardsListLength = _rewardsList.length;\n        rewardsList = new address[](rewardsListLength);\n        claimedAmounts = new uint256[](rewardsListLength);\n\n        _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n\n        for (uint256 i = 0; i < assets.length; ++i) {\n            address asset = assets[i];\n            for (uint256 j = 0; j < rewardsListLength; ++j) {\n                if (rewardsList[j] == address(0)) {\n                    rewardsList[j] = _rewardsList[j];\n                }\n                uint256 rewardAmount = _assets[asset].rewards[rewardsList[j]].usersData[user].accrued;\n                if (rewardAmount != 0) {\n                    claimedAmounts[j] += rewardAmount;\n                    _assets[asset].rewards[rewardsList[j]].usersData[user].accrued = 0;\n                }\n            }\n        }\n        for (uint256 i = 0; i < rewardsListLength; ++i) {\n            _transferRewards(to, rewardsList[i], claimedAmounts[i], lockTime, tokenId);\n\n            emit RewardsClaimed(user, rewardsList[i], to, claimer, claimedAmounts[i]);\n        }\n        return (rewardsList, claimedAmounts);\n    }\n\n    /**\n     * @notice Internal function to transfer rewards to the recipient using the configured transfer strategy\n     * @dev This function delegates the actual reward transfer to the strategy contract specified for each reward token.\n     *      The transfer strategy may handle specialized behaviors like creating/extending locks\n     * @param to Recipient address to receive the rewards\n     * @param reward Address of the reward token being transferred\n     * @param amount Amount of reward tokens to transfer\n     * @param lockTime Optional lock duration in seconds (for strategies that create/extend locks)\n     * @param tokenId Optional tokenId for strategies that interact with existing veNFTs\n     */\n    function _transferRewards(address to, address reward, uint256 amount, uint256 lockTime, uint256 tokenId) internal {\n        IDustTransferStrategy transferStrategy = _transferStrategy[reward];\n\n        bool success = transferStrategy.performTransfer(to, reward, amount, lockTime, tokenId);\n\n        if (!success) revert TransferError();\n    }\n\n    /**\n     * @notice Installs or updates the transfer strategy for a reward token\n     * @dev Internal function to register the TransferStrategy implementation for a reward token\n     * @param reward The address of the reward token\n     * @param transferStrategy The address of the reward TransferStrategy\n     */\n    function _installTransferStrategy(address reward, IDustTransferStrategy transferStrategy) internal {\n        if (reward == address(0)) revert InvalidRewardAddress();\n        if (address(transferStrategy) == address(0)) revert StrategyZeroAddress();\n        if (!CommonLibrary.isContract(address(transferStrategy))) revert StrategyNotContract();\n\n        _transferStrategy[reward] = transferStrategy;\n\n        emit TransferStrategyInstalled(reward, address(transferStrategy));\n    }\n}\n",
        "keccak256": "0x55465f52fc8886e3b438fe62472c2a65467a5af95b736686bab8fca4870d0dee",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IDustRewardsController.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.30;\n\nimport {IRewardsDistributor} from \"@aave-v3-periphery/contracts/rewards/interfaces/IRewardsDistributor.sol\";\nimport {RewardsDataTypes} from \"@aave-v3-periphery/contracts/rewards/libraries/RewardsDataTypes.sol\";\n\nimport {IDustTransferStrategy} from \"../interfaces/IDustTransferStrategy.sol\";\n\n/**\n * @title IDustRewardsController\n * @author Original implementation by Aave\n * @author Extended by Neverland\n * @notice Defines the interface for the DustRewardsController that manages token rewards distribution\n * @dev Extends Aave's IRewardsDistributor with additional functionality for Neverland's veNFT system\n *      This controller manages the distribution of rewards to veNFT holders with options for\n *      time-locks and specific NFT targeting\n *      Modified from Aave's `IRewardsController` to pass lockTime and tokenId to transfer strategies,\n *      enabling integration with Neverland's veNFT locking ecosystem\n */\ninterface IDustRewardsController is IRewardsDistributor {\n    /// @notice Error thrown when a user is not authorized to claim rewards on behalf of another user\n    error ClaimerUnauthorized();\n\n    /// @notice Error thrown when the user address is invalid\n    error InvalidUserAddress();\n\n    /// @notice Error thrown when the caller is not the emission manager or self\n    error OnlyEmissionManagerOrSelf();\n\n    /// @notice Error thrown when a transfer error occurs\n    error TransferError();\n\n    /// @notice Error thrown when the strategy address is zero\n    error StrategyZeroAddress();\n\n    /// @notice Error thrown when the strategy is not a contract\n    error StrategyNotContract();\n\n    /// @notice Error thrown when a reward token address is invalid (zero)\n    error InvalidRewardAddress();\n\n    /**\n     * @notice Emitted when a new address is whitelisted as claimer of rewards on behalf of a user\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /**\n     * @notice Emitted when rewards are claimed\n     * @param user The address of the user rewards has been claimed on behalf of\n     * @param reward The address of the token reward is claimed\n     * @param to The address of the receiver of the rewards\n     * @param claimer The address of the claimer\n     * @param amount The amount of rewards claimed\n     */\n    event RewardsClaimed(\n        address indexed user, address indexed reward, address indexed to, address claimer, uint256 amount\n    );\n\n    /**\n     * @notice Emitted when a transfer strategy is installed for the reward distribution\n     * @param reward The address of the token reward\n     * @param transferStrategy The address of TransferStrategy contract\n     */\n    event TransferStrategyInstalled(address indexed reward, address indexed transferStrategy);\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the address authorized to claim rewards on behalf of a specific user\n     * @dev Used to verify permission when claimRewardsOnBehalf is called\n     *      Returns the zero address if no claimer has been set\n     * @param user The address of the user whose authorized claimer is being queried\n     * @return The address authorized to claim on behalf of the user, or address(0) if none\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @notice Returns the transfer strategy implementation for a specific reward token\n     * @dev Each reward token can have its own dedicated transfer strategy implementation\n     *      The returned address implements the IDustTransferStrategy interface\n     * @param reward The address of the reward token\n     * @return The address of the transfer strategy contract for the specified reward token\n     */\n    function getTransferStrategy(address reward) external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Authorizes an address to claim rewards on behalf of another user\n     * @dev Establishes a delegation relationship for reward claiming\n     *      This is useful for integrating with other protocols or allowing\n     *      trusted services to manage reward claims for users\n     *      Only callable by users for their own accounts or by admin\n     * @param user The address of the user granting claim permission\n     * @param claimer The address being authorized to claim on behalf of the user\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @notice Sets the transfer strategy implementation for a specific reward token\n     * @dev Each reward token can have its own unique transfer logic\n     *      For veNFT integration, typically set to a DustLockTransferStrategy\n     *      which handles locking tokens into veNFTs during claiming\n     *      Only callable by contract admin\n     * @param reward The address of the reward token to configure\n     * @param transferStrategy The implementation of IDustTransferStrategy that will handle reward transfers\n     */\n    function setTransferStrategy(address reward, IDustTransferStrategy transferStrategy) external;\n\n    /**\n     * @notice Configures incentivized assets with emission schedules and reward rates\n     * @dev Sets up reward distributions for assets with specified emission rates\n     *      Each asset can be configured with its own reward token, distribution schedule, and transfer strategy\n     *      Only callable by the contract admin\n     * @param config Array of configuration inputs with the following fields for each asset:\n     *   - emissionPerSecond: Rate of reward distribution per second (in reward token units)\n     *   - totalSupply: Current total supply of the incentivized asset\n     *   - distributionEnd: Timestamp when reward distribution ends\n     *   - asset: Address of the asset being incentivized\n     *   - reward: Address of the reward token to distribute\n     *   - transferStrategy: Implementation of IDustTransferStrategy for reward transfers\n     *   - rewardOracle: Not used in Neverland implementation, can be set to address(0)\n     */\n    function configureAssets(RewardsDataTypes.RewardsConfigInput[] memory config) external;\n\n    /*//////////////////////////////////////////////////////////////\n                            REWARDS ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates reward accrual when a user's balance or asset state changes\n     * @dev Called by incentivized assets as a hook during transfers or other balance-changing operations\n     *      Records snapshots of user and global state to ensure accurate reward calculation\n     *      Must be called by the incentivized asset contract before making any changes to balances\n     * @param user The address of the user whose balance is changing\n     * @param totalSupply The total supply of the asset before the balance change\n     * @param userBalance The user's balance before the change is applied\n     */\n    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\n\n    /*//////////////////////////////////////////////////////////////\n                           REWARDS CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims specified amount of rewards for a user across multiple assets\n     * @dev Calculates and transfers accumulated rewards to the specified recipient\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param amount The amount of rewards to claim (use type(uint256).max for all available rewards)\n     * @param to The address that will receive the rewards\n     * @param reward The address of the reward token to claim\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return The actual amount of rewards claimed\n     */\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (uint256);\n\n    /**\n     * @notice Claims rewards on behalf of another user (requires authorization)\n     * @dev Allows a whitelisted claimer to claim rewards for another user\n     *      The claimer must be previously authorized via setClaimer function\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param amount The amount of rewards to claim (use type(uint256).max for all available rewards)\n     * @param user The address of the user whose rewards are being claimed\n     * @param to The address that will receive the rewards\n     * @param reward The address of the reward token to claim\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return The actual amount of rewards claimed\n     */\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (uint256);\n\n    /**\n     * @notice Claims rewards for the caller (msg.sender) across multiple assets\n     * @dev Convenience function that claims rewards and sends them to the caller\n     *      Equivalent to calling claimRewards with 'to' set to msg.sender\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param amount The amount of rewards to claim (use type(uint256).max for all available rewards)\n     * @param reward The address of the reward token to claim\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return The actual amount of rewards claimed\n     */\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (uint256);\n\n    /**\n     * @notice Claims all available rewards across all reward tokens for a user\n     * @dev Processes all reward types in a single transaction for efficiency\n     *      Returns two parallel arrays with reward tokens and their claimed amounts\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param to The address that will receive the rewards\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return rewardsList Array of addresses of all claimed reward tokens\n     * @return claimedAmounts Array of claimed amounts, with indices matching the rewardsList array\n     */\n    function claimAllRewards(address[] calldata assets, address to, uint256 lockTime, uint256 tokenId)\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @notice Claims all available rewards across all reward tokens for a user on behalf of someone else\n     * @dev Similar to claimAllRewards but allows a whitelisted claimer to claim on behalf of another user\n     *      The claimer must be previously authorized by the user with setClaimer via \"allowClaimOnBehalf\" function\n     *      When integrated with DustLockTransferStrategy, supports automatic locking of rewards into veNFTs\n     * @param assets Array of asset addresses to check for eligible distributions\n     * @param user The address of the user whose rewards are being claimed\n     * @param to The address that will receive the rewards\n     * @param lockTime Optional lock duration in seconds when claiming as veNFT (0 for no lock)\n     * @param tokenId Optional veNFT ID when adding rewards to an existing position (0 for new position)\n     * @return rewardsList Array of addresses of all claimed reward tokens\n     * @return claimedAmounts Array of claimed amounts, with indices matching the rewardsList array\n     */\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to,\n        uint256 lockTime,\n        uint256 tokenId\n    ) external returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @notice Claims all rewards for msg.sender across all configured reward tokens\n     * @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param lockTime Optional lock time for supported rewards\n     * @param tokenId Optional tokenId for supported rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     */\n    function claimAllRewardsToSelf(address[] calldata assets, uint256 lockTime, uint256 tokenId)\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n}\n",
        "keccak256": "0xc1f739427297526680bbe4e507eb48ba513b6cb487fa1d0f0ca9cb849e516ae0",
        "license": "AGPL-3.0"
      },
      "src/interfaces/IDustTransferStrategy.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.30;\n\n/**\n * @title IDustTransferStrategy\n * @author Original implementation by Aave\n * @author Extended by Neverland\n * @notice Extended Aave's `ITransferStrategyBase` interface to add lockTime\n *         and tokenId parameters to the `performTransfer()` function.\n *         Added emergency withdrawal functionality.\n */\ninterface IDustTransferStrategy {\n    /// @notice Error thrown when the caller is not the incentives controller\n    error CallerNotIncentivesController();\n\n    /// @notice Error thrown when the caller is not the rewards admin\n    error OnlyRewardsAdmin();\n\n    /**\n     * @notice Emitted when an emergency withdrawal is performed\n     * @param caller The rewards admin that performed the withdrawal\n     * @param token The token address withdrawn from this strategy\n     * @param to The recipient of the withdrawn tokens\n     * @param amount The amount of tokens withdrawn\n     */\n    event EmergencyWithdrawal(address indexed caller, address indexed token, address indexed to, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the address of the Incentives Controller\n     * @return The Incentives Controller address\n     */\n    function getIncentivesController() external view returns (address);\n\n    /**\n     * @notice Returns the address of the Rewards admin\n     * @return The rewards admin address\n     */\n    function getRewardsAdmin() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                         TRANSFER STRATEGY\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n     * @dev If `tokenId` is specified it's owner has to be `to`\n     *      DUST_VAULT pre-approves infinite amount of `reward` to this contract\n     * @param to Account to transfer rewards to\n     * @param reward Address of the reward token\n     * @param amount Amount of the reward token to transfer\n     * @param lockTime Lock duration, or 0 for early exit\n     * @param tokenId Token ID to merge the emissions with, or 0 for no merge\n     * @return Returns true if transfer logic succeeds\n     */\n    function performTransfer(address to, address reward, uint256 amount, uint256 lockTime, uint256 tokenId)\n        external\n        returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Perform an emergency token withdrawal (admin only)\n     * @dev Only callable by the rewards admin to recover tokens from this strategy contract\n     * @param token Address of the token to withdraw funds from this contract\n     * @param to Address of the recipient of the withdrawal\n     * @param amount Amount of the withdrawal\n     */\n    function emergencyWithdrawal(address token, address to, uint256 amount) external;\n}\n",
        "keccak256": "0xaf2ae409f386ba131b0af0e85424d2e991c2ba1e434fb42639336e3759dd486f",
        "license": "AGPL-3.0"
      },
      "src/libraries/CommonChecksLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonChecksLibrary\n * @author Neverland\n * @notice Shared require/revert helpers for zero/invalid values used across contracts\n */\nlibrary CommonChecksLibrary {\n    /// @notice Used when a zero address is provided where not allowed.\n    error AddressZero();\n    /// @notice Used when a zero amount is provided where not allowed.\n    error ZeroAmount();\n    /// @notice Used when a range is invalid.\n    error InvalidRange();\n    /// @notice Used when two addresses are the same but must differ.\n    error SameAddress();\n    /// @notice Used when a balance is zero.\n    error ZeroBalance();\n    /// @notice Used when a tokenId is invalid.\n    error InvalidTokenId();\n    /// @notice Used when a from address is invalid.\n    error InvalidFromAddress();\n    /// @notice Used when a to address is invalid.\n    error InvalidToAddress();\n    /// @notice Used when a user address is invalid.\n    error InvalidUserAddress();\n    /// @notice Used a function is called by an account that is not permitted.\n    error UnauthorizedAccess();\n\n    /**\n     * @notice Reverts if the provided address is zero\n     * @param addressToCheck The address to check\n     */\n    function revertIfZeroAddress(address addressToCheck) internal pure {\n        if (addressToCheck == address(0)) revert AddressZero();\n    }\n\n    /**\n     * @notice Reverts if the provided amount is zero\n     * @param amount The amount to check\n     */\n    function revertIfZeroAmount(uint256 amount) internal pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n\n    /**\n     * @notice Reverts if the [from, to] range is invalid (from > to)\n     * @param from The start of the range\n     * @param to The end of the range\n     */\n    function revertIfInvalidRange(uint256 from, uint256 to) internal pure {\n        if (from > to) revert InvalidRange();\n    }\n\n    /**\n     * @notice Reverts if the two addresses are the same\n     * @param first The first address to check\n     * @param second The second address to check\n     */\n    function revertIfSameAddress(address first, address second) internal pure {\n        if (first == second) revert SameAddress();\n    }\n\n    /**\n     * @notice Reverts if the balance is zero\n     * @param balance The balance to check\n     */\n    function revertIfZeroBalance(uint256 balance) internal pure {\n        if (balance == 0) revert ZeroBalance();\n    }\n\n    /**\n     * @notice Reverts if the tokenId owner is the zero address\n     * @param owner The owner of the tokenId\n     */\n    function revertIfInvalidTokenId(address owner) internal pure {\n        if (owner == address(0)) revert InvalidTokenId();\n    }\n\n    /**\n     * @notice Reverts if the from address is zero\n     * @param from The from address to check\n     */\n    function revertIfInvalidFromAddress(address from) internal pure {\n        if (from == address(0)) revert InvalidFromAddress();\n    }\n\n    /**\n     * @notice Reverts if the to address is zero\n     * @param to The to address to check\n     */\n    function revertIfInvalidToAddress(address to) internal pure {\n        if (to == address(0)) revert InvalidToAddress();\n    }\n\n    /**\n     * @notice Reverts if the user address is zero\n     * @param user The user address to check\n     */\n    function revertIfInvalidUserAddress(address user) internal pure {\n        if (user == address(0)) revert InvalidUserAddress();\n    }\n}\n",
        "keccak256": "0xa8e23a48af12c93a809845953069be6f296d8d2e93e7cd89e5250b15b5d9f805",
        "license": "BUSL-1.1"
      },
      "src/libraries/CommonLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonLibrary\n * @author Neverland\n * @notice Miscellaneous shared helpers used across the codebase\n */\nlibrary CommonLibrary {\n    /**\n     * @notice Returns true if `account` is a contract.\n     * @dev This uses extcodesize/code.length which returns 0 for contracts in construction.\n     * @param account The address to check.\n     * @return True if code length > 0.\n     */\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n}\n",
        "keccak256": "0x6676bc617b86a7084e9f6cb4d666feeba4c545bb181322ce970aa945e3f017b9",
        "license": "BUSL-1.1"
      }
    },
    "version": 1
  },
  "proxy": "0x7f60150CaF5AA98A99E6EcD2e34E1E8A18d99174",
  "implementation": "0x798495BA821cD0D444A4ab4FA54bf989B80b62e1",
  "proxyAdmin": "0x723485842947E82783FC561720fB09B65F857ed5"
}