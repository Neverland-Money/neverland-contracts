{
  "networkName": "monadTestnet",
  "chainId": 10143,
  "contract": "DustLockTransferStrategy",
  "metadata": {
    "compiler": {
      "version": "0.8.30+commit.73712a01"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "incentivesController",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "rewardsAdmin",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "dustVault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "dustLock",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "name": "AddressZero",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "CallerNotIncentivesController",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidRewardAddress",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "InvalidToAddress",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotTokenOwner",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "OnlyRewardsAdmin",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "caller",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "EmergencyWithdrawal",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "DUST",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "DUST_LOCK",
          "outputs": [
            {
              "internalType": "contract IDustLock",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "DUST_VAULT",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "emergencyWithdrawal",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getIncentivesController",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getRewardsAdmin",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reward",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lockTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "name": "performTransfer",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "devdoc": {
        "author": "Neverland",
        "events": {
          "EmergencyWithdrawal(address,address,address,uint256)": {
            "params": {
              "amount": "The amount of tokens withdrawn",
              "caller": "The rewards admin that performed the withdrawal",
              "to": "The recipient of the withdrawn tokens",
              "token": "The token address withdrawn from this strategy"
            }
          }
        },
        "kind": "dev",
        "methods": {
          "constructor": {
            "params": {
              "dustLock": "The DustLock contract address",
              "dustVault": "The vault address that holds DUST balances",
              "incentivesController": "The incentives controller authorized to call performTransfer",
              "rewardsAdmin": "The rewards admin allowed to emergency withdraw tokens"
            }
          },
          "emergencyWithdrawal(address,address,uint256)": {
            "details": "Only callable by the rewards admin to recover tokens from this strategy contract",
            "params": {
              "amount": "Amount of the withdrawal",
              "to": "Address of the recipient of the withdrawal",
              "token": "Address of the token to withdraw funds from this contract"
            }
          },
          "getIncentivesController()": {
            "returns": {
              "_0": "The Incentives Controller address"
            }
          },
          "getRewardsAdmin()": {
            "returns": {
              "_0": "The rewards admin address"
            }
          },
          "performTransfer(address,address,uint256,uint256,uint256)": {
            "details": "If `tokenId` is specified it's owner has to be `to`      DUST_VAULT pre-approves infinite amount of `reward` to this contract",
            "params": {
              "amount": "Amount of the reward token to transfer",
              "lockTime": "Lock duration, or 0 for early exit",
              "reward": "Address of the reward token",
              "to": "Account to transfer rewards to",
              "tokenId": "Token ID to merge the emissions with, or 0 for no merge"
            },
            "returns": {
              "_0": "Returns true if transfer logic succeeds"
            }
          }
        },
        "stateVariables": {
          "DUST": {
            "return": "The address of the DUST token",
            "returns": {
              "_0": "The address of the DUST token"
            }
          },
          "DUST_LOCK": {
            "return": "The DustLock contract interface",
            "returns": {
              "_0": "The DustLock contract interface"
            }
          },
          "DUST_VAULT": {
            "return": "The address of the DUST vault",
            "returns": {
              "_0": "The address of the DUST vault"
            }
          }
        },
        "title": "DustLockTransferStrategy",
        "version": 1
      },
      "userdoc": {
        "errors": {
          "AddressZero()": [
            {
              "notice": "Used when a zero address is provided where not allowed."
            }
          ],
          "CallerNotIncentivesController()": [
            {
              "notice": "Error thrown when the caller is not the incentives controller"
            }
          ],
          "InvalidRewardAddress()": [
            {
              "notice": "Error thrown when reward token is not DUST"
            }
          ],
          "InvalidToAddress()": [
            {
              "notice": "Used when a to address is invalid."
            }
          ],
          "NotTokenOwner()": [
            {
              "notice": "Error thrown when tokenId owner is not the recipient"
            }
          ],
          "OnlyRewardsAdmin()": [
            {
              "notice": "Error thrown when the caller is not the rewards admin"
            }
          ]
        },
        "events": {
          "EmergencyWithdrawal(address,address,address,uint256)": {
            "notice": "Emitted when an emergency withdrawal is performed"
          }
        },
        "kind": "user",
        "methods": {
          "DUST()": {
            "notice": "Returns the DUST token address"
          },
          "DUST_LOCK()": {
            "notice": "Returns the DustLock contract that manages veNFTs"
          },
          "DUST_VAULT()": {
            "notice": "Returns the vault address where DUST rewards are stored before distribution"
          },
          "constructor": {
            "notice": "Constructs the DUST lock transfer strategy"
          },
          "emergencyWithdrawal(address,address,uint256)": {
            "notice": "Perform an emergency token withdrawal (admin only)"
          },
          "getIncentivesController()": {
            "notice": "Returns the address of the Incentives Controller"
          },
          "getRewardsAdmin()": {
            "notice": "Returns the address of the Rewards admin"
          },
          "performTransfer(address,address,uint256,uint256,uint256)": {
            "notice": "Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation"
          }
        },
        "notice": "Transfer strategy for DUST rewards, that sends user veDUST lock         created from DUST rewards, or allows for early withdrawal.         Adding DUST to an existing veDUST lock is also supported.",
        "version": 1
      }
    },
    "settings": {
      "compilationTarget": {
        "src/emissions/DustLockTransferStrategy.sol": "DustLockTransferStrategy"
      },
      "evmVersion": "paris",
      "libraries": {},
      "metadata": {
        "bytecodeHash": "none",
        "useLiteralContent": true
      },
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "remappings": []
    },
    "sources": {
      "@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../../openzeppelin/contracts/IERC20.sol';\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\nlibrary GPv2SafeERC20 {\n  /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n  /// also when the token returns `false`.\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    bytes4 selector_ = token.transfer.selector;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(freeMemoryPointer, selector_)\n      mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 36), value)\n\n      if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    require(getLastTransferResult(token), 'GPv2: failed transfer');\n  }\n\n  /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n  /// reverts also when the token returns `false`.\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    bytes4 selector_ = token.transferFrom.selector;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(freeMemoryPointer, selector_)\n      mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 68), value)\n\n      if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    require(getLastTransferResult(token), 'GPv2: failed transferFrom');\n  }\n\n  /// @dev Verifies that the last return was a successful `transfer*` call.\n  /// This is done by checking that the return data is either empty, or\n  /// is a valid ABI encoded boolean.\n  function getLastTransferResult(IERC20 token) private view returns (bool success) {\n    // NOTE: Inspecting previous return data requires assembly. Note that\n    // we write the return data to memory 0 in the case where the return\n    // data size is 32, this is OK since the first 64 bytes of memory are\n    // reserved by Solidy as a scratch space that can be used within\n    // assembly blocks.\n    // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      /// @dev Revert with an ABI encoded Solidity error with a message\n      /// that fits into 32-bytes.\n      ///\n      /// An ABI encoded Solidity error has the following memory layout:\n      ///\n      /// ------------+----------------------------------\n      ///  byte range | value\n      /// ------------+----------------------------------\n      ///  0x00..0x04 |        selector(\"Error(string)\")\n      ///  0x04..0x24 |      string offset (always 0x20)\n      ///  0x24..0x44 |                    string length\n      ///  0x44..0x64 | string value, padded to 32-bytes\n      function revertWithMessage(length, message) {\n        mstore(0x00, '\\x08\\xc3\\x79\\xa0')\n        mstore(0x04, 0x20)\n        mstore(0x24, length)\n        mstore(0x44, message)\n        revert(0x00, 0x64)\n      }\n\n      switch returndatasize()\n      // Non-standard ERC20 transfer without return.\n      case 0 {\n        // NOTE: When the return data size is 0, verify that there\n        // is code at the address. This is done in order to maintain\n        // compatibility with Solidity calling conventions.\n        // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\n        if iszero(extcodesize(token)) {\n          revertWithMessage(20, 'GPv2: not a contract')\n        }\n\n        success := 1\n      }\n      // Standard ERC20 transfer returning boolean success value.\n      case 32 {\n        returndatacopy(0, 0, returndatasize())\n\n        // NOTE: For ABI encoding v1, any non-zero value is accepted\n        // as `true` for a boolean. In order to stay compatible with\n        // OpenZeppelin's `SafeERC20` library which is known to work\n        // with the existing ERC20 implementation we care about,\n        // make sure we return success for any non-zero return value\n        // from the `transfer*` call.\n        success := iszero(iszero(mload(0)))\n      }\n      default {\n        revertWithMessage(31, 'GPv2: malformed transfer result')\n      }\n    }\n  }\n}\n",
        "keccak256": "0xb18337187a2a6c4e64c61f8e4e06f0e932a69bb8f33688943bf50d7f4198e44b",
        "license": "LGPL-3.0-or-later"
      },
      "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, 'Address: low-level call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\n    require(isContract(target), 'Address: call to non-contract');\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data\n  ) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, 'Address: low-level static call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), 'Address: static call to non-contract');\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), 'Address: delegate call to non-contract');\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n",
        "keccak256": "0x4ce20476966f73ba3c0aeb85b602b6ecc4e715f5bd9524d1c6286819282c76c5",
        "license": "MIT"
      },
      "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n",
        "keccak256": "0xf57d62241e553696a1324d225663ba2e1a51db0a51ca236d0c1b009d89b6284c",
        "license": "AGPL-3.0"
      },
      "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol';\nimport './Address.sol';\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      'SafeERC20: approve from non-zero to non-zero allowance'\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(oldAllowance >= value, 'SafeERC20: decreased allowance below zero');\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(\n        token,\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n      );\n    }\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, 'SafeERC20: low-level call failed');\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\n    }\n  }\n}\n",
        "keccak256": "0x9ada5448c24f34f934122c0e11d1a89bf9a31b7ade0dcb935bd7dcb339ef7f32",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n",
        "keccak256": "0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC4906.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n",
        "keccak256": "0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC6372.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n",
        "keccak256": "0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/interfaces/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n",
        "keccak256": "0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n",
        "keccak256": "0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266",
        "license": "MIT"
      },
      "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
        "keccak256": "0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9",
        "license": "MIT"
      },
      "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
        "keccak256": "0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1",
        "license": "MIT"
      },
      "src/emissions/DustLockTransferStrategy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport {GPv2SafeERC20} from \"@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport {IERC20} from \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {SafeERC20} from \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeERC20.sol\";\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\nimport {IDustLockTransferStrategy, IDustTransferStrategy} from \"../interfaces/IDustLockTransferStrategy.sol\";\n\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\n\nimport {DustTransferStrategyBase} from \"./DustTransferStrategyBase.sol\";\n\n/**\n * @title DustLockTransferStrategy\n * @author Neverland\n * @notice Transfer strategy for DUST rewards, that sends user veDUST lock\n *         created from DUST rewards, or allows for early withdrawal.\n *         Adding DUST to an existing veDUST lock is also supported.\n */\ncontract DustLockTransferStrategy is DustTransferStrategyBase, IDustLockTransferStrategy {\n    using GPv2SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////\n                             CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant BASIS_POINTS = 10_000;\n\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustLockTransferStrategy\n    IDustLock public immutable DUST_LOCK;\n\n    /// @inheritdoc IDustLockTransferStrategy\n    address public immutable DUST_VAULT;\n\n    /// @inheritdoc IDustLockTransferStrategy\n    address public immutable DUST;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructs the DUST lock transfer strategy\n     * @param incentivesController The incentives controller authorized to call performTransfer\n     * @param rewardsAdmin The rewards admin allowed to emergency withdraw tokens\n     * @param dustVault The vault address that holds DUST balances\n     * @param dustLock The DustLock contract address\n     */\n    constructor(address incentivesController, address rewardsAdmin, address dustVault, address dustLock)\n        DustTransferStrategyBase(incentivesController, rewardsAdmin)\n    {\n        CommonChecksLibrary.revertIfZeroAddress(incentivesController);\n        CommonChecksLibrary.revertIfZeroAddress(rewardsAdmin);\n        CommonChecksLibrary.revertIfZeroAddress(dustVault);\n        CommonChecksLibrary.revertIfZeroAddress(dustLock);\n\n        DUST_VAULT = dustVault;\n        DUST_LOCK = IDustLock(dustLock);\n        DUST = DUST_LOCK.token();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         TRANSFER STRATEGY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc DustTransferStrategyBase\n    function performTransfer(address to, address reward, uint256 amount, uint256 lockTime, uint256 tokenId)\n        external\n        override(DustTransferStrategyBase, IDustTransferStrategy)\n        onlyIncentivesController\n        returns (bool)\n    {\n        // Gracefully handle zero amount transfers\n        if (amount == 0) return true;\n        CommonChecksLibrary.revertIfInvalidToAddress(to);\n        if (reward != DUST) revert InvalidRewardAddress();\n\n        IERC20 rewardToken = IERC20(reward);\n        rewardToken.safeTransferFrom(DUST_VAULT, address(this), amount);\n\n        // tokenId > 0                      -> add DUST to existing veDUST;\n        // tokenId == 0 && lockTime > 0     -> create new veDUST lock;\n        // tokenId == 0 && lockTime == 0    -> direct DUST transfer with earlyWithdrawPenalty;\n        if (tokenId > 0) {\n            // Add DUST to existing veDUST\n            address owner = DUST_LOCK.ownerOf(tokenId);\n            if (owner != to) revert NotTokenOwner();\n            SafeERC20.safeIncreaseAllowance(rewardToken, address(DUST_LOCK), amount);\n            DUST_LOCK.depositFor(tokenId, amount);\n            SafeERC20.safeApprove(rewardToken, address(DUST_LOCK), 0);\n        } else if (lockTime > 0) {\n            // Create new veDUST lock\n            SafeERC20.safeIncreaseAllowance(rewardToken, address(DUST_LOCK), amount);\n            DUST_LOCK.createLockFor(amount, lockTime, to);\n            SafeERC20.safeApprove(rewardToken, address(DUST_LOCK), 0);\n        } else {\n            // Direct transfer with earlyWithdrawPenalty; overflow impossible within uint256 range\n            uint256 treasuryValue = (amount * DUST_LOCK.earlyWithdrawPenalty()) / BASIS_POINTS;\n            address treasury = DUST_LOCK.earlyWithdrawTreasury();\n            CommonChecksLibrary.revertIfZeroAddress(treasury);\n\n            rewardToken.safeTransfer(to, amount - treasuryValue);\n            rewardToken.safeTransfer(treasury, treasuryValue);\n        }\n        return true;\n    }\n}\n",
        "keccak256": "0x63d21632f4a1acfdc303d23c324fbe935d1d934018c1a9364fddf7d32048b4af",
        "license": "MIT"
      },
      "src/emissions/DustTransferStrategyBase.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.30;\n\nimport {GPv2SafeERC20} from \"@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport {IERC20} from \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\";\n\nimport {IDustTransferStrategy} from \"../interfaces/IDustTransferStrategy.sol\";\n\nimport {CommonChecksLibrary} from \"../libraries/CommonChecksLibrary.sol\";\n\n/**\n * @title DustTransferStrategyBase\n * @author Original implementation by Aave\n * @author Extended by Neverland\n * @notice Modified Aave's TransferStrategyBase contract to pass lockTime and\n *         tokenId to the `IDustTransferStrategy`.\n */\nabstract contract DustTransferStrategyBase is IDustTransferStrategy {\n    using GPv2SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The incentives controller contract address\n    address internal immutable INCENTIVES_CONTROLLER;\n\n    /// @dev The rewards admin address for administrative functions\n    address internal immutable REWARDS_ADMIN;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructs the base transfer strategy\n     * @param incentivesController The incentives controller authorized to call performTransfer\n     * @param rewardsAdmin The rewards admin authorized for emergency actions\n     */\n    constructor(address incentivesController, address rewardsAdmin) {\n        CommonChecksLibrary.revertIfZeroAddress(incentivesController);\n        CommonChecksLibrary.revertIfZeroAddress(rewardsAdmin);\n\n        INCENTIVES_CONTROLLER = incentivesController;\n        REWARDS_ADMIN = rewardsAdmin;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           ACCESS CONTROL\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Modifier for incentives controller only functions\n    modifier onlyIncentivesController() {\n        if (INCENTIVES_CONTROLLER != msg.sender) revert CallerNotIncentivesController();\n        _;\n    }\n\n    /// @dev Modifier for reward admin only functions\n    modifier onlyRewardsAdmin() {\n        if (msg.sender != REWARDS_ADMIN) revert OnlyRewardsAdmin();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustTransferStrategy\n    function getIncentivesController() external view override returns (address) {\n        return INCENTIVES_CONTROLLER;\n    }\n\n    /// @inheritdoc IDustTransferStrategy\n    function getRewardsAdmin() external view override returns (address) {\n        return REWARDS_ADMIN;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         TRANSFER STRATEGY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustTransferStrategy\n    function performTransfer(address to, address reward, uint256 amount, uint256 lockTime, uint256 tokenId)\n        external\n        virtual\n        returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                               ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDustTransferStrategy\n    function emergencyWithdrawal(address token, address to, uint256 amount) external onlyRewardsAdmin {\n        IERC20(token).safeTransfer(to, amount);\n\n        emit EmergencyWithdrawal(msg.sender, token, to, amount);\n    }\n}\n",
        "keccak256": "0x1cb8c90618fabc26ca7071d7190ff4518f90c5a20e04377b186d4f54da432d2c",
        "license": "AGPL-3.0"
      },
      "src/interfaces/IDustLock.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {IRevenueReward} from \"./IRevenueReward.sol\";\n\n/**\n * @title IDustLock Interface\n * @notice Interface for the DustLock contract that manages voting escrow NFTs (veNFTs)\n * @dev Combines ERC721 with vote-escrow functionality for governance and reward distribution\n */\ninterface IDustLock is IERC4906, IERC6372, IERC721Metadata {\n    /**\n     * @notice Structure representing a locked token position\n     * @dev Used to track the amount of tokens locked, when they unlock, and if they're permanently locked\n     * @param amount Amount of tokens locked in int256 format for consistency with precision calculations\n     * @param effectiveStart Effective start time for penalty calculations (weighted average on lock operations)\n     * @param end Timestamp when tokens unlock (0 for permanent locks)\n     * @param isPermanent Whether this is a permanent lock that cannot be withdrawn normally\n     */\n    struct LockedBalance {\n        int256 amount;\n        uint256 effectiveStart;\n        uint256 end;\n        bool isPermanent;\n    }\n\n    /**\n     * @notice Checkpoint for tracking user voting power at a specific point in time\n     * @dev Used in the vote-escrow system to track decay of voting power over time\n     * @param bias Voting power at time ts\n     * @param slope Rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanent Amount of permanent (non-decaying) voting power\n     */\n    struct UserPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanent;\n    }\n\n    /**\n     * @notice Global checkpoint for tracking total voting power at a specific point in time\n     * @dev Similar to UserPoint but tracks system-wide totals\n     * @param bias Total voting power at time ts\n     * @param slope Total rate of voting power decrease per second (-dweight/dt)\n     * @param ts Timestamp of the checkpoint\n     * @param blk Block number at which the checkpoint was created\n     * @param permanentLockBalance Total amount of permanently locked tokens\n     */\n    struct GlobalPoint {\n        int256 bias; // WAD format (18 decimals) for precision\n        int256 slope; // WAD format (18 decimals) for precision # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanentLockBalance;\n    }\n\n    /**\n     * @notice Types of deposit operations supported by the veNFT system\n     * @param DEPOSIT_FOR_TYPE Adding tokens to an existing lock owned by someone else\n     * @param CREATE_LOCK_TYPE Creating a new lock position\n     * @param INCREASE_LOCK_AMOUNT Adding more tokens to an existing lock\n     * @param INCREASE_UNLOCK_TIME Extending the lock duration of an existing lock\n     */\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /// @notice Error thrown when the locked amount is less than minLockAmount\n    error AmountTooSmall();\n\n    /// @notice Error thrown when the requested amount exceeds available balance\n    error AmountTooBig();\n\n    /// @notice Error thrown when an ERC721 receiver contract rejects the tokens\n    error ERC721ReceiverRejectedTokens();\n\n    /// @notice Error thrown when transferring to an address that doesn't implement ERC721Receiver\n    error ERC721TransferToNonERC721ReceiverImplementer();\n\n    /// @notice Error thrown when an early withdraw penalty value is invalid (>=10000)\n    error InvalidWithdrawPenalty();\n\n    /// @notice Error thrown when the lock duration doesn't extend beyond the current time\n    error LockDurationNotInFuture();\n\n    /// @notice Error thrown when the lock duration exceeds the maximum allowed time\n    error LockDurationTooLong();\n\n    /// @notice Error thrown when the lock duration is less than the minimum required time\n    error LockDurationTooShort();\n\n    /// @notice Error thrown when trying to depositFor to a lock expiring within MINTIME\n    error DepositForLockDurationTooShort();\n\n    /// @notice Error thrown when trying to perform an operation on an expired lock\n    error LockExpired();\n\n    /// @notice Error thrown when trying to withdraw from a lock that hasn't expired yet\n    error LockNotExpired();\n\n    /// @notice Error thrown when no lock is found for the specified token ID\n    error NoLockFound();\n\n    /// @notice Error thrown when the caller is neither the owner nor approved for the token\n    error NotApprovedOrOwner();\n\n    /// @notice Error thrown when trying to unlock a non-permanent lock using unlockPermanent\n    error NotPermanentLock();\n\n    /// @notice Error thrown when the caller is not the owner of the token\n    error NotOwner();\n\n    /// @notice Error thrown when a team-only function is called by a non-team address\n    error NotTeam();\n\n    /// @notice Error thrown when a pending team function is called by a non-pending team address\n    error NotPendingTeam();\n\n    /// @notice Error thrown when trying to withdraw or modify a permanent lock\n    error PermanentLock();\n\n    /// @notice Error thrown when attempting to merge a veNFT with itself\n    error SameNFT();\n\n    /// @notice Error thrown when splitting is not allowed for the user\n    error SplitNotAllowed();\n\n    /// @notice Error thrown when trying to add a token that already has an owner\n    error AlreadyOwned();\n\n    /// @notice Error thrown when setting a revenue reward contract that is not a deployed contract\n    error InvalidRevenueRewardContract();\n\n    /**\n     * @notice Emitted when tokens are deposited into the veNFT system\n     * @param provider Address depositing the tokens\n     * @param tokenId ID of the veNFT being created or modified\n     * @param depositType Type of deposit operation (create, increase amount, etc.)\n     * @param value Amount of tokens deposited\n     * @param locktime Timestamp when the lock expires\n     * @param ts Timestamp when the deposit occurred\n     */\n    event Deposit(\n        address indexed provider,\n        uint256 indexed tokenId,\n        DepositType indexed depositType,\n        uint256 value,\n        uint256 locktime,\n        uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn before the lock expiry with a penalty\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Original locked amount\n     * @param amountReturned Amount returned to the user after penalty\n     * @param ts Timestamp when the early withdrawal occurred\n     */\n    event EarlyWithdraw(\n        address indexed provider, uint256 indexed tokenId, uint256 value, uint256 amountReturned, uint256 ts\n    );\n\n    /**\n     * @notice Emitted when tokens are withdrawn after the lock expiry\n     * @param provider Address receiving the withdrawn tokens\n     * @param tokenId ID of the veNFT being withdrawn\n     * @param value Amount of tokens withdrawn\n     * @param ts Timestamp when the withdrawal occurred\n     */\n    event Withdraw(address indexed provider, uint256 indexed tokenId, uint256 value, uint256 ts);\n\n    /**\n     * @notice Emitted when a lock is converted to a permanent lock\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being locked permanently\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was created\n     */\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when a permanent lock is unlocked by governance\n     * @param _owner Address that owns the veNFT\n     * @param _tokenId ID of the veNFT being unlocked\n     * @param amount Amount of tokens in the lock\n     * @param _ts Timestamp when the permanent lock was unlocked\n     */\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n\n    /**\n     * @notice Emitted when the total supply of locked tokens changes\n     * @param prevSupply Previous total locked supply\n     * @param supply New total locked supply\n     */\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    /**\n     * @notice Emitted when two veNFTs are merged\n     * @param _sender Address initiating the merge\n     * @param _from Source veNFT ID (burned in the process)\n     * @param _to Destination veNFT ID (receives combined balance)\n     * @param _amountFrom Amount of tokens in the source veNFT\n     * @param _amountTo Amount of tokens in the destination veNFT before merge\n     * @param _amountFinal Final amount of tokens in the destination veNFT after merge\n     * @param _locktime New lock expiry time for the merged veNFT\n     * @param _ts Timestamp when the merge occurred\n     */\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a veNFT is split into two separate veNFTs\n     * @param _from Original veNFT ID being split (burned in the process)\n     * @param _tokenId1 First new veNFT ID created from the split\n     * @param _tokenId2 Second new veNFT ID created from the split\n     * @param _sender Address initiating the split\n     * @param _splitAmount1 Amount of tokens allocated to the first veNFT\n     * @param _splitAmount2 Amount of tokens allocated to the second veNFT\n     * @param _locktime Lock expiry time for both new veNFTs\n     * @param _ts Timestamp when the split occurred\n     */\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    /**\n     * @notice Emitted when a new team address is proposed\n     * @param currentTeam The current team address that proposed the change\n     * @param proposedTeam The newly proposed team address\n     */\n    event TeamProposed(address indexed currentTeam, address indexed proposedTeam);\n\n    /**\n     * @notice Emitted when a proposed team address accepts ownership\n     * @param oldTeam The previous team address\n     * @param newTeam The new team address that accepted ownership\n     */\n    event TeamAccepted(address indexed oldTeam, address indexed newTeam);\n\n    /**\n     * @notice Emitted when a team proposal is cancelled\n     * @param currentTeam The current team address that cancelled the proposal\n     * @param cancelledTeam The proposed team address that was cancelled\n     */\n    event TeamProposalCancelled(address indexed currentTeam, address indexed cancelledTeam);\n\n    /**\n     * @notice Emitted when the early withdraw penalty is updated\n     * @param oldPenalty Previous penalty in basis points\n     * @param newPenalty New penalty in basis points\n     */\n    event EarlyWithdrawPenaltyUpdated(uint256 oldPenalty, uint256 newPenalty);\n\n    /**\n     * @notice Emitted when the early withdraw treasury address is updated\n     * @param oldTreasury Previous treasury address\n     * @param newTreasury New treasury address\n     */\n    event EarlyWithdrawTreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Emitted when the minimum lock amount is updated\n     * @param oldAmount Previous minimum lock amount\n     * @param newAmount New minimum lock amount\n     */\n    event MinLockAmountUpdated(uint256 oldAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted when the revenue reward contract is updated\n     * @param oldReward Previous revenue reward contract address\n     * @param newReward New revenue reward contract address\n     */\n    event RevenueRewardUpdated(address indexed oldReward, address indexed newReward);\n\n    /**\n     * @notice Emitted when the split permission is toggled for an account\n     * @param account Address whose permission is updated\n     * @param allowed Whether splitting is now allowed for the account\n     */\n    event SplitPermissionUpdated(address indexed account, bool allowed);\n\n    /**\n     * @notice Emitted when the base URI is updated\n     * @param oldBaseURI Previous base URI\n     * @param newBaseURI New base URI\n     */\n    event BaseURIUpdated(string oldBaseURI, string newBaseURI);\n\n    /*//////////////////////////////////////////////////////////////\n                                STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Address of Meta-tx Forwarder\n     * @return The trusted forwarder address used for meta-transactions\n     */\n    function forwarder() external view returns (address);\n\n    /**\n     * @notice Address of token (DUST) used to create a veNFT\n     * @return The ERC20 token address used to lock and mint veNFTs\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Address of Neverland Team multisig\n     * @return The address of the current team multisig with administrative privileges\n     */\n    function team() external view returns (address);\n\n    /**\n     * @notice Address of pending team for two-step ownership transfer\n     * @return The address of the pending team, or address(0) if no proposal exists\n     */\n    function pendingTeam() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Proposes a new team address for two-step ownership transfer\n     * @dev This is the first step of a two-step ownership transfer process.\n     *      Only the current team can propose a new team address.\n     *      The proposed address must accept ownership to complete the transfer.\n     *      This prevents accidental loss of admin control due to typos or wrong addresses.\n     * @param _newTeam The address of the proposed new team multisig\n     */\n    function proposeTeam(address _newTeam) external;\n\n    /**\n     * @notice Accepts the proposed team address to complete the ownership transfer\n     * @dev This is the second step of the two-step ownership transfer process.\n     *      Only the pending team address can call this function.\n     *      Once called, the caller becomes the new team and the pending team is cleared.\n     *      This ensures that the new team controls the proposed address.\n     */\n    function acceptTeam() external;\n\n    /**\n     * @notice Cancels the pending team proposal\n     * @dev Allows the current team to cancel a pending ownership transfer.\n     *      Only the current team can call this function.\n     *      This is useful if the team made an error in the proposed address.\n     *      After cancellation, a new proposal can be made.\n     */\n    function cancelTeamProposal() external;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the name of the token\n     * @return The name of the veNFT token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token\n     * @return The symbol of the veNFT token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns the version of the contract\n     * @return The current version string of the contract\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice Updates the base URI for computing tokenURI\n     * @dev Can only be called by the team address\n     * @param newBaseURI The new base URI to set for all tokens\n     */\n    function setBaseURI(string memory newBaseURI) external;\n\n    /**\n     * @notice Current total count of veNFT tokens\n     * @dev Used as a counter for minting new tokens and assigning IDs\n     * @return The current highest token ID value\n     */\n    function tokenId() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the tokenId owned by `_owner` at position `_index`\n     * @param _owner Owner address to query\n     * @param _index Index of the token within the owner's list\n     * @return _tokenId The tokenId at the given index for the owner\n     */\n    function ownerToNFTokenIdList(address _owner, uint256 _index) external view returns (uint256 _tokenId);\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @notice Check whether spender is owner or an approved user for a given veNFT\n     * @param _spender The address to approve for the tokenId\n     * @param _tokenId The ID of the veNFT to be approved\n     * @return True if `_spender` is owner or approved for `_tokenId`, false otherwise\n     */\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Total count of epochs witnessed since contract creation\n     * @return The current epoch number\n     */\n    function epoch() external view returns (uint256);\n\n    /**\n     * @notice Total amount of tokens currently locked in the contract\n     * @return The total supply of locked tokens\n     */\n    function supply() external view returns (uint256);\n\n    /**\n     * @notice Aggregate balance of permanently locked tokens\n     * @dev These tokens cannot be withdrawn through normal means\n     * @return The total amount of permanently locked tokens\n     */\n    function permanentLockBalance() external view returns (uint256);\n\n    /**\n     * @notice Percentage of penalty applied to early withdrawals (in basis points)\n     * @dev Value is between 0 and 10000 (0% to 100%)\n     * @return The current penalty percentage in basis points\n     */\n    function earlyWithdrawPenalty() external view returns (uint256);\n\n    /**\n     * @notice Address that receives penalty fees from early withdrawals\n     * @return The address of the treasury that collects early withdrawal penalties\n     */\n    function earlyWithdrawTreasury() external view returns (address);\n\n    /**\n     * @notice Get the current epoch number for a specific veNFT\n     * @param _tokenId The ID of the veNFT to check\n     * @return _epoch The current epoch number for the specified veNFT\n     */\n    function userPointEpoch(uint256 _tokenId) external view returns (uint256 _epoch);\n\n    /**\n     * @notice Retrieve the scheduled slope change at a given timestamp\n     * @dev Used to calculate future voting power changes due to lock expirations\n     * @param _timestamp The timestamp to check for slope changes\n     * @return The net change in slope (negative value means decrease in voting power)\n     */\n    function slopeChanges(uint256 _timestamp) external view returns (int256);\n\n    /**\n     * @notice Check if an account has permission to split veNFTs\n     * @dev Used to control which addresses can perform veNFT splitting operations\n     * @param _account The address to check for split permission\n     * @return True if the account can split veNFTs, false otherwise\n     */\n    function canSplit(address _account) external view returns (bool);\n\n    /**\n     * @notice Retrieve a global checkpoint at a specific index\n     * @dev Used to track historical voting power across all tokens at different points in time\n     * @param _loc The index of the checkpoint to retrieve\n     * @return The GlobalPoint data at the specified index\n     */\n    function pointHistory(uint256 _loc) external view returns (GlobalPoint memory);\n\n    /**\n     * @notice Get the lock details for a specific veNFT\n     * @dev Returns information about lock amount, end time, and permanent status\n     * @param _tokenId The ID of the veNFT to query\n     * @return The LockedBalance struct containing lock information\n     */\n    function locked(uint256 _tokenId) external view returns (LockedBalance memory);\n\n    /**\n     * @notice Retrieve a user checkpoint for a specific veNFT at a given index\n     * @dev Used to track historical voting power for individual tokens\n     * @param _tokenId The ID of the veNFT to query\n     * @param _loc The index of the user checkpoint to retrieve\n     * @return The UserPoint data at the specified index for the given token\n     */\n    function userPointHistory(uint256 _tokenId, uint256 _loc) external view returns (UserPoint memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Create a global checkpoint to record the current state of voting power\n     * @dev Updates the global point history with current voting power data\n     *      This is called automatically by most state-changing functions\n     *      but can be called manually to ensure up-to-date on-chain data\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT lock\n     * @dev Anyone (even a smart contract) can deposit tokens for someone else's lock\n     *      The deposit increases the lock amount but does not extend the lock time\n     *      Cannot be used for locks that have already expired\n     * @param _tokenId The ID of the veNFT to deposit for\n     * @param _value Amount of tokens to add to the existing lock\n     */\n    function depositFor(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Create a new lock by depositing tokens for the caller\n     * @dev Creates a new veNFT representing the locked tokens\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return The ID of the newly created veNFT\n     */\n    function createLock(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock by depositing tokens for another address\n     * @dev Creates a new veNFT representing the locked tokens and assigns it to the specified recipient\n     *      This is useful for protocols that want to create locks on behalf of their users\n     *      Lock duration is rounded down to the nearest week\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return The ID of the newly created veNFT\n     */\n    function createLockFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for the caller and immediately make it permanent\n     * @dev UX convenience to perform \"create lock\" and \"make permanent\" in a single transaction\n     *      Follows the same validation as `createLock` (min amount, duration bounds, week rounding)\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanent(uint256 _value, uint256 _lockDuration) external returns (uint256);\n\n    /**\n     * @notice Create a new lock for `to` and immediately make it permanent\n     * @dev UX convenience to mint the veNFT to `to` and set permanence in one transaction\n     *      Uses `to` as the owner for auth semantics; validation mirrors `createLock`\n     * @param _value Amount of tokens to deposit and lock\n     * @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n     * @param _to The address that will own the newly created veNFT\n     * @return tokenId The ID of the newly created veNFT\n     */\n    function createLockPermanentFor(uint256 _value, uint256 _lockDuration, address _to) external returns (uint256);\n\n    /**\n     * @notice Deposit additional tokens for an existing veNFT without modifying the unlock time\n     * @dev Increases the amount of tokens in a lock while keeping the same unlock date\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to increase the amount for\n     * @param _value Additional amount of tokens to add to the lock\n     */\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\n\n    /**\n     * @notice Extend the unlock time for an existing veNFT lock\n     * @dev Increases the lock duration without changing the token amount\n     *      Cannot extend lock time of permanent locks\n     *      New lock time is rounded down to the nearest week\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to extend the lock duration for\n     * @param _lockDuration New number of seconds until tokens unlock (from current time)\n     */\n    function increaseUnlockTime(uint256 _tokenId, uint256 _lockDuration) external;\n\n    /**\n     * @notice Withdraw all tokens from an expired lock for `_tokenId`\n     * @dev Only possible if the lock has expired and is not a permanent lock\n     *      This function burns the veNFT and returns the locked tokens to the owner\n     *      IMPORTANT: Any unclaimed rebases or rewards will no longer be claimable after calling this\n     *      Users should claim all rebases and rewards prior to withdrawing\n     *      Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw tokens from\n     */\n    function withdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Withdraw tokens from a lock before it expires, with a time-proportional penalty\n     * @dev Allows users to exit a lock early but with a penalty fee applied\n     *      The penalty is proportional to both `earlyWithdrawPenalty` and remaining time until unlock\n     *      If the lock is permanent, it is internally converted back to a standard time-lock first and\n     *      the early withdraw penalty is computed using the restored lock window. Penalty fees are sent\n     *      to the `earlyWithdrawTreasury` address. Burns the veNFT and returns the nonpenalized portion\n     *      of tokens to the owner. Can only be called by the owner of the veNFT or an approved address\n     * @param _tokenId The ID of the veNFT to withdraw early from\n     */\n    function earlyWithdraw(uint256 _tokenId) external;\n\n    /**\n     * @notice Sets the early withdrawal penalty percentage\n     * @dev Can only be called by the team address\n     *      Value is in basis points (0-10000), where 10000 = 100%\n     * @param _earlyWithdrawPenalty The new penalty percentage in basis points\n     */\n    function setEarlyWithdrawPenalty(uint256 _earlyWithdrawPenalty) external;\n\n    /**\n     * @notice Sets the treasury address that will receive penalty fees from early withdrawals\n     * @dev Can only be called by the team address\n     *      The treasury address receives the penalty portion of tokens from early withdrawals\n     * @param _account The address of the new treasury that will receive penalty fees\n     */\n    function setEarlyWithdrawTreasury(address _account) external;\n\n    /**\n     * @notice Merges two veNFTs by combining their locked tokens into a single veNFT\n     * @dev The source veNFT is burned and its tokens are added to the destination veNFT\n     *      The lock duration/semantics of the destination veNFT are preserved\n     *      Rules:\n     *      - permanent + permanent: allowed (destination stays permanent)\n     *      - nonpermanent + permanent: allowed (permanent principal increases)\n     *      - permanent + nonpermanent: reverts\n     *      - expired source or destination: reverts\n     *      Can only be called by an address that owns or is approved for both veNFTs\n     * @param _from The ID of the source veNFT to merge from (will be burned)\n     * @param _to The ID of the destination veNFT to merge into (will receive the combined tokens)\n     */\n    function merge(uint256 _from, uint256 _to) external;\n\n    /**\n     * @notice Splits a veNFT into two new veNFTs with divided token balances\n     * @dev This operation burns the original veNFT and creates two new ones\n     *      Both new veNFTs maintain the same lock end time as the original\n     *      Can only be called by an address that has split permission, and owns or is approved for the veNFT\n     *      If called by an approved address, that address will NOT have approval on the new veNFTs\n     *      (approvals on the parent do not carry over to children)\n     *      Requires that the caller is either the owner or specifically has been granted split permission\n     *      Cannot split permanent locks\n     * @param _from The ID of the veNFT to split (will be burned)\n     * @param _amount The precise token amount to allocate to the second new veNFT\n     * @return _tokenId1 ID of the first new veNFT with (original amount - _amount) tokens\n     * @return _tokenId2 ID of the second new veNFT with exactly _amount tokens\n     */\n    function split(uint256 _from, uint256 _amount) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n    /**\n     * @notice Grant or revoke permission for an address to split veNFTs\n     * @dev Can only be called by the team address\n     *      Setting permissions for address(0) acts as a global switch for all addresses\n     *      If address(0) is set to false, no address can split regardless of individual permissions\n     *      If address(0) is set to true, individual permissions apply normally\n     * @param _account The address to modify split permissions for, or address(0) for global setting\n     * @param _bool True to grant permission, false to revoke permission\n     */\n    function toggleSplit(address _account, bool _bool) external;\n\n    /**\n     * @notice Permanently lock a veNFT to give it non-decaying voting power\n     * @dev Converts a standard time-locked veNFT to a permanent lock\n     *      Once permanent, the veNFT cannot be withdrawn normally (even after the original lock time)\n     *      Permanent locks have constant voting power equal to the locked token amount with no time decay\n     *      Note: time served prior to permanence is not preserved for penalty calculations  if the owner\n     *      later calls `earlyWithdraw`, the position is first unlocked and the penalty window resets to a\n     *      full MAXTIME from the current timestamp\n     *      Can only be called by the owner of the veNFT or an approved address\n     *      Cannot be called on a lock that is already permanent\n     * @param _tokenId The ID of the veNFT to permanently lock\n     */\n    function lockPermanent(uint256 _tokenId) external;\n\n    /**\n     * @notice Revert a veNFT from permanent lock status back to a standard time-lock\n     * @dev Converts a permanent lock back to a standard time-based lock\n     *      After unlocking, the veNFT's voting power will decay based on the remaining lock time\n     *      The lock time will be the original lock end time from before it was made permanent\n     *      If the original lock time has already passed, the lock will be immediately withdrawable\n     *      Can only be called by the owner or an approved operator\n     *      Only callable on veNFTs that are currently permanently locked\n     * @param _tokenId The ID of the veNFT to revert from permanent to standard lock\n     */\n    function unlockPermanent(uint256 _tokenId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                           VOTING POWER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the current voting power for a specific veNFT\n     * @dev Calculates voting power based on lock amount, remaining time, and permanent status\n     *      For standard locks: voting power = amount * (time_left / MAXTIME)\n     *      For permanent locks: voting power = amount (no time decay)\n     *      Returns 0 if called in the same block as a transfer due to checkpoint timing\n     *      This is the core function used for governance voting power determination\n     * @param _tokenId The ID of the veNFT to query voting power for\n     * @return The current voting power of the specified veNFT\n     */\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Get the historical voting power for a veNFT at a specific timestamp\n     * @dev Uses checkpoints to determine voting power at any point in the past\n     *      Crucial for governance systems that need to determine past voting power\n     *      For timestamps between checkpoints, calculates the interpolated value\n     *      Returns 0 for timestamps before the veNFT was created\n     * @param _tokenId The ID of the veNFT to query historical voting power for\n     * @param _t The timestamp at which to query the voting power\n     * @return The voting power of the specified veNFT at the requested timestamp\n     */\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    /**\n     * @notice Calculate the total voting power across all veNFTs at the current timestamp\n     * @dev Sums up all individual veNFT voting powers including both time-based and permanent locks\n     *      This represents the total governance voting power in the system right now\n     * @return The aggregate voting power of all veNFTs at the current timestamp\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Calculate the total historical voting power across all veNFTs at a specific timestamp\n     * @dev Uses global checkpoints to determine total voting power at any point in the past\n     *      Critical for governance votes that need to determine the total voting power at a past block\n     *      For timestamps between checkpoints, calculates the interpolated value\n     * @param _t The timestamp at which to query the total voting power\n     * @return The aggregate voting power of all veNFTs at the requested timestamp\n     */\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC6372\n    function clock() external view returns (uint48);\n\n    /// @inheritdoc IERC6372\n    function CLOCK_MODE() external view returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                          MIN LOCK AMOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the minimum amount of tokens required to create a veNFT lock\n     * @dev This value is used to validate lock creation and prevent spam attacks\n     * @return The minimum lock amount in token units (with 18 decimals)\n     */\n    function minLockAmount() external view returns (uint256);\n\n    /**\n     * @notice Sets the minimum amount of tokens required to create a veNFT lock\n     * @dev Can only be called by the team address. This helps prevent spam and ensures meaningful lock amounts\n     * @param newMinLockAmount The new minimum lock amount in token units (with 18 decimals)\n     */\n    function setMinLockAmount(uint256 newMinLockAmount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                      NOTIFY CONTRACTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the revenue reward contract\n     * @dev Returns address(0) if no revenue reward contract is set\n     * @return The revenue reward contract\n     */\n    function revenueReward() external view returns (IRevenueReward);\n\n    /**\n     * @notice Sets the revenue reward contract\n     * @dev Can only be called by the team address\n     * @param _revenueReward The new revenue reward contract\n     */\n    function setRevenueReward(IRevenueReward _revenueReward) external;\n}\n",
        "keccak256": "0x6b386b558166fbc71e1bf95bee2210f81afd960ab7129ac7503125c1ffb9bc5b",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IDustLockTransferStrategy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport {IDustTransferStrategy} from \"./IDustTransferStrategy.sol\";\nimport {IDustLock} from \"./IDustLock.sol\";\n\n/**\n * @title IDustLockTransferStrategy\n * @author Neverland\n * @notice Interface for the DustLock transfer strategy which manages reward distributions to veNFT holders\n * @dev Extends IDustTransferStrategy with specialized functionality for veNFT integration and DUST token handling\n */\ninterface IDustLockTransferStrategy is IDustTransferStrategy {\n    /// @notice Error thrown when reward token is not DUST\n    error InvalidRewardAddress();\n\n    /// @notice Error thrown when tokenId owner is not the recipient\n    error NotTokenOwner();\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the DustLock contract that manages veNFTs\n     * @return The DustLock contract interface\n     */\n    function DUST_LOCK() external view returns (IDustLock);\n\n    /**\n     * @notice Returns the vault address where DUST rewards are stored before distribution\n     * @return The address of the DUST vault\n     */\n    function DUST_VAULT() external view returns (address);\n\n    /**\n     * @notice Returns the DUST token address\n     * @return The address of the DUST token\n     */\n    function DUST() external view returns (address);\n}\n",
        "keccak256": "0x9ba3577be3d648293dcf67b52de992cb7689862765c41ec7b26c4a3bb8a91f5b",
        "license": "MIT"
      },
      "src/interfaces/IDustTransferStrategy.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.30;\n\n/**\n * @title IDustTransferStrategy\n * @author Original implementation by Aave\n * @author Extended by Neverland\n * @notice Extended Aave's `ITransferStrategyBase` interface to add lockTime\n *         and tokenId parameters to the `performTransfer()` function.\n *         Added emergency withdrawal functionality.\n */\ninterface IDustTransferStrategy {\n    /// @notice Error thrown when the caller is not the incentives controller\n    error CallerNotIncentivesController();\n\n    /// @notice Error thrown when the caller is not the rewards admin\n    error OnlyRewardsAdmin();\n\n    /**\n     * @notice Emitted when an emergency withdrawal is performed\n     * @param caller The rewards admin that performed the withdrawal\n     * @param token The token address withdrawn from this strategy\n     * @param to The recipient of the withdrawn tokens\n     * @param amount The amount of tokens withdrawn\n     */\n    event EmergencyWithdrawal(address indexed caller, address indexed token, address indexed to, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the address of the Incentives Controller\n     * @return The Incentives Controller address\n     */\n    function getIncentivesController() external view returns (address);\n\n    /**\n     * @notice Returns the address of the Rewards admin\n     * @return The rewards admin address\n     */\n    function getRewardsAdmin() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                         TRANSFER STRATEGY\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n     * @dev If `tokenId` is specified it's owner has to be `to`\n     *      DUST_VAULT pre-approves infinite amount of `reward` to this contract\n     * @param to Account to transfer rewards to\n     * @param reward Address of the reward token\n     * @param amount Amount of the reward token to transfer\n     * @param lockTime Lock duration, or 0 for early exit\n     * @param tokenId Token ID to merge the emissions with, or 0 for no merge\n     * @return Returns true if transfer logic succeeds\n     */\n    function performTransfer(address to, address reward, uint256 amount, uint256 lockTime, uint256 tokenId)\n        external\n        returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Perform an emergency token withdrawal (admin only)\n     * @dev Only callable by the rewards admin to recover tokens from this strategy contract\n     * @param token Address of the token to withdraw funds from this contract\n     * @param to Address of the recipient of the withdrawal\n     * @param amount Amount of the withdrawal\n     */\n    function emergencyWithdrawal(address token, address to, uint256 amount) external;\n}\n",
        "keccak256": "0xaf2ae409f386ba131b0af0e85424d2e991c2ba1e434fb42639336e3759dd486f",
        "license": "AGPL-3.0"
      },
      "src/interfaces/IRevenueReward.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\nimport {IDustLock} from \"../interfaces/IDustLock.sol\";\n\nimport {IUserVaultFactory} from \"./IUserVaultFactory.sol\";\n\n/**\n * @title IRevenueReward Interface\n * @author Neverland\n * @notice Interface for the RevenueReward contract that manages token rewards distribution\n * @dev Handles reward epochs, claiming rewards, and self-repaying loan functionality\n */\ninterface IRevenueReward {\n    /// @notice Error thrown when a non-distributor address attempts to notify rewards\n    error NotRewardDistributor();\n\n    /// @notice Error thrown when a non-owner address attempts a restricted operation\n    error NotOwner();\n\n    /// @notice Error thrown when a non-DustLock address attempts a restricted operation\n    error NotDustLock();\n\n    /// @notice Error thrown when end timestamp used for calculating rewards is greater than the current time\n    error EndTimestampMoreThanCurrent();\n\n    /// @notice Error thrown when provided arrays are empty or exceed soft size limits\n    error InvalidArrayLengths();\n\n    /// @notice Error thrown when a provided reward token is not registered\n    error UnknownRewardToken();\n\n    /**\n     * @notice Emitted when rewards are claimed\n     * @param tokenId The veNFT id that produced the rewards\n     * @param user The address that received the rewards (owner or configured receiver)\n     * @param token Address of the reward token being claimed\n     * @param amount Amount of rewards claimed\n     */\n    event ClaimRewards(uint256 indexed tokenId, address indexed user, address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when new rewards are notified to the contract\n     * @param from Address that notified the rewards (typically the reward distributor)\n     * @param token Address of the reward token being added\n     * @param epoch Reward epoch start timestamp (i.e., start of the week) the amount is credited to\n     * @param amount Amount of rewards added\n     */\n    event NotifyReward(address indexed from, address indexed token, uint256 epoch, uint256 amount);\n\n    /**\n     * @notice Emitted when tokens are recovered from the contract\n     * @param token Address of the token being recovered\n     * @param amount Amount of tokens recovered\n     */\n    event RecoverTokens(address indexed token, uint256 amount);\n\n    /**\n     * @notice Emitted when self-repaying loan status is updated for a token\n     * @param token ID of the veNFT whose reward redirection is being configured\n     * @param rewardReceiver Address that will receive the rewards (or zero address if disabled)\n     * @param isEnabled Whether self-repaying loan is being enabled (true) or disabled (false)\n     */\n    event SelfRepayingLoanUpdate(uint256 indexed token, address rewardReceiver, bool isEnabled);\n\n    /**\n     * @notice Emitted when the reward distributor address is updated\n     * @param oldDistributor The previous reward distributor\n     * @param newDistributor The new reward distributor\n     */\n    event RewardDistributorUpdated(address indexed oldDistributor, address indexed newDistributor);\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice The address of the DustLock contract that manages veNFTs\n     * @return The IDustLock interface of the connected DustLock contract\n     */\n    function dustLock() external view returns (IDustLock);\n\n    /**\n     * @notice The address of the UserVaultFactory contract that manages user vaults\n     * @return The IUserVaultFactory interface of the connected UserVaultFactory contract\n     */\n    function userVaultFactory() external view returns (IUserVaultFactory);\n\n    /**\n     * @notice The duration of a reward epoch in seconds\n     * @dev This defines the time window for each reward distribution cycle\n     * @return Duration in seconds for each reward epoch\n     */\n    function DURATION() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of tokenIds allowed in a single batch claim.\n     * @return The maximum number of tokenIds accepted in batch calls\n     */\n    function MAX_TOKENIDS() external view returns (uint256);\n\n    /**\n     * @notice Maximum number of reward tokens allowed in a single batch claim.\n     * @return The maximum number of reward tokens accepted in batch calls\n     */\n    function MAX_TOKENS() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                            STORAGE GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the timestamp of the last successfully processed reward claim for a token and veNFT\n     * @dev Used to calculate the amount of rewards earned since the last claim. Value is advanced to the\n     *      claim period end only when there were epochs to process; otherwise it remains unchanged.\n     * @param token The address of the reward token\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp (seconds) when rewards were last processed up to\n     */\n    function lastEarnTime(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the address authorized to add rewards to the contract\n     * @dev This address is the only one that can call notifyRewardAmount\n     *      Typically set to a protocol treasury or governance-controlled address\n     * @return The current reward distributor address\n     */\n    function rewardDistributor() external view returns (address);\n\n    /**\n     * @notice Checks if a token is registered as a valid reward token\n     * @dev Only registered reward tokens can be distributed through the contract\n     *      Tokens are registered automatically the first time they're used in notifyRewardAmount\n     * @param token The address of the token to check\n     * @return True if the token is registered as a reward token, false otherwise\n     */\n    function isRewardToken(address token) external view returns (bool);\n\n    /**\n     * @notice Returns the reward token at a specific index in the list of registered reward tokens\n     * @dev Used to enumerate all reward tokens available in the contract\n     *      Valid indices range from 0 to the number of registered reward tokens minus 1\n     * @param index The index in the reward tokens array\n     * @return The address of the reward token at the specified index\n     */\n    function rewardTokens(uint256 index) external view returns (address);\n\n    /**\n     * @notice Returns the accumulated sum of all reward distributions for a specific token\n     * @dev Used for internal reward accounting and distribution calculations\n     *      This value increases each time new rewards are notified\n     * @param token The address of the reward token\n     * @return The total amount of rewards ever distributed for this token\n     */\n    function totalRewardsPerToken(address token) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of rewards allocated for a specific token at a given epoch start\n     * @dev Rewards are tracked by epoch start timestamp (seconds), with each epoch lasting DURATION seconds.\n     * @param token The address of the reward token\n     * @param epoch The epoch start timestamp (i.e., start of the week)\n     * @return The amount of rewards allocated for the token at that epoch start\n     */\n    function tokenRewardsPerEpoch(address token, uint256 epoch) external view returns (uint256);\n\n    /**\n     * @notice Returns the timestamp when a veNFT was minted\n     * @param tokenId The ID of the veNFT\n     * @return The timestamp when the veNFT was minted\n     */\n    function tokenMintTime(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the accumulated fractional remainder of rewards for a veNFT and token, scaled by 1e18.\n     * @dev During per-epoch reward calculations, integer division can leave a remainder that cannot be paid out.\n     *      This function exposes the running sum of those remainders for the given (token, tokenId) pair,\n     *      scaled by a factor of 1e18 to preserve precision (i.e., value is remainder * 1e18 / totalSupplyAt(epoch)).\n     *      This value is informational and not directly claimable; it helps off-chain analytics understand\n     *      the uncredited fractional rewards that have accumulated over time due to rounding.\n     * @param token The address of the reward token being tracked.\n     * @param tokenId The ID of the veNFT whose fractional remainder is queried.\n     * @return scaledRemainder The accumulated fractional rewards remainder, scaled by 1e18.\n     */\n    function tokenRewardsRemainingAccScaled(address token, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the configured reward recipient address for a specific veNFT\n     * @dev When self-repaying loan functionality is enabled, rewards are sent to this address\n     *      Returns address(0) if no special recipient is configured (rewards go to veNFT owner)\n     * @param tokenId The ID of the veNFT to query\n     * @return The address that receives rewards for this veNFT, or address(0) if it's the owner\n     */\n    function tokenRewardReceiver(uint256 tokenId) external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the address authorized to add rewards to the contract\n     * @dev Can only be called by the current reward distributor\n     *      This is a critical permission that controls who can distribute rewards\n     * @param newRewardDistributor The address of the new reward distributor\n     */\n    function setRewardDistributor(address newRewardDistributor) external;\n\n    /**\n     * @notice Adds new rewards to the distribution pool for the next epoch\n     * @dev Can only be called by the authorized reward distributor address.\n     *      Automatically registers new tokens the first time they're used.\n     *      Rewards added during the current epoch become claimable starting the next epoch.\n     *      Emits a NotifyReward event with details about the distribution.\n     *      Reverts: NotRewardDistributor, zero address/amount checks enforced by implementation.\n     * @param token The address of the reward token to distribute\n     * @param amount The amount of rewards to add to the distribution pool\n     */\n    function notifyRewardAmount(address token, uint256 amount) external;\n\n    /**\n     * @notice Recovers unnotified balances of registered reward tokens\n     * @dev Can only be called by the reward distributor\n     *      For each registered reward token, if the contract's token balance exceeds the credited amount\n     *      tracked by totalRewardsPerToken[token], transfers the excess to the reward distributor and emits\n     *      a RecoverTokens event.\n     */\n    function recoverTokens() external;\n\n    /*//////////////////////////////////////////////////////////////\n                            NOTIFICATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Notifies the contract that a new token has been created\n     * @dev Intended to update internal state or trigger logic after a veNFT creation event\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the token (veNFT) that has been created\n     */\n    function notifyTokenMinted(uint256 tokenId) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is transferred\n     * @dev This function is called by the DustLock contract just after transferring a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being transferred\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was transferred\n     * @param from The address of the previous token owner (sender of the transfer)\n     */\n    function notifyAfterTokenTransferred(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles necessary operations after a veNFT token is burned\n     * @dev This function is called by the DustLock contract just after burning a token\n     *      It performs two main actions:\n     *      1. Claims all pending rewards for the token being burned\n     *      2. Removes the token from the self-repaying loan tracking if enabled\n     *      Can only be called by the DustLock contract.\n     * @param tokenId The ID of the veNFT token that was burned\n     * @param from The address of the previous token owner\n     */\n    function notifyAfterTokenBurned(uint256 tokenId, address from) external;\n\n    /**\n     * @notice Handles bookkeeping after two veNFTs are merged.\n     * @dev Callable only by the DustLock contract.\n     * @param fromToken The tokenId that was merged and is no longer active (source).\n     * @param toToken The tokenId that survives the merge and should receive consolidated accounting (destination).\n     * @param owner The tokens' owner.\n     */\n    function notifyAfterTokenMerged(uint256 fromToken, uint256 toToken, address owner) external;\n\n    /**\n     * @notice Handles bookkeeping after a veNFT is split into two new veNFTs.\n     * @dev Callable only by the DustLock contract.\n     *      - Initializes mint timestamps for the two new tokenIds.\n     *      - Proportionally splits the accumulated fractional rewards remainder (scaled by 1e18)\n     *        from `fromToken` between `tokenId1` and `tokenId2` using their provided amounts.\n     *      - Clears the remainder accumulator for `fromToken` and removes it from any self-repaying\n     *        loan tracking if applicable.\n     * @param fromToken The original tokenId that was split (source).\n     * @param tokenId1 The first resulting tokenId after the split.\n     * @param token1Amount The amount (voting power/shares) assigned to `tokenId1` in the split.\n     * @param tokenId2 The second resulting tokenId after the split.\n     * @param token2Amount The amount (voting power/shares) assigned to `tokenId2` in the split.\n     * @param owner The owner of the tokens involved in the split.\n     */\n    function notifyAfterTokenSplit(\n        uint256 fromToken,\n        uint256 tokenId1,\n        uint256 token1Amount,\n        uint256 tokenId2,\n        uint256 token2Amount,\n        address owner\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               CLAIMING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens\n     * @dev Calculates earned rewards for each specified token using epoch-based accounting and transfers them\n     *      to the appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured\n     *      via enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     */\n    function getReward(uint256 tokenId, address[] calldata tokens) external;\n\n    /**\n     * @notice Claims accumulated rewards for a specific veNFT across multiple reward tokens up to a specified timestamp\n     * @dev Similar to getReward, but allows specifying a custom end timestamp for the reward calculation period.\n     *      Calculates earned rewards for each specified token using epoch-based accounting and transfers them to the\n     *      appropriate recipient. Emits a ClaimRewards event per token. If a reward receiver is configured via\n     *      enableSelfRepayLoan, rewards go to that address; otherwise, rewards are sent to the veNFT owner.\n     *      Updates lastEarnTime to rewardPeriodEndTs to track future accruals (only if there were epochs to process).\n     *      Access: callable by the veNFT owner or an approved operator. The DustLock contract may also call.\n     *      Reverts: NotOwner, EndTimestampMoreThanCurrent, UnknownRewardToken, InvalidArrayLengths.\n     * @param tokenId The ID of the veNFT to claim rewards for\n     * @param tokens Array of reward token addresses to claim (must be registered reward tokens)\n     * @param rewardPeriodEndTs The end timestamp to calculate rewards up to (must not be in the future)\n     */\n    function getRewardUntilTs(uint256 tokenId, address[] calldata tokens, uint256 rewardPeriodEndTs) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays or unknown tokens.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     */\n    function getRewardBatch(uint256[] calldata tokenIds, address[] calldata tokens) external;\n\n    /**\n     * @notice Batch claim rewards for many tokenIds across a set of tokens up to a specific timestamp.\n     * @dev Access: callable by the veNFT owner or an approved operator. Reverts on invalid arrays, unknown tokens,\n     *      or if `rewardPeriodEndTs` is in the future.\n     * @param tokenIds Array of veNFT ids to claim for.\n     * @param tokens Array of reward token addresses to claim.\n     * @param rewardPeriodEndTs End timestamp for calculation (<= now).\n     */\n    function getRewardUntilTsBatch(uint256[] calldata tokenIds, address[] calldata tokens, uint256 rewardPeriodEndTs)\n        external;\n\n    /*//////////////////////////////////////////////////////////////\n                         SELF-REPAYING LOANS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Enables the self-repaying loan feature for a specific veNFT\n     * @dev Configures a custom reward receiver address (typically a loan contract).\n     *      This allows veNFT owners to use their rewards to automatically repay loans.\n     *      The getReward function must still be called to trigger the reward claim.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner, zero rewardReceiver.\n     * @param tokenId The ID of the veNFT to configure self-repaying loan for\n     */\n    function enableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Disables the self-repaying loan feature for a specific veNFT\n     * @dev Removes the custom reward receiver configuration, returning to default behavior.\n     *      After disabling, all future rewards will go directly to the veNFT owner.\n     *      Access: callable only by the veNFT owner.\n     *      Reverts: NotOwner.\n     * @param tokenId The ID of the veNFT to restore default reward routing for\n     */\n    function disableSelfRepayLoan(uint256 tokenId) external;\n\n    /**\n     * @notice Batch enable self-repaying loan with a single receiver for many tokenIds.\n     * @dev Each tokenId must be owned by the caller. Reverts on zero rewardReceiver.\n     * @param tokenIds Array of veNFT ids to configure.\n     */\n    function enableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /**\n     * @notice Batch disable self-repaying loan for many tokenIds.\n     * @dev Each tokenId must be owned by the caller.\n     * @param tokenIds Array of veNFT ids to restore default reward routing.\n     */\n    function disableSelfRepayLoanBatch(uint256[] calldata tokenIds) external;\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Preview unclaimed rewards for a single reward token up to a specific timestamp.\n     * @dev Read-only mirror of claim math; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, UnknownRewardToken if not registered.\n     * @param token Reward token address to preview.\n     * @param tokenId veNFT id to preview for.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return amount Total rewards that would be claimable if claimed up to `endTs`.\n     */\n    function earnedRewards(address token, uint256 tokenId, uint256 endTs) external view returns (uint256 amount);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens at the current timestamp.\n     * @dev Convenience wrapper that uses block.timestamp internally. Returns a matrix of rewards per\n     *      tokenId (outer) per token (inner), and totals per token.\n     *      Reverts: InvalidArrayLengths on bad inputs, UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAll(address[] calldata tokens, uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Preview unclaimed rewards for multiple tokenIds and multiple tokens up to a specific timestamp.\n     * @dev Read-only; does not mutate state, does not advance checkpoints.\n     *      Reverts: EndTimestampMoreThanCurrent if `endTs` is in the future, InvalidArrayLengths on bad inputs,\n     *      UnknownRewardToken if a token is not registered.\n     * @param tokens Array of reward token addresses.\n     * @param tokenIds Array of veNFT ids.\n     * @param endTs Timestamp (<= now) up to which to compute rewards.\n     * @return matrix Rewards matrix with shape [tokenIds.length][tokens.length].\n     * @return totals Totals per token across all tokenIds with shape [tokens.length].\n     */\n    function earnedRewardsAllUntilTs(address[] calldata tokens, uint256[] calldata tokenIds, uint256 endTs)\n        external\n        view\n        returns (uint256[][] memory matrix, uint256[] memory totals);\n\n    /**\n     * @notice Returns the number of registered reward tokens\n     * @return The count of reward tokens\n     */\n    function rewardTokensLength() external view returns (uint256);\n\n    /**\n     * @notice Returns the full list of registered reward tokens\n     * @return tokens An array containing all reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory tokens);\n\n    /**\n     * @notice Returns a list of user addresses with at least one active self-repaying loan within a given range.\n     * @dev Iterates over the internal set of users who have enabled self-repaying loans,\n     *      returning addresses from index `from` up to, but not including, index `to`.\n     *      If the specified range exceeds the number of users, the function adjusts accordingly.\n     * @param from The starting index (inclusive) in the user set.\n     * @param to The ending index (exclusive) in the user set.\n     * @return users An array of user addresses in the specified range who have self-repaying loans enabled.\n     */\n    function getUsersWithSelfRepayingLoan(uint256 from, uint256 to) external view returns (address[] memory);\n\n    /**\n     * @notice Returns the list of token IDs for which the given user has enabled a self-repaying loan.\n     * @dev Checks the user's internal set of token IDs with self-repaying loans and returns them as an array.\n     * @param user The address of the user to query.\n     * @return tokenIds An array of token IDs currently associated with self-repaying loans for the user.\n     */\n    function getUserTokensWithSelfRepayingLoan(address user) external view returns (uint256[] memory tokenIds);\n}\n",
        "keccak256": "0x428b509667becb91cd75d1253139e7765f11f580f5f47e70998f7bb2d4fcc5b6",
        "license": "BUSL-1.1"
      },
      "src/interfaces/IUserVaultFactory.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title IUserVaultFactory\n * @author Neverland\n * @notice Interface for the UserVaultFactory contract.\n *         Allows creation and retrieval of user-specific vaults.\n */\ninterface IUserVaultFactory {\n    /**\n     * @notice Emitted when a new user vault is created\n     * @param user The user for whom the vault was created\n     * @param vault The address of the created vault\n     */\n    event UserVaultCreated(address indexed user, address indexed vault);\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user. Creates a new vault if none exists\n     * @dev If the vault does not exist, a new BeaconProxy is deployed and initialized for the user\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getUserVault(address user) external view returns (address vault);\n\n    /*//////////////////////////////////////////////////////////////\n                               ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the vault address for a given user if it exists\n     * @dev If the vault does not exist, returns address(0)\n     * @param user The address of the user whose vault is being queried or created\n     * @return vault The address of the user's vault\n     */\n    function getOrCreateUserVault(address user) external returns (address vault);\n}\n",
        "keccak256": "0x2c37e5bc81e701ab66b66aea87f6daedf1ec8adf2685d14a66afe77ea477735e",
        "license": "BUSL-1.1"
      },
      "src/libraries/CommonChecksLibrary.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.30;\n\n/**\n * @title CommonChecksLibrary\n * @author Neverland\n * @notice Shared require/revert helpers for zero/invalid values used across contracts\n */\nlibrary CommonChecksLibrary {\n    /// @notice Used when a zero address is provided where not allowed.\n    error AddressZero();\n    /// @notice Used when a zero amount is provided where not allowed.\n    error ZeroAmount();\n    /// @notice Used when a range is invalid.\n    error InvalidRange();\n    /// @notice Used when two addresses are the same but must differ.\n    error SameAddress();\n    /// @notice Used when a balance is zero.\n    error ZeroBalance();\n    /// @notice Used when a tokenId is invalid.\n    error InvalidTokenId();\n    /// @notice Used when a from address is invalid.\n    error InvalidFromAddress();\n    /// @notice Used when a to address is invalid.\n    error InvalidToAddress();\n    /// @notice Used when a user address is invalid.\n    error InvalidUserAddress();\n    /// @notice Used a function is called by an account that is not permitted.\n    error UnauthorizedAccess();\n\n    /**\n     * @notice Reverts if the provided address is zero\n     * @param addressToCheck The address to check\n     */\n    function revertIfZeroAddress(address addressToCheck) internal pure {\n        if (addressToCheck == address(0)) revert AddressZero();\n    }\n\n    /**\n     * @notice Reverts if the provided amount is zero\n     * @param amount The amount to check\n     */\n    function revertIfZeroAmount(uint256 amount) internal pure {\n        if (amount == 0) revert ZeroAmount();\n    }\n\n    /**\n     * @notice Reverts if the [from, to] range is invalid (from > to)\n     * @param from The start of the range\n     * @param to The end of the range\n     */\n    function revertIfInvalidRange(uint256 from, uint256 to) internal pure {\n        if (from > to) revert InvalidRange();\n    }\n\n    /**\n     * @notice Reverts if the two addresses are the same\n     * @param first The first address to check\n     * @param second The second address to check\n     */\n    function revertIfSameAddress(address first, address second) internal pure {\n        if (first == second) revert SameAddress();\n    }\n\n    /**\n     * @notice Reverts if the balance is zero\n     * @param balance The balance to check\n     */\n    function revertIfZeroBalance(uint256 balance) internal pure {\n        if (balance == 0) revert ZeroBalance();\n    }\n\n    /**\n     * @notice Reverts if the tokenId owner is the zero address\n     * @param owner The owner of the tokenId\n     */\n    function revertIfInvalidTokenId(address owner) internal pure {\n        if (owner == address(0)) revert InvalidTokenId();\n    }\n\n    /**\n     * @notice Reverts if the from address is zero\n     * @param from The from address to check\n     */\n    function revertIfInvalidFromAddress(address from) internal pure {\n        if (from == address(0)) revert InvalidFromAddress();\n    }\n\n    /**\n     * @notice Reverts if the to address is zero\n     * @param to The to address to check\n     */\n    function revertIfInvalidToAddress(address to) internal pure {\n        if (to == address(0)) revert InvalidToAddress();\n    }\n\n    /**\n     * @notice Reverts if the user address is zero\n     * @param user The user address to check\n     */\n    function revertIfInvalidUserAddress(address user) internal pure {\n        if (user == address(0)) revert InvalidUserAddress();\n    }\n}\n",
        "keccak256": "0xa8e23a48af12c93a809845953069be6f296d8d2e93e7cd89e5250b15b5d9f805",
        "license": "BUSL-1.1"
      }
    },
    "version": 1
  },
  "address": "0x98A3C29416797Ee10b5714E2aFD07d18D7935864"
}